<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.31
     from zlex.texi on 9 Febuary 1997 -->

<TITLE>Zlex</TITLE>
</HEAD>
<BODY>
<H1>Zlex</H1>
<P>
for Zlex Version 1.02.
<P>
Copyright (C) 1995 Zerksis D. Umrigar
<P>
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.
<P>
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
<P>
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
<P>
<H1><A NAME="SEC1" HREF="zlex_toc.html#SEC1">Introduction</A></H1>
<P>
In order to introduce Zlex, the process of scanning is reviewed and some
terms are introduced.  Zlex is is compared with similar programs and the
motivation for the development of yet another scanner generator is
presented.  An example is used to illustrate the operation of Zlex.
<P>
<H2><A NAME="SEC2" HREF="zlex_toc.html#SEC2">Scanner Generator Overview</A></H2>
Many programming applications require scanning a input stream and
partitioning it into a token stream, where tokens are typically identified
with non-overlapping subsequences of the input stream.  For example, a
natural-language interface will need to partition a stream of characters
into a stream of words, which constitute the tokens.  A compiler for a
programming language will need to partition the stream of characters
representing a program into a stream of literals, reserved words, operators
and identifiers which constitute the tokens of the programming language.
<A NAME="IDX1">.</A>
<P>
A <DFN>scanner</DFN> is a program or portion of a program which performs the task
of partitioning a input stream into a token stream.  Writing a scanner is a
very common programming task: all applications which analyze some form of
text input will usually contain some kind of scanner (even though it may not
be identified as such).  Such scanners are usually written by hand,
typically in a procedural programming language like C or Pascal, where
knowledge about the syntax of tokens is intimately interwoven into
programming constructs which specify how to recognize those tokens. Even
though scanners are usually programs of relatively modest complexity,
maintaining non-trivial hand-written scanners can still be a demanding task.
<A NAME="IDX2">.</A>
<P>
A <DFN>scanner-generator</DFN> is a program which is given a formal
specification of the syntax of tokens and automatically generates a
scanner from those specifications.  Since the specifications are largely
declarative in that they specify only <EM>what</EM> constitutes a token
without specifying <EM>how</EM> to recognize one, they are much easier to
maintain than hand-written scanners.  A pattern language based on
regular expressions is the formalization used to specify the syntax of
tokens for most scanner generators.  The efficiency of a
automatically-generated scanner can be comparable to that of a typical
hand-written scanner.
<P>
See section <A HREF="zlex.html#SEC25">Patterns</A>.
<A NAME="IDX4">.</A>
<A NAME="IDX5">.</A>
<A NAME="IDX3">.</A>
Zlex is such a scanner generator, automatically transforming a scanner
specification into a scanner program.  It accepts a scanner
specification given in a file referred to as the <DFN>Zlex source file</DFN>
and generates a C code file referred to as the <DFN>generated scanner
file</DFN>.  The Zlex source file contains (among other things) patterns
specifying the syntax of tokens.  For each pattern there is also a
corresponding action, consisting of arbitrary C code, which is to be
executed when the input matches the pattern.  These actions are copied
verbatim into the generated scanner.  The generated scanner file needs
to be compiled and linked with the rest of the program and with the Zlex
library to produce an executable program.
<P>
The generated scanner provides a function which is the <DFN>main scanner
function</DFN>.  Whenever this scanner function is called, it scans its input
stream looking for a match with any of the specified patterns.  If it finds
such a match, it executes the action corresponding to the pattern.  If the
action terminates in a return, it returns to its caller; otherwise it
continues scanning the input looking for the next match.  If no pattern
matches the current input character, then the scanner executes a predefined
action which defaults to merely echoing the unmatched character to the
standard output.
<A NAME="IDX6">.</A>
<P>
Once the generated scanner has recognized a token, it is typically
transformed into a small integer for processing by the rest of the
program.  A token typically has at least one attribute: its <DFN>lexeme</DFN>
which is the actual subsequence of the input-stream corresponding to
that token.  The generated scanner allows its actions to access the
lexeme for the current token.
<P>
<H2><A NAME="SEC3" HREF="zlex_toc.html#SEC3">Background</A></H2>
<P>
Scanner-generators were popularized by the scanner-generator <CODE>lex</CODE>
which is distributed with the popular Unix operating system.
Unfortunately, <CODE>lex-generated</CODE> scanners had the reputation of being
less efficient than hand-written scanners.  An attempt to remedy this
efficiency problem resulted in <CODE>flex</CODE> (see section `Flex' in <CITE>Flex - a scanner generator</CITE>) which was extremely successful in attaining
this stated goal.  Zlex is largely upward compatible with both
<CODE>flex</CODE> and lex.  Its raison d'etre is multi-faceted:
<P>
<OL>

<LI>
Even though <CODE>lex</CODE> and <CODE>flex</CODE> have a large number of features,
they are not flexible enough to be used in certain situations.

<LI>
Even though scanning is the problem in which <CODE>lex</CODE> and <CODE>flex</CODE>
specialize, the lexical specifications for their own input languages are
severely restrictive in not allowing the free-form input typical of
modern programming languages.

<LI>
Personal whimsical reasons: I wanted to play around with scanner-generation
algorithms.  I also suspect that I suffer from the NIH (not-invented-here)
syndrome.

</OL>
<P>
The performance of Zlex-generated scanners is comparable to those
generated by <CODE>flex</CODE>, but its additional features enable tasks which
would be very difficult if not impossible with <CODE>flex</CODE>.
<P>
<H2><A NAME="SEC4" HREF="zlex_toc.html#SEC4">An Example</A></H2>
<P>
The following Zlex program counts the number of lines, words and characters
in its standard input, where a <EM>word</EM> is a maximal string of characters
not containing a whitespace character (a whitespace character is defined to
be either a space, tab or new-line).
<P>
<PRE>
001     /* Word-count program for stdin. */
002     %%
003     %{
004       unsigned cc= 0;       /* # of chars seen so far. */
005       unsigned wc= 0;       /* # of words seen so far. */
006       unsigned lc= 0;       /* # of lines seen so far. */
007     %}
008
009
010     [^\t \n]+       wc++; cc+= yyleng;
011     [\t ]+          cc+= yyleng;
012     \n+             lc+= yyleng; cc+= yyleng;
013     &#60;&#60;EOF&#62;&#62;         printf("%d %d %d\n", lc, wc, cc);
</PRE>
<P>
The above program consists of two sections separated by a line containing
only <CODE>%%</CODE>.  The first section is the declarations section which is used
to declare Zlex and C entities (in the above program it is empty).  The
second section contains the patterns along with the corresponding C actions.
<P>
Lines enclosed within decorated-braces <CODE>%{</CODE> and <CODE>%}</CODE> are copied
directly into the generated C-file.  In this example, the lines within
decorated braces at the start of the second section are used to declare and
initialize C variables local to the generated scanner function <CODE>yylex</CODE>.
These variables are counters which keep track of the number of characters,
words and newlines seen so far.
<P>
Line 10 in the second section consists of a pattern to match our
specification of a <EM>word</EM>, followed by a C action.  The <SAMP>`['</SAMP> and
<SAMP>`]'</SAMP> delimit a <EM>character-class</EM> which specifies a set of
characters.  A character-class is a regular expression which matches any
character in that class.  For example, <CODE>[\t \n]</CODE> matches any character
which is a tab, blank or newline (Zlex allows C-style escape sequences
starting with <SAMP>`\'</SAMP> within character-classes).  The <SAMP>`^'</SAMP> at the
beginning of a class denotes the negation of that character-class: hence
<CODE>[^\t \n]</CODE> denotes any character except a tab, blank or newline, i.e. a
non-whitespace character. The postfix operator <SAMP>`+'</SAMP> denotes one or more
repetitions of the previous regular expression: hence <CODE>[^\t \n]+</CODE>
denotes a sequence of one or more non-whitespace characters.  Since Zlex
always prefers the longest possible match, the specified regular expression
will match "a maximal string of characters not containing a whitespace
character" -- namely a <EM>word</EM>.
<P>
The action for the first pattern simply increments the word count <CODE>wc</CODE>
by 1 and increments the character count <CODE>cc</CODE> by the number of
characters matched (the variable <CODE>yyleng</CODE> always contains the length of
the current lexeme).  Lines 11 and 12 handle blanks/tabs and newlines in a
similar manner.  Line 13 contains a special pattern which matches
end-of-file and a action which prints out the values of the three counters.
<P>
Assuming that the above program is in the file <TT>`wc.l'</TT>, it can be
compiled and executed using a sequence of commands similar to the following:
<P>
<PRE>
$ zlex wc.l -o wc.c
$ cc wc.c -lzlex -o wc
$ wc
'Twas brillig, and the slithy toves
  Did gyre and gimble in the wabe:
All mimsy were the borogoves,
     And the mome raths outgrabe.
^D
=>       4      23     135
$
</PRE>
<P>
The option <SAMP>`-o'</SAMP> for both Zlex and the C-compiler cc allows naming the
output file.  The first line transforms the Zlex file <TT>`wc.l'</TT> to a C
file <TT>`wc.c'</TT>.  The second line compiles the C-file into a executable,
linking it with the Zlex library (which provides a default <CODE>main</CODE>
program which merely calls the generated scanner function <CODE>yylex</CODE>).
The third line runs the executable: the next six lines are input followed by
an end-of-file (shown as a <KBD>^D</KBD>).  This is followed by a line which is
the executable's output containing the number of lines, number of words and
number of characters.
<P>
<H2><A NAME="SEC5" HREF="zlex_toc.html#SEC5">Enhancements in Zlex</A></H2>
<P>
The enhancements provided by Zlex over <CODE>lex</CODE> and <CODE>flex</CODE> are
the following:
<P>
<DL COMPACT>

<DT>16-bit character support
<DD>Zlex supports the generation of scanners which process 16-bit character
input.  Unfortunately, due of the limitations of current editors, Zlex still
requires its own source file to be specified using 8-bit characters.  Hence
16-bit characters need to be specified using their character codes (possibly
encapsulated within macros).

With this support for 16-bit characters, it should be possible to use Zlex
to built Unicode scanners, even though Zlex does not know anything about
Unicode per se.

<DT>Intra-token patterns
<DD>These are patterns which can be recognized within other
tokens. See section <A HREF="zlex.html#SEC57">Intra-Token Patterns</A>.  Intra-token patterns are useful
for doing the pre-lexical processing required by some programming
languages (for example, the deletion of a <SAMP>`\'</SAMP> followed by a newline
character in C).

<DT>Column numbers
<DD>Zlex supports obtaining the column number of the current token (in
addition to the undocumented <CODE>yylineno</CODE> feature of <CODE>lex</CODE>.  The
method used does not require the generated scanner to test each incoming
character to see if it is a newline.

<DT>Character count
<DD>It is possible to access the count of the number of characters read from the
current source file.

<DT>Sharing of code among multiple scanners
<DD>Much of the code required for a Zlex scanner is linked in from the Zlex
library.  This library code can be shared among multiple scanners.  The
only code unique to each scanner will be a relatively small main scanner
function and possibly several auxiliary functions (this will be in addition
to several large data tables which will be unique to each scanner).

<DT>Ambiguous right-context patterns.
<DD>Unlike other scanner generators, Zlex can handle ambiguous right context
where the pattern to be matched overlaps with the trailing context.
See section <A HREF="zlex.html#SEC49">Right Context</A>.  The worst case complexity of the method used to
identify such ambiguous trailing context can be quadratic.

<DT>Interactive scanners
<DD>As long as <CODE>&#60;stdio&#62;</CODE> input functions are not used (<SAMP>`--stdio'</SAMP>
option see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>), then all Zlex generated scanners can operate
interactively without any performance degradation.

<DT>Code Scanners
<DD>Zlex supports the generation of directly encoded scanners in addition
to the more conventional scanners which interpret tables.  At this point,
this option does not appear particularly useful.

<DT>Whitespace within patterns
<DD>There is an option <SAMP>`--whitespace'</SAMP> (see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>) which makes Zlex
more tolerant of spaces and comments in the Zlex file.  This allows the Zlex
programmer to format patterns so that they are more readable. See section <A HREF="zlex.html#SEC58">Whitespace Within Patterns</A>.

</DL>
<H1><A NAME="SEC6" HREF="zlex_toc.html#SEC6">The Scanning Process</A></H1>
<P>
When the main scanner function is entered, it initializes its data
structures if it is the first time it has been called.  It then enters a
<DFN>select-act</DFN> loop, where it recognizes a pattern which matches a
prefix of the current input, carries out the specified C action and then
repeats the process on the unprocessed suffix of the input.  If the action
terminates in a return from the main scanner function, then when the scanner
function is called again, it merely reenters the select-act loop.
<P>
The following possibilities arise as the scanner attempts to match its
patterns with a prefix of its input:
<P>
<OL>

<LI>
The prefix of the input matches one or more patterns, but it is possible
that a longer prefix could also match some patterns.  In that case, unless
one of the matched patterns is a intra-token pattern (see section <A HREF="zlex.html#SEC57">Intra-Token Patterns</A>), the scanner looks for the longer match.

<LI>
A single pattern matches a prefix of the input and there is no possibility
that a longer prefix could match any pattern.   In that case, the scanner
executes the action associated with the pattern.

<LI>
Multiple patterns match a prefix of the input and there is no possibility
that a longer prefix could match any pattern.  In that case, the scanner
uses a disambiguating rule to choose a pattern and then executes the action
associated with the chosen pattern.

<LI>
No pattern matches a prefix of the input.  In that situation, the scanner
executes a predefined action.

</OL>
<P>
<H2><A NAME="SEC7" HREF="zlex_toc.html#SEC7">Pattern Conflicts</A></H2>
<P>
When multiple patterns match a prefix of the input, the scanner needs to
choose between these conflicting patterns.  These choices are governed
by the following rules:
<P>
<OL>
<LI>
An intra-token pattern (see section <A HREF="zlex.html#SEC57">Intra-Token Patterns</A>) is preferred over all
other patterns and is matched as soon as it is recognized, even though it
may be a prefix of another pattern.

<LI>
A pattern which matches a longer prefix of the input is preferred over one
which matches a shorter prefix of the input.

<LI>
If two patterns match the same prefix of the input, then the pattern
which occurs earlier in the Zlex source file is preferred.

</OL>
<P>
Hence given the scanner specification:
<P>
<PRE>
%%
while                      <I>`Action for keyword <CODE>while</CODE>.'</I> 
[[:alpha:]_][[:alnum:]_]+  <I>`Action for an identifier.'</I>
</PRE>
<P>
The first pattern simply matches the keyword <SAMP>`while'</SAMP>.  The second
pattern matches an identifier which starts with an alphabetic character or
<SAMP>`_'</SAMP> and is followed by one or more alphanumeric characters or
<SAMP>`_'</SAMP>s.  If the input is <SAMP>`while'</SAMP>, the identifier pattern would match
the prefixes <SAMP>`w'</SAMP>, <SAMP>`wh'</SAMP>, <SAMP>`whi'</SAMP>, <SAMP>`whil'</SAMP> and <SAMP>`while'</SAMP>;
the <CODE>while</CODE> keyword pattern would match the entire input.  By rules (2)
and (3), the <I>`Action for keyword <CODE>while</CODE>.'</I> will be that executed by
the generated scanner.
<P>
<H2><A NAME="SEC8" HREF="zlex_toc.html#SEC8">Backtracking in Zlex Scanners</A></H2>
<P>
As a character is scanned by a Zlex scanner, it may tentatively be matched
with a pattern, but subsequently it may be discovered that the tentative
pattern match is incorrect and that the character needs to be rescanned
for an alternate match.  <DFN>Backtracking</DFN> refers to the rescanning of
characters to identify alternate matches.
<P>
Most Zlex scanners will do some backtracking under normal operation.
Backtracking can also be forced by the Zlex programmer by using the special
<CODE>REJECT</CODE> action (see section <A HREF="zlex.html#SEC82">Forced Backtracking: <CODE>REJECT</CODE></A>).
<A NAME="IDX7">.</A>
<P>
As a Zlex scanner scans its input, it usually looks ahead by a single
character to decide which pattern it is in, and whether it has reached the
end of a pattern.  That single character lookahead is not always sufficient:
the scanner may have to scan several extra characters before it can be sure
which action to take.
<P>
Consider the following scanner which ignores an alphabetic string if it is
followed by a digit, but outputs an alphabetic string in blank-separated
groups of upto 4 characters when it is not followed by a digit.
<P>
<PRE>
%%
[[:alpha:]]{4}                  printf("%s ", yytext);
[[:alpha:]+/[[:digit:]]         /* No action. */
.|\n                            ECHO;
</PRE>
<P>
The first pattern matches a sequence of exactly four alphabetical
characters (indicated by the <SAMP>`{4}'</SAMP>).  The second pattern matches
a sequence of one or more alphabetical characters only if it is followed
by a digit (indicated by the trailing context <SAMP>`/[[:digit:]]'</SAMP>).  The
final pattern matches any single character.
<P>
Consider the input line
<P>
<PRE>
abcdefg
</PRE>
<P>
The scanner will scan all the characters in <SAMP>`abcdefg'</SAMP> before it
realizes that the newline terminating this alphabetic string is not a digit
and hence the second pattern cannot match.  It will match the first pattern
using <SAMP>`abcd'</SAMP> returning <SAMP>`efg'</SAMP> to the input stream.  As part of the
action of matching the first pattern it will output <SAMP>`abcd '</SAMP>, and
will then resume scanning.  It will then look at the <SAMP>`efg'</SAMP> it pushed
back, scanning past all three characters before realizing that the input
does not match either of the first two patterns.  The only alternative is
the third pattern which it matches, <CODE>ECHO</CODE>ing <SAMP>`e'</SAMP>, and pushing
back <SAMP>`fg'</SAMP>.  The same sequence of overscan and pushback repeats for
<SAMP>`fg'</SAMP> with output <SAMP>`f'</SAMP> and pushback <SAMP>`g'</SAMP>.  Finally the remaining
<SAMP>`g'</SAMP> matches the last pattern.  The output is:
<P>
<PRE>
abcd efg
</PRE>
<P>
Note that the <SAMP>`e'</SAMP> is scanned twice, the <SAMP>`f'</SAMP> thrice, and the
<SAMP>`g'</SAMP> four times.
<P>
This sort of backtracking in Zlex is not inordinately expensive, but should
be avoided if possible.  As illustrated by the above example, the
backtracking arises because of overlapping patterns: hence overlapping
patterns should be avoided as far as possible.
<P>
<H2><A NAME="SEC9" HREF="zlex_toc.html#SEC9">Default Action</A></H2>
By default, characters which are not matched by any pattern are
<CODE>ECHO</CODE>ed to <CODE>yyout</CODE> (see section <A HREF="zlex.html#SEC88">Output in a Zlex Scanner</A>).  This default action
can be suppressed by specifying the <CODE>--suppress-default</CODE> option
(see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>).  
<P>
A scanner which marks all lines containing character sequences which look
like ANSI-C trigraphs (which start with a sequence of 2 <SAMP>`?'</SAMP>s) can be
generated from the following:
<P>
<PRE>
%%
.*"??".+        printf("*** %s", yytext);
</PRE>
<P>
The <SAMP>`.'</SAMP> is a regular expression which matches any character except
newline; the <SAMP>`*'</SAMP> is a postfix operator which specifies 0 or more
repetitions of the preceeding regular expression; the <SAMP>`+'</SAMP> is a postfix
operator which specifies 1 or more repetitions of the preceeding regular
expression.  Hence the pattern will match only lines containing a sequence
of at least two <SAMP>`?'</SAMP> followed by at least one other (non-newline)
character.  The action specified for that pattern prints out the contents of
the matching line (<CODE>yytext</CODE>) preceeded by a mark <SAMP>`*** '</SAMP>. Lines
which do not match the specified pattern will be handled character by
character by the default action and echoed to <CODE>yyout</CODE>.
<P>
For all applications except very simple filters, usually it is not a good
idea to depend on this default behavior for the following reasons:
<P>
<UL>
<LI>
Since it can be confusing to a user to have an application suddenly echo
characters not recognized by its scanner, every possible character should be
handled explicitly by scanner patterns.  At minimum, the scanner should
specify a final pattern like <CODE>.|\n</CODE> (with an error action) to ensure
that every character will be matched.  Such patterns will also need to be
provided for every exclusive start state (see section <A HREF="zlex.html#SEC55">Start State Patterns</A>).

<LI>
Since the default action processes only a single character at a time, it is
somewhat inefficient (see section <A HREF="zlex.html#SEC139">Efficiency</A>).
</UL>
<P>
<H1><A NAME="SEC10" HREF="zlex_toc.html#SEC10">The Structure of the Zlex Input File</A></H1>
<P>
A Zlex file consists of upto three sections, with each section used for
different purposes.  The delimiter sequence <CODE>%%</CODE> on a line by itself is
used to separate sections.
<P>
The text contained in these sections is of two types:
<P>
<OL>
<LI>
Text which is absorbed by Zlex.

<LI>
Text which is treated as a block of code to be copied into the generated
scanner.  This text is delimited by being enclosed within braces, decorated
braces (<SAMP>`%{'</SAMP> and <SAMP>`%}'</SAMP>) or by being indented (see section <A HREF="zlex.html#SEC12">Code Blocks</A>).
</OL>
<P>
<A NAME="IDX8">.</A>
<H2><A NAME="SEC11" HREF="zlex_toc.html#SEC11">Comments</A></H2>
In a Zlex file, comments enclosed within <SAMP>`/*'</SAMP> and <SAMP>`*/'</SAMP> can
span multiple lines.  It is also possible to have comments within patterns
if the <SAMP>`--whitespace'</SAMP> option is used (see section <A HREF="zlex.html#SEC58">Whitespace Within Patterns</A>).
<P>
<H2><A NAME="SEC12" HREF="zlex_toc.html#SEC12">Code Blocks</A></H2>
Code blocks which are to be copied into the generated scanner can be
delimited in any one of the following ways:
<A NAME="IDX9">.</A>
<P>
<DL COMPACT>
<DT>C-Code
<DD>A C-code block starts with a left-brace <SAMP>`{'</SAMP>.  Text starting with the
<SAMP>`{'</SAMP>, upto and including the <EM>balancing</EM> right-brace <SAMP>`}'</SAMP> is
copied into the generated scanner.  Note that braces enclosed within C-style
comments, strings or character-constants are not counted when finding the
balancing <SAMP>`}'</SAMP>.  Escaped newlines (<SAMP>`\'</SAMP> followed by a newline
character) are recognized within C-strings, but not within other constructs.

The knowledge of C which is used to look for the balancing <SAMP>`}'</SAMP> is
incomplete and relatively easy to fool.  For example, Zlex would get
hopelessly confused if a Zlex programmer were to <CODE>#define</CODE> the macro
<CODE>END</CODE> to be <SAMP>`}'</SAMP>, and then used <CODE>END</CODE> instead of <SAMP>`}'</SAMP>:
Zlex does not know anything about C-preprocessing.

<DT>Decorated-Brace Code
<DD>This is signalled by a line which begins with a decorated left-brace
<CODE>%{</CODE>.  The <EM>rest</EM> of the line and all subsequent lines are copied
to the generated scanner until a line starting with a decorated right-brace
<CODE>%}</CODE> is encountered. The delimiting <CODE>%{</CODE> and <CODE>%}</CODE> are not
copied.  The contents of the copied text are not analyzed at all.

<DT>Indented Code
<DD>The text is on a line which begins with a space or a tab and the first
non-blank characters are not <SAMP>`{'</SAMP> or <SAMP>`/*'</SAMP>.  In that case, the rest
of the line is copied to the generated scanner without any further
processing, as are all immediately following indented lines.

<DT>Pattern Code
<DD>The text follows a pattern in section 2 of the Zlex file and does not start
with a <SAMP>`{'</SAMP>.  The entire line except for the pattern and immediately
following whitespace are copied to the generated scanner without any further
processing as though it was indented code.  Note that pattern code blocks
can only be used when the option <SAMP>`--no-whitespace'</SAMP> has been specified
(the default), as with <SAMP>`--whitespace'</SAMP> the pattern code block will be
regarded as part of the pattern.

</DL>
<P>
Note that the text within decorated-brace, indented or pattern code blocks
is not analyzed in any way.  This has the advantage of language
independence: if Zlex were to be retargeted to generate a scanner in a
language other than C, there would be no change in the specifications for
these code blocks.  The disadvantage is that it is impossible for Zlex to
recognize the terminating delimiter for the code block when it occurs within
a target language construct like a comment or string.
<P>
<A NAME="IDX10">.</A>
<H2><A NAME="SEC13" HREF="zlex_toc.html#SEC13">Declarations Section</A></H2>
This section contains the declarations of Zlex and C entities.
It is the first section in the Zlex source file and must be present (even
though it may be empty).  Hence the simplest possible Zlex source is
<P>
<PRE>
%%
</PRE>
<P>
which merely copies its input to its output using the default rule
(see section <A HREF="zlex.html#SEC9">Default Action</A>).  
<P>
Besides comments, this declarations section can contain the following:
<P>
<DL COMPACT>
<DT>C Declarations
<DD>These are copied directly into the generated scanner.  They can be delimited
in any of the ways outlined (see section <A HREF="zlex.html#SEC12">Code Blocks</A>).  Traditionally, decorated
braces have been used to delimit these code blocks.

<DT>Macro Definitions
<DD>The definition of a Zlex macro consists of a line starting with the name of
the macro followed by whitespace, followed by a regular expression giving
the definition of the macro (see section <A HREF="zlex.html#SEC34">Regular Expression Macros</A>).

<DT>Directives
<DD>This consists of a line starting with a <CODE>%</CODE> character followed by an
alphabetic string specifying the directive.  The directives currently
accepted include:

<DL COMPACT>
<DT><CODE>%option</CODE>
<DD>This can be followed by options as they would be specified on the command-line
(see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>).  The options actually specified on the command-line
override the options specified in the source file using this directive.
<CODE>%option</CODE> directives must precede all other directives.  

<DT><CODE>%array</CODE>
<DD>Is equivalent to <CODE>%option --array</CODE>.

<DT><CODE>%pointer</CODE>
<DD>Is equivalent to <CODE>%option --pointer</CODE>.

<DT><CODE>%s</CODE> or <CODE>%S</CODE>
<DD>These directives are used to declare inclusive start states.  The directive
can be followed by one or more space-separated start state names
(see section <A HREF="zlex.html#SEC63">Start States</A>).

<DT><CODE>%x</CODE> or <CODE>%X</CODE>
<DD>These directives are used to declare exclusive start states.  The directive
can be followed by one or more space-separated start state names
(see section <A HREF="zlex.html#SEC63">Start States</A>).

<DT>Obsolete lex Directives
<DD>These are allowed only for backward compatibility with lex.  They have no
effect on Zlex and are undocumented as far as Zlex is concerned.
</DL>
</DL>
<P>
<H2><A NAME="SEC14" HREF="zlex_toc.html#SEC14">Rules Section</A></H2>
This is the second section in the Zlex file.  It consists of an optional
initial C-code section (see section <A HREF="zlex.html#SEC12">Code Blocks</A>) followed by pattern-action
rules.
<P>
If the optional initial C-code section is present, it is copied into the
beginning of the generated scanner function.  It can be used to declare and
initialize any local variables needed by the Zlex programmer.
<P>
A pattern-action rule consists of a pattern (see section <A HREF="zlex.html#SEC25">Patterns</A>) followed by a
action.  The possibilities for an action are:
<P>
<DL COMPACT>
<DT>Empty Action
<DD>No action is specified.  This means that when a token corresponding to the
pattern is recognized, it is simply discarded.

<DT>C Code Block
<DD>The action consists of the concatenation of all the following code blocks
which do not have any intervening pattern (see section <A HREF="zlex.html#SEC12">Code Blocks</A>).
Traditionally, the action is specified by a <EM>single</EM> brace-enclosed C
code block which starts on the same line as the pattern.  When a token
specified by the pattern is recognized, the specified action is carried out.

<DT>Next Pattern Action <SAMP>`|'</SAMP>
<DD>This special action specifies that the action for this pattern is the same
as the action for the next pattern.
</DL>
<P>
<H2><A NAME="SEC15" HREF="zlex_toc.html#SEC15">Code Section</A></H2>
The third section of the Zlex source file consists of C code typically
containing the definitions of some of the C objects declared in the first
section.  It is simply copied unchanged into the generated scanner file.
<P>
<H2><A NAME="SEC16" HREF="zlex_toc.html#SEC16">Line Directives</A></H2>
<A NAME="IDX11">.</A>
<A NAME="IDX12">.</A>
<A NAME="IDX13">.</A>
<A NAME="IDX14">.</A>
<P>
At any point in a zlex source file, outside a code block or a comment a line
which looks like
<PRE>
%line   <VAR>nnn</VAR>       <VAR>file-name</VAR>
</PRE>
will pretend that the following line is line number <VAR>nnn</VAR> from
<VAR>file-name</VAR>.  The <VAR>file-name</VAR> is any string not containing newlines
enclosed within double quotes <SAMP>`"'</SAMP>: it may contain ANSI-C escape
sequences.  Both the line number <VAR>nnn</VAR> and <VAR>file-name</VAR> are optional.
<P>
A <CODE>%line</CODE> directive, like all other directives, is only recognized when
it occurs at the start of a line.  It is useful to track the origin of
source lines when a zlex file is generated automatically from another source
file by a preprocessor.  The <CODE>%line</CODE> directive is similar to the
<CODE>#line</CODE> directive accepted by C-preprocessors.
<P>
If a <CODE>%line</CODE> directive occurs in section 2 of the zlex source file,
then it may break old <CODE>lex</CODE> or <CODE>flex</CODE> programs which would regard
the character sequence <SAMP>`%line'</SAMP> at the start of a line as a pattern.
Hence the <CODE>%line</CODE> directive is not recognized in section 2 of the Zlex
source file when the <SAMP>`--lex-compat'</SAMP> option is specified
(see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>).
<P>
<H1><A NAME="SEC17" HREF="zlex_toc.html#SEC17">C Interface Conventions</A></H1>
<P>
The Zlex programmer is provided with C objects for accessing information
about and controlling the operation of the generated scanner.  The C
entities used for this interface are functions, variables and macros.  For
example, Zlex provides a main scanner function with default name
<CODE>yylex</CODE>; the text of the last matched token can be accessed using
variables with default names <CODE>yytext</CODE> and <CODE>yyleng</CODE>; Zlex provides
the C macro <CODE>REJECT</CODE> to find an alternate way to tokenize the current
input.
<P>
Certain conventions are used in naming these entities.  Many of these names
can be changed by the Zlex programmer.  Many entities also have alternate
names.  When we refer to an entity in this manual we usually refer to it by
its <DFN>common name</DFN>, which is the way it was referred to in historical
implementations.
<P>
<H2><A NAME="SEC18" HREF="zlex_toc.html#SEC18">Naming Conventions</A></H2>
<P>
Certain conventions are used by Zlex in choosing the names for
programmer-visible C entities.
<P>
<A NAME="IDX15">.</A>
<H3><A NAME="SEC19" HREF="zlex_toc.html#SEC19">Macros Names</A></H3>
There is a canonical form for all macro names defined by Zlex in the
generated scanner.  A <DFN>canonical macro name</DFN> starts with the prefix
<SAMP>`YY_'</SAMP>, has all letters capitalized, and words are separated by
underscores.  Examples of canonical macro names are <CODE>YY_REJECT</CODE> and
<CODE>YY_NEW_FILE</CODE>.  
<P>
In order to retain compatibility with <CODE>lex</CODE> and <CODE>flex</CODE>,
alternate names are provided for some macros.  These alternate names do
not meet the above conventions for canonical names.  For example,
<CODE>REJECT</CODE> is an alternate name for <CODE>YY_REJECT</CODE>.
<P>
Unfortunately, there is no consistency whether the call of a macro <VAR>M</VAR>
which does not require any arguments is written as <CODE><VAR>M</VAR>()</CODE> or
simply <CODE><VAR>M</VAR></CODE>.  This inconsistency arises because of the need to
maintain backward compatibility with <CODE>lex</CODE> and <CODE>flex</CODE>.
<P>
<A NAME="IDX16">.</A>
<H3><A NAME="SEC20" HREF="zlex_toc.html#SEC20">Variable Names</A></H3>
By default, the names of all variables begin with the prefix <SAMP>`yy'</SAMP>,
though this prefix can be changed by using the <SAMP>`--prefix'</SAMP> option
(see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>).  The default variable names usually contain only
lower-case letters, though in a few cases, they also contain underscores for
backward compatibility.  It is possible for the user to specify an arbitrary
name for any variable by defining an appropriate C-macro.
<P>
For example, the default name of the variable which holds the length of the
current lexeme is <SAMP>`yyleng'</SAMP> (see section <A HREF="zlex.html#SEC61">Current Lexeme Length: <CODE>yyleng</CODE></A>).  If at scanner
generation time, the programmer specifies the option <SAMP>`--prefix=lex_'</SAMP>,
then the name of the variable will be <SAMP>`lex_len'</SAMP>.  If the programmer
<CODE>#define</CODE>s the macro <CODE>YY_LENG</CODE> to be <CODE>tokLength</CODE>, then the
name will be <SAMP>`tokLength'</SAMP>.
<P>
<A NAME="IDX17">.</A>
<H3><A NAME="SEC21" HREF="zlex_toc.html#SEC21">Function Names</A></H3>
There is only one documented function in the generated scanner file: this is
the main scanner function with default name <CODE>yylex</CODE>.  Its name can be
changed in a manner similar to variable names (see section <A HREF="zlex.html#SEC20">Variable Names</A>), by
either specifying the <SAMP>`--prefix'</SAMP> option during scanner generation or by
defining the macro <CODE>YY_LEX</CODE>.  For example, if during scanner generation
the programmer specifies the option <SAMP>`--prefix=scan'</SAMP>, then the name of
the main scanning function will be <SAMP>`scanlex'</SAMP>.  If the programmer
<CODE>#define</CODE>s the macro <CODE>YY_LEX</CODE> to be <CODE>scan</CODE>, then the name of
the function will be <SAMP>`scan'</SAMP>.
<P>
The other documented functions are those in the Zlex library.  With one
exception, the names of all these library functions start with the prefix
<SAMP>`yy'</SAMP>.  They do not contain any underscores, but the first letter of
each word is capitalized.  It is not possible to change these names as they
are precompiled into the Zlex library when it is built during installation.
Examples of these library function names are <CODE>yyCreateBuffer</CODE>,
<CODE>yyTopState</CODE> and <CODE>yySwitchToBuffer</CODE>.
<A NAME="IDX18">.</A>
<P>
The one exception to the rule for library function names is the function
<CODE>main</CODE> which is a default main program which simply invokes
<CODE>yylex()</CODE>.  
<P>
<A NAME="IDX19">.</A>
<H3><A NAME="SEC22" HREF="zlex_toc.html#SEC22">Private Names</A></H3>
Some names are used by Zlex for its own internal purposes.  All these
private names start with the prefix <SAMP>`yy'</SAMP> or <SAMP>`YY'</SAMP>, independent of
the <SAMP>`--prefix'</SAMP> option.  The user is urged to avoid using names starting
with these prefixes to prevent possible name clashes.
<P>
<A NAME="IDX20">.</A>
<H2><A NAME="SEC23" HREF="zlex_toc.html#SEC23">Scope of Names</A></H2>
The names provided by Zlex have three kinds of scope:
<P>
<DL COMPACT>
<A NAME="IDX21">.</A>
<DT>Scanner Function Scope
<DD>If a name has scanner function scope, its use is meaningful only within the
main scanner function.  In practice, this means that the programmer can use
these names only within the actions associated with patterns and not in any
other functions.  Examples of names with scanner function scope are
<CODE>YY_REJECT</CODE> and <CODE>yy_act</CODE>.

<A NAME="IDX22">.</A>
<DT>File Scope
<DD>Names with file scope are meaningful only within the generated scanner
file.  All macro names which do not have scanner function scope have file
scope.  

<A NAME="IDX23">.</A>
<DT>Program Scope
<DD>Names with program scope can be used through-out the program.  All public
function names and variable names have program scope.  No macro name has
program scope.

</DL>
<P>
The effect of using a name outside its intended scope is undefined.  In
practice, it will usually result in a compiler error when compiling the
generated scanner.
<P>
<A NAME="IDX24">.</A>
<A NAME="IDX25">.</A>
<A NAME="IDX26">.</A>
<H2><A NAME="SEC24" HREF="zlex_toc.html#SEC24">Passing the Scanner State to Zlex Library Routines</A></H2>
Many of the Zlex library routines need to know the current state of
private scanner variables to perform their tasks.  This need is met by
passing the state via an opaque pointer to <CODE>void</CODE>, <CODE>typedef</CODE>'d
as a <CODE>YYDataHandle</CODE>.  This pointer can be found in a variable with
default name <CODE>yydataP</CODE> having <CODE>extern</CODE> linkage.  Like all
other variable names, the name of this variable can be changed to an
arbitrary name by defining the macro <CODE>YY_DATA_P</CODE> to the new name.
Alternatively, the prefix used for the name can be changed by using the
<SAMP>`--prefix'</SAMP> option (see section <A HREF="zlex.html#SEC20">Variable Names</A>).
<P>
Since this variable has external linkage, it can be accessed from files
other than the generated scanner file and passed as a handle to Zlex library
routines.
<P>
<H1><A NAME="SEC25" HREF="zlex_toc.html#SEC25">Patterns</A></H1>
<A NAME="IDX27">.</A>
<P>
The pattern language used for expressing the syntax of tokens is essentially
the language of regular expressions, extended with constructs which allow
context-dependent matching.
<P>
Note that we distinguish between <EM>patterns</EM> and <EM>regular
expressions</EM>.  Patterns are regular expressions augmented with
context-sensitive operators.  All regular expressions are patterns but not
all patterns are regular expressions.
<P>
<H2><A NAME="SEC26" HREF="zlex_toc.html#SEC26">Meta-Characters</A></H2>
<A NAME="IDX28">.</A>
<P>
In patterns, most characters usually stand for themselves: i.e. the
occurrence of a particular character in a pattern specifies that that
particular character should be matched.  However some characters do not
stand for themselves but are special meta-characters which tell Zlex how to
combine patterns.  The meta-characters used by Zlex are the following:
<P>
<PRE>
        \ " ( ) { } &#60; &#62; . ? | + * / ^ $ , -
</PRE>
<P>
If a pattern is required to match any of the above characters, then the
character can be quoted by preceeding it by a backslash <SAMP>`\'</SAMP>.  If a
pattern is required to match a backslash, then the backslash itself can be
quoted by using <CODE>\\</CODE>.  Any character other than a <SAMP>`\'</SAMP> or <SAMP>`"'</SAMP>
can also be quoted by simply enclosing it within <SAMP>`"'</SAMP> delimiters.
<P>
There are some contexts within which the above set of meta-characters is
reduced.  Since it can be difficult to remember exactly which characters are
special within which contexts, it is advisable for the Zlex programmer to
quote all non-alphanumeric characters which are to be matched literally.
<P>
<A NAME="IDX29">.</A>
<H2><A NAME="SEC27" HREF="zlex_toc.html#SEC27">Regular Expressions</A></H2>
Regular expressions are a concise notation for specifying the syntax of
tokens.  Regular expression syntax uses the following constructs and
operators.
<P>
<H3><A NAME="SEC28" HREF="zlex_toc.html#SEC28">Single Characters</A></H3>
Any character which is not a meta-character is a regular expression which
matches itself.
<P>
<H4>Examples</H4>
<P>
<UL>

The regular expression <CODE>A</CODE> matches the character <SAMP>`A'</SAMP>.

The regular expression <CODE>#</CODE> matches the character <SAMP>`#'</SAMP>.  However,
since <SAMP>`#'</SAMP> is a non-alphanumeric character it is advisable to quote it
by escaping it using a <SAMP>`\'</SAMP> as <CODE>\#</CODE> or by enclosing it within
<SAMP>`"'</SAMP> delimiters as <CODE>"#"</CODE>.

<CODE>+</CODE> is <EM>not</EM> a regular expression since <SAMP>`+'</SAMP> is a
meta-character.

</UL>
<P>
<A NAME="IDX30">.</A>
<A NAME="IDX31">.</A>
<H3><A NAME="SEC29" HREF="zlex_toc.html#SEC29">Escape Sequences</A></H3>
The backslash character can be used to quote characters and specify
character escapes in a manner similar to C.  Specifically:
<P>
<UL>
<LI>
<CODE>\a</CODE>, <CODE>\b</CODE>, <CODE>\f</CODE>,
<CODE>\n</CODE>, <CODE>\r</CODE>, <CODE>\t</CODE>, <CODE>\v</CODE> are regular expressions which
match the characters <KBD>BEL</KBD> (bell), <KBD>BS</KBD> (backspace), <KBD>FF</KBD>
(form-feed), <KBD>NL</KBD> (newline), <KBD>CR</KBD> (carriage-return), <KBD>TAB</KBD>
(tab) and <KBD>VT</KBD> (vertical-tab) respectively.  

<A NAME="IDX32">.</A>
<LI>
<SAMP>`\'</SAMP> followed by upto 3 octal digits is a regular expression which
matches the character with character code equal to the octal number.

<A NAME="IDX33">.</A>
<LI>
<SAMP>`\x'</SAMP> followed by a hexadecimal number is a regular expression which
matches the character with character code equal to the hexadecimal number.

<LI>
<SAMP>`\'</SAMP> followed by any other character (except newline) is a regular
expression which matches that character.

</UL>
<H4>Examples</H4>
<P>
<UL>

<SAMP>`\x81'</SAMP> matches the character whose decimal character code is 129.

<SAMP>`\400'</SAMP> should match the character whose decimal character code is 256.
However, this is invalid since Zlex currently only supports character codes
in the range 0--255.

</UL>
<A NAME="IDX34">.</A>
<P>
<H3><A NAME="SEC30" HREF="zlex_toc.html#SEC30">Character Classes</A></H3>
A character class is a regular expression denoting a set of characters which
will match any single character in the set.  Character classes are specified
by listing the members of the set enclosed within <SAMP>`['</SAMP> and <SAMP>`]'</SAMP>. It
is possible to denote ranges of characters in a character class by using
<CODE><VAR>lo</VAR>-<VAR>hi</VAR></CODE>, where <VAR>lo</VAR> and <VAR>hi</VAR> are the first and last
characters in the range.  A negated character class is a character class
whose first character is <SAMP>`^'</SAMP> and denotes the complement of the
character class.  Escape sequences (see section <A HREF="zlex.html#SEC29">Escape Sequences</A>) are recognized within a
character-class.  The rules for recognizing special characters within
character-classes are different from those for other patterns and are given
below:
<P>
<DL COMPACT>

<DT><SAMP>`\'</SAMP>
<DD>This is the only character which is special through-out a character class.
It is used to specify escape sequences.  It can be included by quoting it
with itself as <SAMP>`\\'</SAMP>.

<A NAME="IDX35">.</A>
<DT><SAMP>`^'</SAMP>
<DD>This is special only at the beginning of a character class (immediately
after the <SAMP>`['</SAMP> signalling the start of the character class).  It signals
the start of a negated character class.

<A NAME="IDX36">.</A>
<DT><SAMP>`-'</SAMP>
<DD>This is special and used to denote character ranges when used <EM>within</EM>
a character class; it is not special and stands for itself when used at the
beginning of the class (immediately after the <SAMP>`['</SAMP> signalling the start
of the character class or immediately after the negated-class operator
<SAMP>`^'</SAMP>) or at the end (just before the terminating <SAMP>`]'</SAMP>). 

<DT><SAMP>`]'</SAMP>
<DD>This is special when used after the beginning of the character class and
terminates the character class; it is not special and stands for itself when
used right at the beginning of the class (immediately after the <SAMP>`['</SAMP>
signalling the start of the character class or immediately after the
negated-class operator <SAMP>`^'</SAMP>).

</DL>
<P>
Any whitespace character (except newline) is significant within a character
class and specifies a character within the class.  Comments are never
recognized within a character class.  Hence the character class
<CODE>[/*a */ a]</CODE> would contain the four characters <SAMP>` '</SAMP>, <SAMP>`/'</SAMP>,
<SAMP>`*'</SAMP> and <SAMP>`a'</SAMP>.  Newlines are not allowed directly within a character
class and must be specified using the escape sequence <SAMP>`\n'</SAMP>.
<P>
<H4>Examples</H4>
<P>
<UL>

<CODE>[lL]</CODE> matches any one of the characters <SAMP>`l'</SAMP> or <SAMP>`L'</SAMP>.

<CODE>[0-9a-fA-F]</CODE> matches any hexadecimal digit.

<CODE>[^0-9a-zA-Z]</CODE> matches any non-alphanumeric character.

<CODE>[-+]</CODE> or <CODE>[+-]</CODE> matches any one of the characters <CODE>+</CODE> or
<SAMP>`-'</SAMP>.

<CODE>[\t \n]</CODE> matches a tab, space or newline character.

</UL>
<P>
<A NAME="IDX37">.</A>
<H3><A NAME="SEC31" HREF="zlex_toc.html#SEC31">Named Character Classes</A></H3>
<P>
Specifying lowercase alphabetic characters using a pattern like <CODE>[a-z]</CODE>
may not work with character sets other than ASCII as the character codes for
lower-case letters may not always be contiguous in the underlying character
set.  To remedy this problem, POSIX introduced named character classes of
the form <CODE>[:<VAR>Name</VAR>:]</CODE>.  The class represented by
<CODE>[:<VAR>Name</VAR>:]</CODE> is precisely the set of characters <VAR>c</VAR> for which
the standard C-library function <CODE>is<VAR>Name</VAR>(<VAR>c</VAR>)</CODE> returns
non-zero.
<P>
<DL COMPACT>
<DT><CODE>[:alnum:]</CODE>
<DD>An upper or lower-case alphabetic character or a decimal digit.

<DT><CODE>[:alpha:]</CODE>
<DD>An upper or lower-case alphabetic character.

<DT><CODE>[:blank:]</CODE>
<DD>A space <SAMP>` '</SAMP> or tab <SAMP>`\t'</SAMP> character.

<DT><CODE>[:cntrl:]</CODE>
<DD>A control character.

<DT><CODE>[:digit:]</CODE>
<DD>A digit.

<DT><CODE>[:graph:]</CODE>
<DD>Any printing character (not a control character) other than a space character.

<DT><CODE>[:lower:]</CODE>
<DD>A lower-case letter.

<DT><CODE>[:print:]</CODE>
<DD>Any printing character (not a control character), including a space character.

<DT><CODE>[:punct:]</CODE>
<DD>A punctuation character which is a printing character but not a space 
character or alphanumeric character.

<DT><CODE>[:space:]</CODE>
<DD>A space <SAMP>` '</SAMP>, tab <SAMP>`\t'</SAMP>, carriage return <SAMP>`\r'</SAMP>, newline
<SAMP>`\n'</SAMP>, vertical tab <SAMP>`\v'</SAMP> or form-feed <SAMP>`\f'</SAMP> character.

<DT><CODE>[:upper:]</CODE>
<DD>An upper-case letter.

<DT><CODE>[:xdigit:]</CODE>
<DD>A hexadecimal digit.
</DL>
<P>
These named classes cannot occur directly in a pattern but only as members
of a character class.  Hence <CODE>[:alpha:]</CODE> is not a valid pattern but
<CODE>[[:alpha:]]</CODE> is.
<A NAME="IDX38">.</A>
<P>
<H3><A NAME="SEC32" HREF="zlex_toc.html#SEC32">Any Character Except Newline</A></H3>
<SAMP>`.'</SAMP> is a regular expression which matches any character except newline.
<P>
<H4>Example</H4>
<P>
<UL>
<CODE>.|\n</CODE> is a pattern which matches any character (<SAMP>`|'</SAMP> is a
regular expression operator specifying the union of two regular
expressions). 
</UL>
<P>
<A NAME="IDX39">.</A>
<P>
<H3><A NAME="SEC33" HREF="zlex_toc.html#SEC33">String Quoting</A></H3>
A string of characters enclosed within double-quotes <SAMP>`"'</SAMP> is a regular
expression which matches that string of characters.  Escape
sequences are recognized within the string.  The
characters which are special within the string are <SAMP>`\'</SAMP> (used for
escaping characters) and <SAMP>`"'</SAMP> (used for terminating the string) and must
be escaped with a preceeding <SAMP>`\'</SAMP> if they are to be included within the
string.  A newline cannot be contained directly within a string regular
expression, but must be specified using a escape sequence as <SAMP>`\n'</SAMP>.
<P>
<H4>Examples</H4>
<P>
<UL>

<CODE>"[]"</CODE> matches the string consisting of the two characters <SAMP>`[]'</SAMP>.

<CODE>"\x30\0\"\\\n"</CODE> matches the string containing five characters: the
first character has the hexadecimal character code <CODE>30</CODE>, the second
character has the character code 0, the third and fourth characters are
<SAMP>`"'</SAMP> and <SAMP>`\'</SAMP> respectively, and the last character is the newline
character.
</UL>
<P>
<A NAME="IDX40">.</A>
<H3><A NAME="SEC34" HREF="zlex_toc.html#SEC34">Regular Expression Macros</A></H3>
A macro can be defined in section 1 of the Zlex file by specifying a macro
name <VAR>M</VAR> followed by a regular expression <VAR>R</VAR>.  Any use of
<CODE>{<VAR>M</VAR>}</CODE> within a regular expression is expanded to
<CODE>(<VAR>R</VAR>)</CODE>.  Note that the definition is restricted to be a
<EM>regular expression</EM>; it cannot be a <EM>pattern</EM> containing any
context operators (see section <A HREF="zlex.html#SEC25">Patterns</A>).
<P>
A macro name can contain alphanumeric characters or <SAMP>`_'</SAMP> or <SAMP>`-'</SAMP>,
but must start with a alphabetical character or <SAMP>`_'</SAMP>.  When the macro is
defined in section 1 of the Zlex file, the name must occur at the beginning
of a line.  This must be followed by whitespace followed by the macro
definition on the same line.  The regular expression comprising the macro
definition can contain calls to other macros, including those which have not
yet been defined.  It is an error for a macro to contain a call to itself,
either directly or indirectly via calls to other macros.  A macro is not
expanded until a call to the macro is encountered in section 2 of the Zlex
file.
<P>
Whitespace is allowed within the defining regular expression
(see section <A HREF="zlex.html#SEC58">Whitespace Within Patterns</A>).  When a macro name is used within
braces, no whitespace or comments are allowed within the braces.  This makes
it easier for Zlex to disambiguate a macro use, from the start of a block of
C-code.
<P>
Macros can be used to make patterns more readable if the Zlex programmer
chooses suitable mnemonic macro names.  They do not add anything to the
expressive power of the pattern language since every use of a macro name is
fully equivalent to its defining regular expression enclosed in parentheses.
<P>
<H4>Examples</H4>
<P>
<UL>

In old <CODE>lex</CODE> and <CODE>flex</CODE> programs one often encounters macros
like the following:

<PRE>
alpha             [a-zA-Z]
</PRE>

This is not portable across all character set and is no longer necessary
since named character classes (see section <A HREF="zlex.html#SEC31">Named Character Classes</A>) can be used
instead.
</UL>
<P>
<A NAME="IDX41">.</A>
<A NAME="IDX42">.</A>
<H3><A NAME="SEC35" HREF="zlex_toc.html#SEC35">Optional Regular Expression</A></H3>
If <VAR>R</VAR> is a regular expression which matches <VAR>r'</VAR>, then
<CODE><VAR>R</VAR>?</CODE> is a regular expression which matches zero or one
occurrences of <VAR>r'</VAR>.  
<P>
<H4>Examples</H4>
<P>
<UL>

<CODE>[-+]?</CODE> denotes an optional sign.

<CODE>\.?</CODE> can be used to denote an optional decimal point.

</UL>
<P>
<A NAME="IDX43">.</A>
<A NAME="IDX44">.</A>
<A NAME="IDX45">.</A>
<A NAME="IDX46">.</A>
<H3><A NAME="SEC36" HREF="zlex_toc.html#SEC36">Zero or More Repetitions</A></H3>
If <VAR>R</VAR> is a regular expression which matches <VAR>r'</VAR>, then
<CODE><VAR>R</VAR>*</CODE> is a regular expression which matches zero or more
repetitions of <VAR>r'</VAR>.  <SAMP>`*'</SAMP> is often referred to as the
<DFN>Kleene-closure</DFN> or simply <DFN>closure</DFN> operator.
<P>
<H4>Examples</H4>
<P>
<UL>
<CODE>[[:alnum:]]*</CODE> will match a sequence of zero or more alphanumeric
characters.

<CODE>[*]*</CODE> will match a sequence of 0 or more <SAMP>`*'</SAMP>s.
</UL>
<P>
<A NAME="IDX47">.</A>
<A NAME="IDX48">.</A>
<H3><A NAME="SEC37" HREF="zlex_toc.html#SEC37">One or More Repetitions</A></H3>
If <VAR>R</VAR> is a regular expression which matches <VAR>r'</VAR>, then
<CODE><VAR>R</VAR>+</CODE> is a regular expression which matches one or more
repetitions of <VAR>r'</VAR>.  
<P>
<H4>Examples</H4>
<P>
<UL>

<CODE>[[:xdigit:]]+</CODE> will match a sequence of one or more hexadecimal
characters.

<CODE>.+</CODE> will match the rest of the current line provided it is nonempty
(recall that <SAMP>`.'</SAMP>  matches any character except a newline).

</UL>
<P>
<A NAME="IDX49">.</A>
<H3><A NAME="SEC38" HREF="zlex_toc.html#SEC38">Counted Repetition</A></H3>
If <VAR>R</VAR> is a regular expression which matches <VAR>r'</VAR>, then
<CODE><VAR>R</VAR>{<VAR>lo</VAR>,<VAR>hi</VAR>}</CODE> where <VAR>lo</VAR> and <VAR>hi</VAR> are
positive integers matches <VAR>lo</VAR> through <VAR>hi</VAR> occurrences of <VAR>r'</VAR>;
<CODE><VAR>R</VAR>{<VAR>num</VAR>}</CODE> where <VAR>num</VAR> is a positive integer
matches exactly <VAR>num</VAR> occurrences of <VAR>r'</VAR>.  
<CODE><VAR>R</VAR>{<VAR>lo</VAR>,}</CODE> matches at least <VAR>lo</VAR>
occurrences of <VAR>r'</VAR>.  
<P>
No whitespace or comments are ever allowed between the starting <SAMP>`{'</SAMP>
and the first digit of the repetition count.  This restriction makes it
easier for Zlex to disambiguate counted repetition from a C-code block.
<P>
<H4>Examples</H4>
<P>
<UL>

<CODE>[[:alpha:]]{1,6}</CODE> matches any
nonempty string of alphabetic characters upto 6 letters long.

<CODE>[[:digit:]]{3}</CODE> matches exactly three digits.

<CODE>[[:alnum:]]{5,}</CODE> matches a sequence of at least 5 alpha-numeric
characters.

</UL>
<P>
<A NAME="IDX50">.</A>
<A NAME="IDX51">.</A>
<H3><A NAME="SEC39" HREF="zlex_toc.html#SEC39">Concatenation</A></H3>
If <VAR>R</VAR> and <VAR>S</VAR> are regular expressions which match <VAR>r'</VAR> and
<VAR>s'</VAR> respectively, then their juxtaposition <CODE><VAR>R</VAR><VAR>S</VAR></CODE> is a
regular expression which matches the concatenation of <VAR>r'</VAR> and <VAR>s'</VAR>.
<P>
<H4>Examples</H4>
<P>
<UL>

The regular expression <CODE>[a-zA-Z_][-0-9a-zA-Z_]*</CODE> can be
used to denote a Zlex macro name.

The regular expression <CODE>0[0-7]*</CODE> can be used to denote a octal number
in ANSI-C.

</UL>
<P>
<A NAME="IDX52">.</A>
<A NAME="IDX53">.</A>
<A NAME="IDX54">.</A>
<H3><A NAME="SEC40" HREF="zlex_toc.html#SEC40">Union</A></H3>
If <VAR>R</VAR> and <VAR>S</VAR> are regular expressions which match <VAR>r'</VAR> and
<VAR>s'</VAR> respectively, then <CODE><VAR>R</VAR>|<VAR>S</VAR></CODE> is a regular expression
which matches either <VAR>r'</VAR> or <VAR>s'</VAR>.  
<P>
<H4>Examples</H4>
<P>
<UL>

The regular expression <CODE>[0-9]+[lL]?[uU]?|[0-9]+[uU]?[lL]?</CODE> 
denotes a ANSI-C integer which consists of a sequence of digits 
followed optionally by <SAMP>`l'</SAMP> or <SAMP>`L'</SAMP> (denoting <EM>long</EM>), 
or by <SAMP>`u'</SAMP> or <SAMP>`U'</SAMP> (denoting <EM>unsigned</EM>) in either order.  

The above can be expressed slightly more succinctly by using 
parentheses to factor out the <CODE>[0-9]+</CODE>, as 
<CODE>[0-9]+([lL]?[uU]? | [uU]?[lL]?)</CODE>.

</UL>
<P>
<A NAME="IDX55">.</A>
<H3><A NAME="SEC41" HREF="zlex_toc.html#SEC41">Operator Precedence</A></H3>
The precedence of the operators defined above is shown below.  Operators
which are grouped together have the same precedence.  The groups are in
order of decreasing precedence.
<P>
<UL>

Postfix operators: Closure operator <SAMP>`*'</SAMP>, one or more operator <SAMP>`+'</SAMP>,
optional operator
<SAMP>`?'</SAMP>, counted repetition <SAMP>`{<VAR>lo</VAR>,<VAR>hi</VAR>}'</SAMP>.

Concatenation by juxtaposition.

Union operator <SAMP>`|'</SAMP>.

</UL>
<P>
<A NAME="IDX56">.</A>
<H3><A NAME="SEC42" HREF="zlex_toc.html#SEC42">Grouping Regular Expression</A></H3>
If <VAR>R</VAR> is a regular expression, then <CODE>(<VAR>R</VAR>)</CODE> is also a regular
expression equivalent to <VAR>R</VAR>.  The parentheses are used for grouping
regular expressions to override the default precedence of the regular
expression operators.
<P>
<H4>Example</H4>
<P>
<UL>
<CODE>(a|b)c</CODE> matches either the string <SAMP>`ab'</SAMP> or <SAMP>`ac'</SAMP>.  If the
parentheses were omitted and the pattern was written as <CODE>a|bc</CODE>, then
the pattern would match the string <SAMP>`a'</SAMP> or the string <SAMP>`bc'</SAMP>.
</UL>
<P>
<H3><A NAME="SEC43" HREF="zlex_toc.html#SEC43">Operator Independence</A></H3>
<P>
Some of the operators are merely syntactic sugar and can be
expressed in terms of the other operators.  For example:
<P>
<PRE>
<VAR>R</VAR>+ => <VAR>R</VAR><VAR>R</VAR>*
<VAR>R</VAR>{2,4} => <VAR>R</VAR><VAR>R</VAR>|<VAR>R</VAR><VAR>R</VAR><VAR>R</VAR>|<VAR>R</VAR><VAR>R</VAR><VAR>R</VAR><VAR>R</VAR>
<VAR>R</VAR>{2,} => <VAR>R</VAR><VAR>R</VAR><VAR>R</VAR>*
[/*-] => "/"|"*"|"-"
</PRE>
<P>
<H3><A NAME="SEC44" HREF="zlex_toc.html#SEC44">Regular Expression Examples</A></H3>
<P>
The following examples use Zlex regular expressions to specify the syntax of
comments in various programming languages.
<P>
<A NAME="IDX57">.</A>
<H4><A NAME="SEC45" HREF="zlex_toc.html#SEC45">Ada Comments</A></H4>
<P>
An Ada comment starts with the characters <SAMP>`--'</SAMP> and continues to
end-of-line.  A suitable pattern is
<P>
<PRE>
"--".*
</PRE>
<P>
<A NAME="IDX58">.</A>
<H4><A NAME="SEC46" HREF="zlex_toc.html#SEC46">Pascal Comments</A></H4>
<P>
Pascal has two commenting conventions.  One of them is to enclose
the body of a possibly multi-line comment within braces <SAMP>`{'</SAMP> and
<SAMP>`}'</SAMP>.  The body of the comment should not contain any <SAMP>`}'</SAMP>
characters.  An incorrect attempt to write a regular expression for such a
comment is:
<P>
<PRE>
"{"(.|\n)*"}"         /* Wrong. */
</PRE>
<P>
The problem is that the regular expression does not enforce the restriction
that the body of the comment should not contain any <SAMP>`}'</SAMP> characters.
In fact, with Zlex's rule for preferring the longest match, the above
regular expression will interpret all the text between the first <SAMP>`{'</SAMP>
and the last <SAMP>`}'</SAMP> in a Pascal file as a comment!
<P>
A correct regular expression is:
<P>
<PRE>
"{"[^}]*"}"
</PRE>
<P>
Though this is correct, it has the disadvantage that it forces Zlex to save
the text of a long comment.  For more efficient ways of processing long
comments, see section <A HREF="zlex.html#SEC72">Start States Example: C comments</A>.
<P>
<A NAME="IDX59">.</A>
<H4><A NAME="SEC47" HREF="zlex_toc.html#SEC47">C Comments</A></H4>
A comment in C consists of any character sequence not containing the
subsequence <SAMP>`*/'</SAMP> surrounded by <SAMP>`/*'</SAMP> and <SAMP>`*/'</SAMP>.  The following
is an incorrect attempt (which was published in a book) at writing a regular
expression for a C comment (the spaces in the regular expression have been
added for readability and can be ignored by Zlex):
<P>
<PRE>
("/*" "/"* ([^*/] | [^*]"/" | "*"[^/])* "*"* "*/") /* Wrong. */
</PRE>
<P>
Analyzing the above expression we realize that the expression within the
inner parentheses corresponds to the body of the comment except for a
possibly empty prefix containing only <SAMP>`/'</SAMP>s and a possibly empty suffix
containing only <SAMP>`*'</SAMP>s.  Analyzing the inner expression further, it
specifies 0 or more repetitions of
<P>
<UL>
<LI>
Any character except a <SAMP>`/'</SAMP> or <SAMP>`*'</SAMP>.

<LI>
Any character except a <SAMP>`*'</SAMP> followed by a <SAMP>`/'</SAMP>.

<LI>
A <SAMP>`*'</SAMP> followed by any character except a <SAMP>`/'</SAMP>.
</UL>
<P>
Though the above seems correct, it is not.  A counterexample is the valid
comment <SAMP>`/**1/*/'</SAMP> which does not match the above regular expression.
The problem is caused by ignoring the possible overlap between the
subpatterns <SAMP>`[^*]"/"'</SAMP> and <SAMP>`"*"[^/]'</SAMP> where the negated character
classes in both patterns may need to match the same character (<SAMP>`1'</SAMP> in
the counterexample).
<P>
A solution which is claimed to be correct is the following:
<P>
<PRE>
("/*" [^*]* "*"+ ([^/*][^*]*"*"+)* "/")
</PRE>
<P>
The <CODE>[^*]*</CODE> deals with that prefix of the comment body which does not
contain any <SAMP>`*'</SAMP>s.  When a <SAMP>`*'</SAMP> occurs, we need to have a sequence
of one or more of them (<CODE>"*"+</CODE>).  The inner closure
<CODE>([^/*][^*]*"*"+)*</CODE> specifies that the sequence of <SAMP>`*'</SAMP>s be
followed by 0 or more repetitions of text not starting with <SAMP>`/'</SAMP> or
<SAMP>`*'</SAMP> and terminating in a sequence of <SAMP>`*'</SAMP>s.  So irrespective of the
number of iterations of the inner closure, the input character at the end of
the closure must be a <SAMP>`*'</SAMP>. Hence a further <SAMP>`/'</SAMP> in the input
terminates the comment.
<P>
Once again, this is not the recommended way to specify C comments in Zlex
because of the possibly excessive growth of the text saved by Zlex.  For the
recommended method, see section <A HREF="zlex.html#SEC72">Start States Example: C comments</A>.  As the preceeding
remark makes clear, these complicated regular expressions are mainly useful
as exercises with which to plague students.  What is more interesting is the
non-eureka process by which these expressions may be constructed, but that
is beyond the scope of this manual.
<P>
<A NAME="IDX60">.</A>
<H2><A NAME="SEC48" HREF="zlex_toc.html#SEC48">Context Operators</A></H2>
Sometimes it is necessary to match regular expressions only in certain
contexts.  This can be achieved by patterns which use additional syntax to
specify the context in which a regular expression should be matched.
<P>
<A NAME="IDX61">.</A>
<H3><A NAME="SEC49" HREF="zlex_toc.html#SEC49">Right Context</A></H3>
Right context allows an input sequence to match a regular expression only if
the input which immediately follows the matching sequence satisfies certain
restrictions.  Generalized right context allows the restrictions to be
expressed via an arbitrary regular expression.  End-of-line right context is
a special case of generalized right context.
<P>
<H4><A NAME="SEC50" HREF="zlex_toc.html#SEC50">Generalized Right Context</A></H4>
One can define a real number in Modula-2 by means of the following macro
definitions: 
<P>
<PRE>
digit           [0-9]
sign            [-+]
exp             E{sign}?{digit}+
real            {digit}+\.{digit}*{exp}?
</PRE>
<P>
The above definition allows numbers like <SAMP>`22.'</SAMP> with an empty fraction
and exponent.  Unfortunately, constructs like <SAMP>`1..10'</SAMP> are commonly used
in Modula-2 to indicate subranges, and should be scanned as three tokens
<SAMP>`1'</SAMP>, <SAMP>`..'</SAMP> and <SAMP>`10'</SAMP>.  However since Zlex always prefers the
longest match, the effect of the pattern <CODE>{real}</CODE> on the input
<SAMP>`1..10'</SAMP> will be to scan the first token as <CODE>1.</CODE>, which is wrong
for Modula-2.  One solution is to scan a number as a real only if it is not
followed by a <SAMP>`.'</SAMP>  character.  This can be achieved by suffixing the
above pattern with a special right-context construct which imposes this
restriction:
<P>
<PRE>
<CODE>{real}/[^.]</CODE>
</PRE>
<P>
<SAMP>`/'</SAMP> is the right-context operator.  If <VAR>R</VAR> and <VAR>C</VAR> are
arbitrary regular expressions, then <CODE><VAR>R</VAR>/<VAR>C</VAR></CODE> is a pattern
which matches input <VAR>R'</VAR> iff <VAR>R</VAR> matches <VAR>R'</VAR> and the input
after <VAR>R'</VAR> matches <VAR>C</VAR>.  Note that the input which matched <VAR>C</VAR>
is available to be rescanned.
<P>
Returning to the Modula-2 example, <CODE>{real}/[^.]</CODE> will not match the
input <CODE>1..10</CODE>.  Instead the <CODE>1</CODE> can be matched by a pattern for an
integer, the <CODE>..</CODE> can be matched by an appropriate pattern, and the
<CODE>10</CODE> can be matched by the pattern for an integer.  On the other hand
if the input is <CODE>1.+2</CODE>, then <CODE>{real}/[^.]</CODE> will match the
<SAMP>`1.'</SAMP>, since <SAMP>`+'</SAMP> matches <CODE>[^.]</CODE>.  The <SAMP>`+'</SAMP> will then be
rescanned and can be matched by a suitable pattern.
<P>
There are no restrictions on the regular expressions on either side of the
<SAMP>`/'</SAMP>.  Unfortunately, this freedom allows ambiguous patterns like
<CODE>[a-zA-Z0-9]+/[0-9]+"#"</CODE>, for which there are multiple ways to match an
input like <SAMP>`aA12b123#'</SAMP>.  Specifically, the prefixes <SAMP>`aA12b'</SAMP>,
<SAMP>`aA12b1'</SAMP> and <SAMP>`aA12b12'</SAMP> all match the specified pattern.  It is
necessary for Zlex to use a disambiguating rule to resolve the ambiguity: it
always matches the longest prefix.  For the above example, Zlex would match
<SAMP>`aA12b12'</SAMP>.  Note that other scanner generators may get confused by
similar patterns.
<P>
<A NAME="IDX62">.</A>
<A NAME="IDX63">.</A>
<H4><A NAME="SEC51" HREF="zlex_toc.html#SEC51">End of Line Right Context</A></H4>
<P>
It is sometimes necessary to match a regular expression <VAR>R</VAR> only at the
end of a line.  This can be achieved by using the pattern <CODE><VAR>R</VAR>/\n</CODE>.
The <CODE>$</CODE> end-of-line anchor is available to abbreviate this pattern to
<CODE><VAR>R</VAR>$</CODE>.  The <SAMP>`$'</SAMP> character is special only at the end of a
pattern.
<P>
<H4><A NAME="SEC52" HREF="zlex_toc.html#SEC52">Right Context Restrictions</A></H4>
A single pattern can contain only a single instance of a right-context
operator.  Hence a pattern like <CODE>[A-Za-z0-9]+/[\t ]+$</CODE> which
attempts to recognize an alphanumeric word only when it occurs at the end of
a line is illegal, since <SAMP>`$'</SAMP> provides an additional right-context
operator. Instead, the pattern can be written as <CODE>[A-Za-z0-9]+/[\t
]+\n</CODE> which is legal.
<P>
<A NAME="IDX64">.</A>
<H3><A NAME="SEC53" HREF="zlex_toc.html#SEC53">Left Context</A></H3>
<P>
In a Zlex scanner, it is possible to use two methods for allowing
left-context to influence a match.  The first is useful when the
interpretation of a token is affected by whether or not it is at the start
of a line.  The second is more general, and allows encapsulating the
left-context into a state which selects a subset of the patterns which are
allowed to match.
<P>
<A NAME="IDX65">.</A>
<A NAME="IDX66">.</A>
<H4><A NAME="SEC54" HREF="zlex_toc.html#SEC54">Start of Line Pattern</A></H4>
<P>
In a C preprocessor, <SAMP>`#'</SAMP> signals a preprocessor directive only
if it occurs at the beginning of a line (preceeded optionally by
whitespace).  A pattern which recognizes a <SAMP>`#'</SAMP> only when it signals a
preprocessor directive is the following:
<P>
<PRE>
^[\t \v\f]*\#
</PRE>
<P>
The <SAMP>`^'</SAMP> is the <DFN>start-of-line</DFN> anchor: the following pattern is
matched only if the previous character was a newline character.
<P>
When a scanner uses one or more patterns containing the start-of-line anchor
<SAMP>`^'</SAMP>, it is possible to query and set the current start-of-line
condition during scanning.  See See section <A HREF="zlex.html#SEC86">Querying Beginning of Line: <CODE>YY_AT_BOL</CODE></A> and
See section <A HREF="zlex.html#SEC87">Setting Beginning of Line: <CODE>yy_set_bol</CODE></A>.
<P>
<A NAME="IDX67">.</A>
<H4><A NAME="SEC55" HREF="zlex_toc.html#SEC55">Start State Patterns</A></H4>
The generated scanner can be in one of several different states before it
starts scanning the input for the next token: these states are known as
<DFN>start states</DFN>.  The Zlex programmer is required to name and declare all
start states and can control the transitions between start states by using
special actions. In a particular start state, only a subset of the patterns
is used to recognize tokens; exactly which subset is to be selected is
indicated by qualifying each pattern with the set of start states in which
that pattern should be active.  More information on start states can be
found in section <A HREF="zlex.html#SEC63">Start States</A>.
<P>
<A NAME="IDX68">.</A>
<H2><A NAME="SEC56" HREF="zlex_toc.html#SEC56">End of File Patterns</A></H2>
The special pattern <CODE>&#60;&#60;EOF&#62;&#62;</CODE> (which cannot contain any internal
whitespace or comments) is used to match the end of the input file.  It may
be qualified with a set of start conditions using a syntax identical to that
used for qualifying regular expressions.  The end-of-file pattern is useful
for doing special processing at end-of-file.  The following example shows
how it can be used to signal that a construct like a comment was not
terminated before end-of-file was encountered:
<P>
<PRE>
&#60;COMMENT&#62;&#60;&#60;EOF&#62;&#62;   fprintf(stderr, "EOF detected within comment.");
</PRE>
<P>
It is assumed that the scanner entered a <CODE>COMMENT</CODE> start state when a
comment was encountered.
<P>
For special Zlex actions which can be used in <CODE>&#60;&#60;EOF&#62;&#62;</CODE> patterns,
see section <A HREF="zlex.html#SEC106">End-of-File and Termination</A>.
<P>
<A NAME="IDX69">.</A>
<H2><A NAME="SEC57" HREF="zlex_toc.html#SEC57">Intra-Token Patterns</A></H2>
Intra-token patterns are useful to do pre-lexical processing during the
scanning process.  More information on intra-token patterns can be found in
section <A HREF="zlex.html#SEC102">Using Intra-Token Patterns</A>.
<A NAME="IDX70">.</A>
<H2><A NAME="SEC58" HREF="zlex_toc.html#SEC58">Whitespace Within Patterns</A></H2>
Whitespace is allowed in Zlex patterns when the option
<SAMP>`--whitespace'</SAMP> is specified (see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>).  Unfortunately, it
is not possible to allow totally free-format input in order to retain as
much backward-compatibility as possible with <CODE>flex</CODE> and <CODE>lex</CODE>.
The rules for how whitespace within different constructs are as follows:
<P>
<DL COMPACT>
<DT>What is whitespace?
<DD>Blanks, tabs and comments are regarded as equivalent whitespace.
Newlines are treated somewhat differently.

<DT>Character classes and strings
<DD>Whitespace (except newlines) is always significant and is included in the
pattern.  Newlines are not allowed directly in strings or character classes,
but must be escaped.  The effect of whitespace within these constructs is
independent of the <SAMP>`--whitespace'</SAMP> option.  This behavior is identical
to the behavior of other common text processing utilities.

<DT>End-of-file Pattern
<DD>Whitespace is never allowed in the end-of-file token <CODE>&#60;&#60;EOF&#62;&#62;</CODE> which is
regarded as an indivisible token.  This behavior is independent of the
<SAMP>`--whitespace'</SAMP> option.

<DT>Macro Calls
<DD>Whitespace is never allowed in macro calls of the form
<CODE>{<VAR>macro</VAR>}</CODE> which are regarded as indivisible tokens.  This
behavior is independent of the <SAMP>`--whitespace'</SAMP> option.

<DT>Regular Expressions in Macro Definitions
<DD>Spaces and tabs are always allowed and ignored within the regular
expressions used for macro definitions in section 1 of the Zlex file.  When
the option <SAMP>`--whitespace'</SAMP> is not specified, the pattern is terminated
by the first newline; when the option <SAMP>`--whitespace'</SAMP> is specified,
newlines are allowed and ignored <EM>provided they occur within
parentheses</EM>.

<DT>Patterns in Section 2
<DD>When the <SAMP>`--whitespace'</SAMP> option is not specified, a pattern in section 2
is terminated by the first non-quoted whitespace which is not within a
string or character class. When the <SAMP>`--whitespace'</SAMP> option is specified,
whitespace which is not within a character class or string in a section 2
pattern is allowed and ignored; the pattern is terminated by the start of a
brace-enclosed action or by the first newline which is not within parentheses.
</DL>
<P>
One consequence of these rules is that when the <SAMP>`--whitespace'</SAMP> option
is used, it is not possible to include a action for a pattern in section 2
of the Zlex file without enclosing the action within braces.
<P>
<H1><A NAME="SEC59" HREF="zlex_toc.html#SEC59">Accessing the Current Lexeme</A></H1>
<P>
Two variables with external linkage allow accessing the characters
constituting the last matched token, as well as its length.
<P>
<A NAME="IDX71">.</A>
<A NAME="IDX72">.</A>
<A NAME="IDX73">.</A>
<A NAME="IDX74">.</A>
<H2><A NAME="SEC60" HREF="zlex_toc.html#SEC60">Current Lexeme Text: <CODE>yytext</CODE></A></H2>
This is a variable which enables access to the sequence of characters
which constitute the lexeme of the current token.  This sequence of
characters is always terminated by a <KBD>NUL</KBD> <SAMP>`\0'</SAMP> character.
Like all other variable names, the name of this variable can be changed
to an arbitrary name by defining the macro <CODE>YY_TEXT</CODE> to the new
name.  Alternatively, the prefix used for the name can be changed by
using the <SAMP>`--prefix'</SAMP> option (see section <A HREF="zlex.html#SEC20">Variable Names</A>).  Its default
declaration depends on whether the option <SAMP>`--pointer'</SAMP> or
<SAMP>`--array'</SAMP> is used (see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>).  When <SAMP>`--pointer'</SAMP> is
used, its default declaration is <CODE>char *yytext</CODE>; when
<SAMP>`--array'</SAMP> is used, its default definition is equivalent to
<A NAME="IDX75">.</A>
<P>
<PRE>
char *yytext[YYLMAX];
</PRE>
<P>
where <CODE>YYLMAX</CODE> is a macro which gives the size of the array.
<CODE>YYLMAX</CODE> can be defined by the user in section 1 of the Zlex file if a
value different from the default value (<CODE>8192</CODE>) is desired.  
<P>
When <CODE>yytext</CODE> is declared to be an array and the length of a matched
lexeme is greater than the value of <CODE>YYLMAX</CODE>, then the <CODE>yytext</CODE>
array will silently overflow with unpredictable results.  When <CODE>yytext</CODE>
is declared to be a pointer, there is no possibility of overflow as the
lexeme text is maintained within the scanner's buffer (which is grown
dynamically as needed).
<P>
A scanner in which <CODE>yytext</CODE> is declared to be a pointer is usually
faster than one in which it is declared to be an array.  This fact, coupled
with the overflow problem mentioned previously, make a <CODE>%array</CODE>
declaration fairly useless except for backward compatibility with
lex.
<P>
The Zlex programmer should always treat <CODE>yytext</CODE> as a read-only
variable.
<P>
The following program fragment shows a pattern-action pair which matches the
occurrence of an identifier at the beginning of a line and saves it in
dynamic memory pointed to by the variable <CODE>text</CODE>.
<P>
<PRE>
%%

[[:alpha:]_][[:alnum:]_]*       
  {  text= malloc(yyleng + 1); /* <CODE>+1</CODE> for terminating <CODE>NUL</CODE>. */
     if (!text) { <I>`Call an error routine.'</I> }
     strcpy(text, yytext);
  }
</PRE>
<P>
<A NAME="IDX76">.</A>
<A NAME="IDX77">.</A>
<A NAME="IDX78">.</A>
<A NAME="IDX79">.</A>
<H2><A NAME="SEC61" HREF="zlex_toc.html#SEC61">Current Lexeme Length: <CODE>yyleng</CODE></A></H2>
This variable with declaration <CODE>int yyleng</CODE> holds the length of the
current token.  The <DFN>length of a token</DFN> is the number of characters
in the lexeme of the token (not counting any terminating <CODE>'\0'</CODE>).
Like all other variable names, the name of this variable can be changed
to an arbitrary name by defining the macro <CODE>YY_LENG</CODE> to the new
name.  Alternatively, the prefix used for the name can be changed by
using the <SAMP>`--prefix'</SAMP> option (see section <A HREF="zlex.html#SEC20">Variable Names</A>).
<P>
The Zlex programmer should always treat <CODE>yyleng</CODE> as a read-only
variable.
<P>
The following program produces a histogram of word-lengths, where a word
is defined to be a maximal sequence of characters not containing a
space, tab or newline.
<P>
<PRE>
%{
enum { MAX_WORD_LEN= 10 };
static unsigned freq[MAX_WORD_LEN];
%}
%%
[^\t \n]+       { if (yyleng &#62; MAX_WORD_LEN) {
                     <I>`Signal error;'</I>
                  } 
                  else {
                    freq[yyleng]++; 
                  }
                }
[\t \n]+        /* No action. */
&#60;&#60;EOF&#62;&#62;         { unsigned i;
                  for (i= 0; i &#60; MAX_WORD_LEN; i++) {
                    printf("%d: %d\n", i, freq[i]);
                  }
                }
</PRE>
<P>
<H2><A NAME="SEC62" HREF="zlex_toc.html#SEC62">Concatenating Tokens: <CODE>yymore</CODE></A></H2>
<P>
If an action contains a call to the <CODE>yymore()</CODE> macro, then the lexeme
for that token is prefixed to the lexeme of the next token recognized.
Effectively, this allows the programmer to recognize subtokens within a
larger token.  The canonical form <CODE>YY_MORE()</CODE> can also be used instead.
The library function <CODE>yyMore(YYDataHandle)</CODE> can also be used from files
other than the generated scanner file.
<P>
For example, let us suppose that an application requires printing out the
input lines in reverse order, and printing the total number of words in the
input.  Whenever a token within a line is recognized the scanner executes
a <CODE>yymore</CODE> action: hence when the <SAMP>`\n'</SAMP> terminating a line is
finally matched, <CODE>yytext</CODE> contains the text for the entire line.  This
is saved in a stack of lines using a function <CODE>pushLine()</CODE> shown below.
Finally at <CODE>&#60;&#60;EOF&#62;&#62;</CODE> this stack is traversed with the lines being
printed in reverse order.
<P>
<PRE>
%{
#include &#60;stdio.h&#62;
#include &#60;stddef.h&#62;

typedef struct LineStruct {
  struct LineStruct *last;
  char *text;
} LineStruct;

static LineStruct *pushLine(LineStruct *lines, 
                            const char *text, int textLen);

%}
%%
  /* Declare local variables. */
  int wc= 0;
  LineStruct *lines= NULL;
[\t ]+          yymore();
[^\t \n]+       wc++; yymore();
\n              lines= pushLine(lines, yytext, yyleng);
&#60;&#60;EOF&#62;&#62;         { LineStruct *p;
                  for (p= lines; p; p= p-&#62;last) fputs(p-&#62;text, stdout);
                  printf("# of words= %d\n", wc);
                }
%%
static LineStruct *
pushLine(LineStruct *lines, const char *text, int textLen)
{
  char *const savedText= malloc(textLen + 1);
  LineStruct *const lineP= malloc(sizeof(LineStruct));
  if (!savedText || !lineP) {
    fprintf(stderr, "Out of memory.\n"); exit(1);
  }
  strcpy(savedText, text);
  lineP-&#62;text= savedText; lineP-&#62;last= lines;
  return lineP;
}
</PRE>
<P>
A log of running the scanner generated from the above follows:
<P>
<PRE>
"Beware the Jabberwock, my son!
  The jaws that bite, the claws that catch!
 Beware the Jubjub bird, and shun
    The frumious Bandersnatch!"
^D
=>
    The frumious Bandersnatch!"
 Beware the Jubjub bird, and shun
  The jaws that bite, the claws that catch!
"Beware the Jabberwock, my son!
# of words= 22
</PRE>
<P>
<A NAME="IDX80">.</A>
<H1><A NAME="SEC63" HREF="zlex_toc.html#SEC63">Start States</A></H1>
<P>
Start states allow the behavior of the scanner to depend on the left context
within the input.  Several actions allow the scanner to control or access
its current start state.
<P>
<H2><A NAME="SEC64" HREF="zlex_toc.html#SEC64">Start State Types</A></H2>
Start states are of two types: <EM>exclusive</EM> and <EM>inclusive</EM>. When a
<A NAME="IDX81">.</A>
<DFN>exclusive start state</DFN> is active, only those patterns whose qualifying
start states include the name of that start state are selected.  See
section <A HREF="zlex.html#SEC72">Start States Example: C comments</A> for an example where start states are used to
process C-style comments.  When a
<A NAME="IDX82">.</A>
<DFN>inclusive start state</DFN> is active, patterns which do not have any
qualifying start states at all are also selected in addition to the patterns
whose qualifying start states include the name of the active start state.
This implies that a pattern with no qualifying start states is equivalent to
the same pattern qualified by <STRONG>all</STRONG> the <EM>inclusive</EM> start
states.  Inclusive start states are useful to factor out the commonality
within different start states (see section <A HREF="zlex.html#SEC73">Using Inclusive Start States</A>).
<P>
Start state qualified patterns can occur only in section 2 of the Zlex
file.  The syntax for qualifying patterns is to prefix the pattern with the
names of the start states separated by commas <SAMP>`,'</SAMP>, and enclosed within
angle brackets <SAMP>`&#60;'</SAMP> and <SAMP>`&#62;'</SAMP>.  The following patterns are 
examples of start state qualified patterns:
<P>
<PRE>
&#60;INITIAL&#62;"/*"
&#60;COMMENT&#62;"*/"
&#60;INITIAL,COMMENT&#62;\n
</PRE>
<P>
where it is assumed that <CODE>INITIAL</CODE> and <CODE>COMMENT</CODE> are suitably
declared start states.
<P>
        
<H2><A NAME="SEC65" HREF="zlex_toc.html#SEC65">Start State Declarations</A></H2>
<P>
Before a start state name can be used in section 2 of the Zlex file, it must
be declared in section 1 of the Zlex file.  An exclusive (inclusive) start
state is declared in section 1 by a line starting with <CODE>%x</CODE> (<CODE>%s</CODE>)
or <CODE>%X</CODE> (<CODE>%S</CODE>) followed by whitespace followed by the name of the
start state on the same line.  Multiple start states of the same type can be
declared by including multiple names on the same line separated by space.
The characters allowed within a start state name are identical to those
allowed in a macro name: a sequence of alphanumeric or <SAMP>`_'</SAMP> or <SAMP>`-'</SAMP>
characters starting with an alphabetic or <SAMP>`_'</SAMP> character.  
<P>
The following are examples of start state declarations:
<P>
<PRE>
%x      COMMENT C_CODE          /* Exclusive start states. */
%s      RANGE SS_USE            /* Inclusive start states. */
</PRE>
<P>
In the generated scanner, the programmer declared start state names are
<CODE>#define</CODE>d to be small integers.  Hence the programmer should not use
these names in any other context.  
<A NAME="IDX84">.</A>
<A NAME="IDX85">.</A>
<A NAME="IDX83">.</A>
All Zlex generated scanners predefine an
inclusive start state called <CODE>INITIAL</CODE> which is the initial start
state for the scanner when it is first called.
<CODE>INITIAL</CODE> is <CODE>#define</CODE>d to be
<CODE>0</CODE>; The
user should not make any assumptions about the assignment of integers to
other start states, and should always refer to them using their symbolic
names.
<P>
<A NAME="IDX86">.</A>
<A NAME="IDX87">.</A>
<A NAME="IDX88">.</A>
<H2><A NAME="SEC66" HREF="zlex_toc.html#SEC66">Entering a Start State: <CODE>BEGIN</CODE></A></H2>
The macro <CODE>BEGIN</CODE> is used to set the current start state.  To set the
current start state to one with name <VAR>ss</VAR>, <CODE>BEGIN(<VAR>ss</VAR>)</CODE> can be
used.  For backwards compatibility reasons, <CODE>BEGIN <VAR>ss</VAR></CODE> without
the parentheses can also be used.
<P>
The canonical name <CODE>YY_BEGIN</CODE> can be used instead; unlike <CODE>BEGIN</CODE>,
the parentheses are always required.  To begin start-state <VAR>ss</VAR> the form
<CODE>YY_BEGIN(<VAR>ss</VAR>)</CODE> is used.  
<P>
Since the <CODE>INITIAL</CODE> start state (see section <A HREF="zlex.html#SEC65">Start State Declarations</A>) is
<CODE>#define</CODE>d to be <CODE>0</CODE>, <CODE>BEGIN 0</CODE> is synonymous with
<CODE>BEGIN INITIAL</CODE>.
<P>
The following example shows how inclusive start states can be used to
recognize numbers in different bases depending on a specific directive.  The
base is set by a <SAMP>`%bin'</SAMP>, <SAMP>`%oct'</SAMP> or <SAMP>`%hex'</SAMP> directive which
must occur at the start of a line.
<P>
<PRE>
%s BIN OCT HEX
%%
^"%bin"                 BEGIN BIN;
^"%oct"                 BEGIN OCT;
^"%hex"                 BEGIN HEX;
&#60;BIN&#62;[01]+              <I>`Action for a binary number.'</I>
&#60;OCT&#62;[0-7]+             <I>`Action for a octal number.'</I>
&#60;HEX&#62;[a-fA-F0-9]+       <I>`Action for a hexadecimal number.'</I>
<I>`Other non-qualified patterns.'</I>
</PRE>
<P>
<A NAME="IDX89">.</A>
<A NAME="IDX90">.</A>
<A NAME="IDX91">.</A>
<A NAME="IDX92">.</A>
<H2><A NAME="SEC67" HREF="zlex_toc.html#SEC67">Accessing the Current Start State: <CODE>YY_START</CODE></A></H2>
<P>
The macro <CODE>YY_START</CODE> returns the current start state (an unsigned
integer).  <CODE>YYSTATE</CODE> is synonymous with <CODE>YY_START</CODE>.
<P>
Accessing the current start state using <CODE>YY_START</CODE> allows the Zlex
programmer to use start-state subroutines.  For example, in the scanner for
Zlex, C-style comments are allowed within several constructs.  These
comments are processed using an exclusive start state <CODE>COMMENT</CODE>
(see section <A HREF="zlex.html#SEC72">Start States Example: C comments</A>).  When we are in a construct and see the
start of a comment, we do a <CODE>BEGIN COMMENT</CODE> <EM>after</EM> saving the
current start state in a global variable, say <CODE>commentRet</CODE>.  Then when
in the <CODE>COMMENT</CODE> state we see the end of the comment we do a
<CODE>BEGIN commentRet</CODE>, which puts us back in the start state in which we
originally saw the comment.
<P>
In the above situation, we could predict exactly how many start states
we need to save at any time (exactly one).  That may not be possible in
general.  Start state stacks may be used in such situations
(see section <A HREF="zlex.html#SEC68">Start State Stacks</A>).
<P>
<H2><A NAME="SEC68" HREF="zlex_toc.html#SEC68">Start State Stacks</A></H2>
<P>
In a Zlex scanner, start state stacks can be created and manipulated using
three routines.
<P>
<A NAME="IDX93">.</A>
<A NAME="IDX94">.</A>
<A NAME="IDX95">.</A>
<A NAME="IDX96">.</A>
<H3><A NAME="SEC69" HREF="zlex_toc.html#SEC69">Pushing a Start State: <CODE>yy_push_state</CODE></A></H3>
<P>
The macro <CODE>yy_push_state(<VAR>ss</VAR>)</CODE> pushes the current start-state on
top of the start state stack and does a <CODE>BEGIN <VAR>ss</VAR></CODE> action.  The
canonical name <CODE>YY_PUSH_STATE</CODE> may be used synonymously.  From files
other than the generated scanner, the programmer can call the Zlex library
function <CODE>yyPushState</CODE> with prototype:
<P>
<PRE>
void 
yyPushState(YYDataHandle d, YYState ss);
</PRE>
<P>
to push the current start state on the start state stack of the scanner
specified by <CODE>d</CODE> and enter start state <CODE>ss</CODE>.
<P>
<A NAME="IDX97">.</A>
<A NAME="IDX98">.</A>
<A NAME="IDX99">.</A>
<A NAME="IDX100">.</A>
<H3><A NAME="SEC70" HREF="zlex_toc.html#SEC70">Popping the Start State Stack: <CODE>yy_pop_state</CODE></A></H3>
<P>
The macro <CODE>yy_pop_state()</CODE> sets the current start state to the state on
top of the start state stack and pops the start state stack.  The canonical
name <CODE>YY_POP_STATE</CODE> may be used synonymously.  From files other than
the generated scanner, the programmer can call the Zlex library function
<CODE>yyPopState</CODE> with prototype:
<P>
<PRE>
void 
yyPopState(YYDataHandle d);
</PRE>
<P>
to set the current start state to the state on top of the start state stack
of the scanner specified by <CODE>d</CODE> and pop its start state stack.
<P>
<A NAME="IDX101">.</A>
<A NAME="IDX102">.</A>
<A NAME="IDX103">.</A>
<A NAME="IDX104">.</A>
<H3><A NAME="SEC71" HREF="zlex_toc.html#SEC71">The Top of the Start State Stack: <CODE>yy_top_state</CODE></A></H3>
<P>
The macro <CODE>yy_top_state()</CODE> return the start state on top of the start
state stack.  The start state stack is not changed.  The canonical name
<CODE>YY_TOP_STATE</CODE> may be used synonymously.  From files other than the
generated scanner, the programmer can call the Zlex library function
<CODE>yyTopState</CODE> with prototype:
<P>
<PRE>
YYState 
yyTopState(YYDataHandle d);
</PRE>
<P>
to return the start state on top of the start state stack of the scanner
specified by <CODE>d</CODE>.
<P>
<A NAME="IDX105">.</A>
<H2><A NAME="SEC72" HREF="zlex_toc.html#SEC72">Start States Example: C comments</A></H2>
<P>
The following example is the recommended way to process C-style comments
using Zlex.  It illustrates the use of exclusive start states to allow the
scanner to process the comments in reasonable line-sized chunks.
<P>
When the generated scanner sees a <SAMP>`/*'</SAMP> it enters a exclusive start
state named <CODE>COMMENT</CODE> where it is looking for the terminating
<SAMP>`*/'</SAMP>.  Because <CODE>COMMENT</CODE> is an exclusive start state, Zlex will
ignore all patterns not qualified by <CODE>COMMENT</CODE> when in the
<CODE>COMMENT</CODE> state.
<P>
<PRE>
001     %x                      COMMENT         /* Declare start-state. */
002     %%
003     "/*"                    BEGIN COMMENT;
004     &#60;COMMENT&#62;"*/"           BEGIN INITIAL;
005     &#60;COMMENT&#62;[^*\n]+
006     &#60;COMMENT&#62;\n
007     &#60;COMMENT&#62;"*"+/[^/]              
</PRE>
<P>
Line 1 declares the identifier <CODE>COMMENT</CODE> to be an exclusive
start-state.  Line 3 has a pattern for recognizing the <SAMP>`/*'</SAMP> which
begins a comment.  Since the pattern is not qualified by any start states,
it will be active in all inclusive start states: namely <CODE>INITIAL</CODE>.  Its
action uses the special Zlex macro <CODE>BEGIN</CODE> (see section <A HREF="zlex.html#SEC66">Entering a Start State: <CODE>BEGIN</CODE></A>) to enter the special <CODE>COMMENT</CODE> state.
<P>
Line 4 recognizes the terminating <SAMP>`*/'</SAMP> only when the scanner is in the
<CODE>COMMENT</CODE> state.  Its action is to change the scanner state back to
<CODE>INITIAL</CODE>.  Once the scanner is back in the <CODE>INITIAL</CODE> state, the
patterns prefixed by <CODE>COMMENT</CODE> are ignored, and other patterns (not
shown) become active.
<P>
Line 5 recognizes any prefix of a comment line which does not contain
<SAMP>`*'</SAMP>.  Note the use of <CODE>\n</CODE> in the negated character class; if we
had simply used the regular expression <CODE>[^*]+</CODE>, then it could
conceivably match several lines of text -- something which is undesirable
as the <CODE>yytext</CODE> saved by the scanner may become excessively large.
<P>
Lines 6 and 7 recognize those portions of a comment not recognized by line
5.  Line 6 recognizes a newline occurring within a comment.  The
given code does not have any action but if the scanner is keeping track of
line numbers, an appropriate action would be to increment a line number
counter.  Line 7 recognizes <SAMP>`*'</SAMP>s occurring within a comment which are
not followed by a <SAMP>`/'</SAMP>.  We use <CODE>"*"+/[^/]</CODE> rather than simply
<CODE>"*"/[^/]</CODE>, as it is always desirable to scan as large a token as
possible to reduce scanner overhead.
<P>
<A NAME="IDX106">.</A>
<H2><A NAME="SEC73" HREF="zlex_toc.html#SEC73">Using Inclusive Start States</A></H2>
Inclusive start states are not strictly necessary, but are useful to capture
the semantics of a state which is very similar to other inclusive states, in
that all except a few tokens are processed identically.  The implementation
of Zlex itself provides a practical example of such uses of inclusive start
states.  In Zlex, the <SAMP>`,'</SAMP> character is usually an ordinary character:
within a pattern it usually stands for itself specifying that a comma should
be matched.  The exceptions to this rule are:
<P>
<UL>
<LI>
A comma is used to separate start state names within the qualifying start
state list for a pattern,

<LI>
A comma is used within the counted repetition operator 
<CODE>{<VAR>lo</VAR>,<VAR>hi</VAR>}</CODE> to separate <VAR>lo</VAR> from <VAR>hi</VAR>.
</UL>
<P>
The Zlex scanner defines two inclusive start states <CODE>RANGE</CODE> and
<CODE>SS_USE</CODE> which return a comma as a special token.  A highly simplified
version of the code is shown below.
<P>
<PRE>
%s      RANGE           /* Start state for counted repetition. */
%s      SS_USE          /* Start state for start state list. */

%%

"{"                     BEGIN RANGE; 

"&#60;"                     BEGIN SS_USE;

&#60;RANGE,SS_USE&#62;","       return ',';

.                       return CHAR_TOK;
</PRE>
<P>
If a comma is encountered when the scanner is in either one of the states
<CODE>RANGE</CODE> or <CODE>SS_USE</CODE> it is returned as the special token <CODE>','</CODE>.
Otherwise it is simply returned as a <SAMP>`CHAR_TOK'</SAMP>.  Note that any other
characters will be matched using the patterns without any start-state
qualifications: in the currently popular object-oriented parlance,
<CODE>RANGE</CODE> and <CODE>SS_USE</CODE> <EM>inherit</EM> behavior from the patterns
without start-state qualifications.
<P>
<H1><A NAME="SEC74" HREF="zlex_toc.html#SEC74">Input in a Zlex Scanner</A></H1>
<P>
A Zlex scanner reads its input from a <CODE>stdio</CODE> <CODE>FILE</CODE> pointer
with default name <CODE>yyin</CODE>.  For performance reasons, it buffers its
input.  Normally, it is the main scanner function which reads its input
directly from the buffer, but it is also possible for the Zlex
programmer to read directly from the buffer using the <CODE>input</CODE>
macro.  It is possible for the programmer to specify the method by which
the scanner fills its buffer by defining the <CODE>YY_INPUT()</CODE> macro.
The programmer is allowed to modify the characters in the scanner buffer
and backtrack to alternate matches with the prefix of the input.  It is
also possible for the Zlex programmer to query the position in the
current input stream, or the current line or column number.  When
patterns involving the start-of-line anchor <SAMP>`^'</SAMP> have been used,
Zlex makes it possible to query and set the current start-of-line
condition.
<P>
<A NAME="IDX107">.</A>
<A NAME="IDX108">.</A>
<A NAME="IDX109">.</A>
<H2><A NAME="SEC75" HREF="zlex_toc.html#SEC75">Input File Pointer: <CODE>yyin</CODE></A></H2>
<CODE>yyin</CODE> is the default name of the variable with declaration
<CODE>FILE *yyin</CODE> which Zlex uses to read its input.  Like all other
variable names, the name of this variable can be changed to an arbitrary
name by defining the macro <CODE>YY_IN</CODE> to the new name.  Alternatively,
the prefix used for the name can be changed by using the <SAMP>`--prefix'</SAMP>
option (see section <A HREF="zlex.html#SEC20">Variable Names</A>).
<P>
When the scanner function is first entered it initializes <CODE>yyin</CODE> to
<CODE>stdin</CODE>, unless the user has already initialized it to a
non-<CODE>NULL</CODE> <CODE>FILE</CODE> pointer.  So if the generated scanner should
read from a file other than the standard input, the programmer need only
initialize <CODE>yyin</CODE> to a suitable <CODE>FILE</CODE> pointer.  For example, the
following main program illustrates how to setup the scanner to read from the
file specified by the first command-line argument.
<P>
<PRE>
%{
#define YY_IN inFile    /* Use <CODE>inFile</CODE> instead of <CODE>yyin</CODE>. */
%}
%%
<I>`Patterns go here.'</I>
%%
int 
main(int argc, const char *argv[])
{
  if (argc &#60; 2) {
    <I>`Usage error.'</I>
  }
  if (!(inFile= fopen(argv[1], "r"))) {
    <I>`File open error.'</I>
  }
  return yylex();       /* Call generated scanner function. */
}
</PRE>
<P>
<A NAME="IDX110">.</A>
<A NAME="IDX111">.</A>
<A NAME="IDX112">.</A>
<H2><A NAME="SEC76" HREF="zlex_toc.html#SEC76">Direct Input: <CODE>input</CODE></A></H2>
<P>
The <CODE>input()</CODE> macro returns the next character from the input buffer,
returning -1 if end-of-file is encountered.  If C++ is being used, then the
alternate name <CODE>yy_input()</CODE> is used instead.  The canonical name
<CODE>YY_GET()</CODE> is also recognized.  The Zlex library function
<CODE>int yyGet(YYDataHandle)</CODE> can also be used to read the next character from
the input.  It returns -1 on EOF.  Use <CODE>YY_GET()</CODE> to read the input
when the call is within the scanner file.  Outside the scanner file it is
necessary to call <CODE>yyGet()</CODE> passing it the data handle of the relevant
scanner.
<P>
The following excerpt illustrates a common use of <CODE>input()</CODE> to ignore
C-style comments: 
<P>
<PRE>
"/*"            { int ch0, ch1= ' ';
                  do {
                    ch0= ch1; ch1= input();
                  } while (ch1 != EOF &#38;&#38; (ch0 != '*' || ch1 != '/'));
                  if (ch1 == EOF) error("EOF within comment.");
                }
</PRE>
<P>
Note that this is not the recommended way to process comments in Zlex.  For
the recommended method, see section <A HREF="zlex.html#SEC72">Start States Example: C comments</A>.
<P>
<A NAME="IDX113">.</A>
<A NAME="IDX114">.</A>
<A NAME="IDX115">.</A>
<H2><A NAME="SEC77" HREF="zlex_toc.html#SEC77">Redefining the Input Macro <CODE>YY_INPUT</CODE></A></H2>
<P>
<CODE>YY_INPUT(buf, result, maxSize)</CODE> provides input to Zlex buffers.  It
should fill the <CODE>char *buf</CODE> with upto <CODE>int maxSize</CODE> characters and
return in <CODE>int result</CODE> either the number of characters read or
<CODE>YY_EOF_IN</CODE> to indicate end-of-file.  Its default definition uses the
system <CODE>read</CODE> routine, but if the <CODE>--stdio</CODE> option is specified
(see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>), then its default definition uses the <CODE>fread</CODE> routine
from the <CODE>stdio</CODE> library.
<P>
The definition of the macro <CODE>YY_EOF_IN</CODE> to be returned by
<CODE>YY_INPUT</CODE> defaults to <CODE>YY_NULL</CODE> (see section <A HREF="zlex.html#SEC78">The Null Value: <CODE>YY_NULL</CODE></A>), but
it can be redefined by the programmer in section 1 of the Zlex source file
to some other value.
<P>
This macro can be redefined in section 1 of the Zlex file to get input some
other way.  For example, Zlex currently supports processing of only 7-bit or
8-bit characters.  However, it is possible to use Zlex to process words of
size larger than that of a <CODE>char</CODE>, if those words can be mapped into
characters without loss of information.  This can be done as follows:
<P>
<PRE>
#define YY_INPUT(buf, result, n)   result= wordInput(buf, n)

int
wordInput(char *buf, unsigned n)
{
  Word *wordBuf= (Word *)malloc(n * sizeof(Word));
  unsigned nWords;
  int result;
  if (!wordBuf) { <I>`Signal memory allocation error.'</I> }
  nWords= readWords(wordBuf, n); /* Read words from source. */
  if (nWords == 0) {
    result= YY_EOF_IN;
  }
  else {
    unsigned i;
    for (i= 0; i &#60; nWords; i++) buf[i]= mapWordToChar(wordBuf[i]);
    result= nWords;
  }
  free(wordBuf);
  return result;
}
</PRE>
<P>
where <CODE>mapWordToChar()</CODE> maps a word into a character.  Note that the
scanner will maintain the current lexeme in <CODE>yytext</CODE> using characters;
it will be the programmer's responsibility to map these characters back into
<CODE>Word</CODE>s.
<P>
<H2><A NAME="SEC78" HREF="zlex_toc.html#SEC78">The Null Value: <CODE>YY_NULL</CODE></A></H2>
<A NAME="IDX116">.</A>
<P>
The macro <CODE>YY_NULL</CODE> is used for two purposes:
<P>
<OL>
<LI>
It is the value to be returned by <CODE>YY_INPUT</CODE> (see section <A HREF="zlex.html#SEC77">Redefining the Input Macro <CODE>YY_INPUT</CODE></A>) on end-of-file.

<LI>
It is the value returned by the scanner when end-of-file is encountered.
</OL>
<P>
The default definition for <CODE>YY_NULL</CODE> is <CODE>0</CODE>, but the programmer
can redefine this macro in a C-code section in section 1 of the Zlex file.
<P>
Zlex uses <CODE>YY_NULL</CODE> only for compatibility with undocumented behavior
of <CODE>flex</CODE>.  Its use is discouraged, as it is has two distinct
purposes.  Instead, the programmer should use <CODE>YY_EOF_IN</CODE>
(see section <A HREF="zlex.html#SEC77">Redefining the Input Macro <CODE>YY_INPUT</CODE></A>) or <CODE>YY_EOF_OUT</CODE>
(see section <A HREF="zlex.html#SEC117">Return Value on Termination: <CODE>YY_EOF_OUT</CODE></A>) for each respective purpose.
<P>
<H2><A NAME="SEC79" HREF="zlex_toc.html#SEC79">Modifying Characters in the Input Stream</A></H2>
<A NAME="IDX117">.</A>
<P>
Two methods can be used by a Zlex programmer to force the generated
scanner to insert characters into the input stream.  The first of these is
<CODE>YY_LESS</CODE> which returns characters from the current lexeme to the input
stream; the other is <CODE>YY_UNPUT</CODE> which can be used to insert arbitrary
characters (not necessarily from the current lexeme) into the input stream.
<P>
<A NAME="IDX118">.</A>
<A NAME="IDX119">.</A>
<H3><A NAME="SEC80" HREF="zlex_toc.html#SEC80">Rescanning Lexeme Text: <CODE>yyless</CODE></A></H3>
<CODE>yyless(n)</CODE> returns all but the first n characters of the current lexeme
back to the input stream.  <CODE>yytext</CODE> and <CODE>yyleng</CODE> are suitably
adjusted.  The canonical form <CODE>YY_LESS(n)</CODE> can also be used.  The library
function <CODE>yyLess(YYDataHandle d, int n)</CODE> can also be used from files
other than the generated scanner file.
<P>
Note that if it is necessary to look ahead in the input stream in order to
recognize a token, it is preferable to use right context patterns
(see section <A HREF="zlex.html#SEC49">Right Context</A>).  Note also that <CODE>yyless(0)</CODE> will cause the
scanner to enter an infinite loop unless its state is changed in some way.
<P>
The following excerpt illustrates the use of <CODE>yyless</CODE> to generate
multiple tokens from the same subsequence of the input stream.  This may be
useful in a situation where a single input subsequence signals both the end
of a syntactic construct and the start of the next syntactic construct.  If
we assume that <CODE>xxx</CODE> is a Zlex macro defining the subsequence of
interest then the following code should achieve our goal:
<P>
<PRE>
{xxx}         { if (flag == 0) {
                    flag= 1; yyless(0); return TOK0;
                  }
                  else {
                    flag= 0; return TOK1;
                  }
              }
</PRE>
<P>
We assume that <CODE>flag</CODE> is a suitably declared C variable, and
<CODE>TOK0</CODE> and <CODE>TOK1</CODE> are the token values.
<P>
<A NAME="IDX120">.</A>
<A NAME="IDX121">.</A>
<A NAME="IDX122">.</A>
<H3><A NAME="SEC81" HREF="zlex_toc.html#SEC81">Unputting Characters: <CODE>unput</CODE></A></H3>
<CODE>unput(c)</CODE> puts the character <CODE>c</CODE> onto the input stream to be the
next character read.  The Zlex programmer should ensure that 0 &#60;= <CODE>c</CODE> &#60;
<VAR>character set size</VAR>; <CODE>unput</CODE> cannot be used to unput an <CODE>EOF</CODE>
character.  The contents of <CODE>yytext</CODE> are unaffected.  Note that it is
more efficient to use <CODE>yyless</CODE> if all that is desired is to unput a
suffix of <CODE>yytext</CODE>.
<P>
The canonical form <CODE>YY_UNPUT(c)</CODE> may also be used. The Zlex library
function <CODE>yyUnput(YYDataHandle d, int c)</CODE> may also be used from files
other than the generated scanner file.
<P>
The following excerpt illustrates the use of <CODE>unput</CODE> to translate
character sequences.  If an application dictates that the input sequences
<SAMP>`%%('</SAMP> and <SAMP>`%%)'</SAMP> be translated to the sequences <SAMP>`['</SAMP> and
<SAMP>`]'</SAMP> respectively before any tokenizing occurs, and it is known that the
sequences cannot occur within other tokens, then we can use the following
pattern-action pairs:
<P>
<PRE>
"%%("   unput('[');
"%%)"   unput(']');
</PRE>
<P>
Note that this suffices only because it is specified that the sequences
cannot occur within other tokens.  If that is not the case, then the above
code would not be correct and we would either need to redefine
<CODE>YY_INPUT</CODE> (see section <A HREF="zlex.html#SEC77">Redefining the Input Macro <CODE>YY_INPUT</CODE></A>) appropriately, or use
intra-token patterns (see section <A HREF="zlex.html#SEC102">Using Intra-Token Patterns</A>).
<P>
<A NAME="IDX123">.</A>
<A NAME="IDX124">.</A>
<H2><A NAME="SEC82" HREF="zlex_toc.html#SEC82">Forced Backtracking: <CODE>REJECT</CODE></A></H2>
Backtracking can be forced to occur in a Zlex scanner to try alternate
choices for a pattern by using the <CODE>REJECT</CODE> action.  The initial choice
of pattern is governed by the rules built into the generated scanner.  When
multiple patterns match the input to a Zlex generated scanner, the choice of
pattern is governed by rules which first prefer the longest match and then
the pattern which occurs earlier in the Zlex source file (see section <A HREF="zlex.html#SEC7">Pattern Conflicts</A>).
<P>
<A NAME="IDX125">.</A>
<A NAME="IDX126">.</A>
<A NAME="IDX127">.</A>
<P>
<CODE>REJECT</CODE> transfers control to the action of the next pattern which
matches the current lexeme or a prefix of the current lexeme.  This action
can also be referred to using the canonical name <CODE>YY_REJECT</CODE>.
<P>
<CODE>REJECT</CODE> performs a transfer of control -- it is equivalent to an
unconditional <CODE>goto</CODE> and the code immediately following the
<CODE>REJECT</CODE> will never be executed.  Also <CODE>REJECT</CODE> has function scope
and hence it cannot be used outside the actions.
<P>
<CODE>REJECT</CODE> is useful when overlapping subsequences of the input are to be
recognized as tokens.  This is illustrated by the following scanner which
outputs all the prefixes of the words in its input, where a word is a
maximal sequence not containing tab, blank or newline.
<P>
<PRE>
%%
[^\t \n]+       printf("%s\n", yytext); REJECT;
.|\n
</PRE>
<P>
<CODE>yytext</CODE> is a <CODE>NUL</CODE>-terminated C-string giving the text of the
current lexeme (see section <A HREF="zlex.html#SEC60">Current Lexeme Text: <CODE>yytext</CODE></A>).  Given the word <SAMP>`abc'</SAMP> the first
pattern will match; its action will first output <SAMP>`abc'</SAMP> on a separate
line.  When the <CODE>REJECT</CODE> action is executed, there is no other pattern
to match <SAMP>`abc'</SAMP>. Hence it will try to match a prefix of <SAMP>`abc'</SAMP>:
<SAMP>`ab'</SAMP> matches the first pattern.  So it will again output <SAMP>`ab'</SAMP> and
execute a <CODE>REJECT</CODE> action.  This <CODE>REJECT</CODE> results again in a match
with the first pattern and an output of <SAMP>`a'</SAMP>.  The subsequent
<CODE>REJECT</CODE> matches the second pattern with <SAMP>`a'</SAMP> but no action is
taken.  Hence the output will be:
<P>
<PRE>
abc
ab
a
</PRE>
<P>
The <CODE>REJECT</CODE> action is not inordinately expensive.
<P>
<A NAME="IDX128">.</A>
<A NAME="IDX129">.</A>
<A NAME="IDX130">.</A>
<H2><A NAME="SEC83" HREF="zlex_toc.html#SEC83">Current Character Count: <CODE>YY_CHAR_NUM</CODE></A></H2>
The macro <CODE>YY_CHAR_NUM</CODE> returns the number of characters read by the
scanner from the current file or memory buffer upto the start of the current
<CODE>yytext</CODE>.  The position does not include any of the characters of
<CODE>yytext</CODE>.  The returned position is zero-origin: hence the character
just after <CODE>yytext</CODE> will be at absolute position <CODE>YY_CHAR_NUM +
yyleng</CODE> in the file or in-memory buffer.
<P>
The value returned by <CODE>YY_CHAR_NUM</CODE> will not be correct if the
<CODE>unput</CODE> (see section <A HREF="zlex.html#SEC81">Unputting Characters: <CODE>unput</CODE></A>) action is used.
<P>
Many scanning applications require tracking the current line and column
number. If newlines can occur within other tokens, then the
<SAMP>`--yylineno'</SAMP> option provides suitable facilities (see section <A HREF="zlex.html#SEC84">Current Line Number: <CODE>yylineno</CODE></A>).  If newlines cannot occur within other tokens, then the
recommended method is illustrated by the following code fragment which shows
how YY_CHAR_NUM can be used to compute the current column number within a
line.
<P>
<PRE>
%{
  int lineStartPos= 0;  /* Starting YY_CHAR_NUM for a line. */
  int lineNum= 1;       /* 1 + # of '\n's seen so far. */
#define COL_NUM         (YY_CHAR_NUM - lineStartPos)
%}
%%
\n                 { lineStartPos= YY_CHAR_NUM + 1;  lineNum++;
                     <I>`Other actions for a newline.'</I>
                   }
</PRE>
<P>
The macro <CODE>COL_NUM</CODE> can now be used within other actions to access the
column number.  
<P>
<H2><A NAME="SEC84" HREF="zlex_toc.html#SEC84">Current Line Number: <CODE>yylineno</CODE></A></H2>
<P>
If the <SAMP>`--yylineno'</SAMP> option is specified, when the scanner is
generated, then the current line number (1-origin) is maintained in the
variable whose default name is <CODE>yylineno</CODE> and declaration <CODE>int
yylineno</CODE>.  Like all other variable names, the name of this variable can
be changed to an arbitrary name by defining the macro <CODE>YY_LINENO</CODE>
to the new name.  Alternatively, the prefix used for the name can be
changed by using the <SAMP>`--prefix'</SAMP> option (see section <A HREF="zlex.html#SEC20">Variable Names</A>).
<P>
Unlike the implementation of <CODE>yylineno</CODE> by other scanner
generators, a Zlex generated scanner does not test every character to
see if it is a newline.  It does these tests only when it is known that a
lexeme contains or is followed by a newline character: this information
is obtained using a hidden intra-token pattern (see section <A HREF="zlex.html#SEC102">Using Intra-Token Patterns</A>).  Hence scanning of lexemes which do not contain newlines is
not slowed down except for a simple test of a flag which is performed on
once per action rather than once per character.
<P>
Since a hidden intra-token pattern <CODE>+\n</CODE> (see section <A HREF="zlex.html#SEC102">Using Intra-Token Patterns</A> is used to implement the <CODE>yylineno</CODE> feature, this feature
will not work if the user specifies a intra-token pattern which overlaps
with the hidden pattern.  It will also not work correctly if the
programmer uses <CODE>unput</CODE> to put newline characters into the buffer.
<P>
This feature was added to Zlex for backward compatibility with an
undocumented feature of <CODE>lex</CODE> (documented in <CODE>flex</CODE>).  When
newlines cannot occur within other tokens it is usually not necessary to
use this feature as it is easy enough for the programmer to update a
line number counter whenever a pattern containing a newline character is
matched (see section <A HREF="zlex.html#SEC83">Current Character Count: <CODE>YY_CHAR_NUM</CODE></A>).
<P>
<H2><A NAME="SEC85" HREF="zlex_toc.html#SEC85">Current Column Number</A></H2>
<P>
If the <SAMP>`--yylineno'</SAMP> option is specified, then the macro
<CODE>YY_COL_NUM</CODE> returns the 0-origin column number within the current
line.  If newlines cannot occur within other tokens, see the example in
section <A HREF="zlex.html#SEC83">Current Character Count: <CODE>YY_CHAR_NUM</CODE></A>, for the recommended way to track this
information.
<P>
The current column number is computed only when the Zlex programmer uses
the <CODE>YY_COL_NUM</CODE> macro.  The implementation uses a hidden
intra-token pattern <CODE>+\n</CODE> (see section <A HREF="zlex.html#SEC102">Using Intra-Token Patterns</A> to
implement the <CODE>YY_COL_NUM</CODE> macro.  Hence this feature will not work
if the user specifies a intra-token pattern which overlaps with the
hidden pattern.  It will also not work correctly if the programmer uses
<CODE>unput</CODE> to put newline characters into the buffer.
<P>
<A NAME="IDX131">.</A>
<A NAME="IDX132">.</A>
<H2><A NAME="SEC86" HREF="zlex_toc.html#SEC86">Querying Beginning of Line: <CODE>YY_AT_BOL</CODE></A></H2>
The macro call <CODE>YY_AT_BOL()</CODE> returns non-zero if the next token to be
matched can match beginning-of-line patterns having a <SAMP>`^'</SAMP> anchor.
<P>
Note that this macro is provided only when there is at least one pattern
which uses the beginning-of-line <SAMP>`^'</SAMP> anchor.
<P>
<A NAME="IDX133">.</A>
<A NAME="IDX134">.</A>
<A NAME="IDX135">.</A>
<H2><A NAME="SEC87" HREF="zlex_toc.html#SEC87">Setting Beginning of Line: <CODE>yy_set_bol</CODE></A></H2>
The macro <CODE>yy_set_bol(<VAR>v</VAR>)</CODE> sets the beginning-of-line condition
for the next pattern to true if <VAR>v</VAR> is non-zero; false if <VAR>v</VAR> is
zero.  When the beginning-of-line condition is set true, the next pattern
can match beginning-of-line patterns having a <SAMP>`^'</SAMP> anchor; when it is
set false, the next pattern cannot match beginning-of-line patterns having a
<SAMP>`^'</SAMP> anchor.
<P>
The canonical macro name <CODE>YY_SET_BOL</CODE> can be used synonymously with
<CODE>yy_set_bol</CODE>.  
<P>
Note that these macros are provided only when there is at least one pattern
which uses the beginning-of-line <SAMP>`^'</SAMP> anchor.
<P>
<H1><A NAME="SEC88" HREF="zlex_toc.html#SEC88">Output in a Zlex Scanner</A></H1>
<P>
Limited facilities are provided in a Zlex scanner for echoing the current
lexeme to a <CODE>FILE</CODE> pointer with default name <CODE>yyout</CODE>
<P>
<A NAME="IDX136">.</A>
<A NAME="IDX137">.</A>
<A NAME="IDX138">.</A>
<H2><A NAME="SEC89" HREF="zlex_toc.html#SEC89">Output File Pointer: <CODE>yyout</CODE></A></H2>
<CODE>yyout</CODE> is the default name of the variable with declaration
<CODE>FILE *yyout</CODE> which Zlex uses to echo the current lexeme
(see section <A HREF="zlex.html#SEC90">Echoing Lexeme Text: <CODE>ECHO</CODE></A>).  Like all other variable names,
the name of this variable can be changed to an arbitrary name by
defining the macro <CODE>YY_OUT</CODE> to the new name.  Alternatively, the
prefix used for the name can be changed by using the <SAMP>`--prefix'</SAMP>
option (see section <A HREF="zlex.html#SEC20">Variable Names</A>).
<P>
When the scanner function is first entered it initializes <CODE>yyout</CODE> to
<CODE>stdout</CODE>, unless the user has already initialized it to a non-<CODE>NULL</CODE>
<CODE>FILE</CODE> pointer.  So if the generated scanner should echo to a file
other than the standard output, the programmer need only initialize
<CODE>yyout</CODE> to a suitable <CODE>FILE</CODE> pointer.
<P>
<A NAME="IDX139">.</A>
<A NAME="IDX140">.</A>
<A NAME="IDX141">.</A>
<H2><A NAME="SEC90" HREF="zlex_toc.html#SEC90">Echoing Lexeme Text: <CODE>ECHO</CODE></A></H2>
The <CODE>ECHO</CODE> macro echoes the current lexeme to <CODE>yyout</CODE>.  The
canonical name <CODE>YY_ECHO</CODE> can also be used.
<P>
The following example removes all lines starting with <KBD>#</KBD>.
<P>
<PRE>
%%
^#.*\n          |
^#.*            /* No action: don't echo. */
.*\n            |
.*              ECHO;
</PRE>
<P>
The patterns <CODE>^#.*</CODE> and <CODE>.*</CODE> take care of processing the
last line in the file when it does not end with a newline.
<P>
<A NAME="IDX142">.</A>
<H1><A NAME="SEC91" HREF="zlex_toc.html#SEC91">Buffer Management</A></H1>
For efficiency reasons, a Zlex scanner buffers its input.  Hence if the Zlex
programmer wishes to switch input to a new file, it is not sufficient to
merely change <CODE>yyin</CODE> (see section <A HREF="zlex.html#SEC75">Input File Pointer: <CODE>yyin</CODE></A>), as the scanner will
continue reading from its previously buffered input.  It is necessary to
switch to a buffer for the new file.  Buffer management actions provide
facilities for doing this.
<P>
Buffers need not necessarily be associated with files.  It is possible to
create buffers whose contents are taken from a string or some other
in-memory structure.  When the scanner reaches the end of an in-memory
buffer, it does normal end-of-file processing.
<P>
Tokens are not allowed to span buffer boundaries.
<P>
<A NAME="IDX143">.</A>
<A NAME="IDX144">.</A>
<A NAME="IDX145">.</A>
<H2><A NAME="SEC92" HREF="zlex_toc.html#SEC92">The Buffer Type: <CODE>YY_BUFFER_STATE</CODE></A></H2>
The handle used to refer to a buffer has the declaration:
<PRE>
typedef void *YYBufHandle;
</PRE>
For compatibility with <CODE>flex</CODE>, the programmer can also refer to this
type using the macro <CODE>YY_BUFFER_STATE</CODE>.  This opaque type can be passed
to and returned from the buffer management actions.
<P>
<A NAME="IDX146">.</A>
<A NAME="IDX147">.</A>
<A NAME="IDX148">.</A>
<A NAME="IDX149">.</A>
<H2><A NAME="SEC93" HREF="zlex_toc.html#SEC93">The Current Buffer: <CODE>yy_current_buffer</CODE></A></H2>
<CODE>yy_current_buffer</CODE> is the default name of a variable which
contains a <CODE>YY_BUFFER_STATE</CODE> handle to the current buffer.  Like
all other variable names, the name of this variable can be changed to an
arbitrary name by defining the macro <CODE>YY_CURRENT_BUFFER</CODE> to the new
name.  Alternatively, the prefix used for the name can be changed by
using the <SAMP>`--prefix'</SAMP> option (see section <A HREF="zlex.html#SEC20">Variable Names</A>).
<P>
The user should never explicitly assign a value to this variable, but do so
only implicitly by calling the appropriate buffer management routine
(see section <A HREF="zlex.html#SEC100">Switching Buffers: <CODE>yy_switch_to_buffer</CODE></A>).
<P>
<A NAME="IDX150">.</A>
<A NAME="IDX151">.</A>
<A NAME="IDX152">.</A>
<A NAME="IDX153">.</A>
<H2><A NAME="SEC94" HREF="zlex_toc.html#SEC94">Creating a Buffer: <CODE>yy_create_buffer</CODE></A></H2>
The macro call <CODE>yy_create_buffer(f, s)</CODE> creates a buffer for
<CODE>FILE</CODE> pointer <CODE>f</CODE>, having space for at least <CODE>s</CODE> characters.
(The macro <CODE>YY_BUF_SIZE</CODE> contains a recommended value for <CODE>s</CODE>.)
The value returned is a <CODE>YY_BUFFER_STATE</CODE> (see section <A HREF="zlex.html#SEC92">The Buffer Type: <CODE>YY_BUFFER_STATE</CODE></A>).
<P>
The canonical name <CODE>YY_CREATE_BUFFER</CODE> can also be used for this macro.
From files other than the Zlex source file, the library function with
prototype 
<P>
<PRE>
YY_BUFFER_STATE 
yyCreateBuffer(YYDataHandle d, FILE *f, yy_size_t s);
</PRE>
can be used to create and initialize a buffer for the file with <CODE>FILE</CODE>
pointer f, having space for at least <CODE>s</CODE> characters.  It returns the
handle of the newly created buffer, aborting execution on error.
<P>
<A NAME="IDX154">.</A>
<A NAME="IDX155">.</A>
<A NAME="IDX156">.</A>
<A NAME="IDX157">.</A>
<H2><A NAME="SEC95" HREF="zlex_toc.html#SEC95">Deleting a Buffer: <CODE>yy_delete_buffer</CODE></A></H2>
The macro call <CODE>yy_delete_buffer(b)</CODE> deletes the buffer with
<CODE>YY_BUFFER_STATE b</CODE>.  <CODE>b</CODE> must have been previously returned by
one of the buffer creation actions.
<P>
The canonical name <CODE>YY_DELETE_BUFFER</CODE> can also be used for this macro.
From files other than the Zlex source file, the library function with
prototype 
<P>
<PRE>
void
yyDeleteBuffer(YYDataHandle d, YYBufHandle b);
</PRE>
<P>
can be used to delete buffer with handle <CODE>b</CODE> for the scanner with
handle <CODE>d</CODE>.
<P>
<A NAME="IDX158">.</A>
<A NAME="IDX159">.</A>
<A NAME="IDX160">.</A>
<A NAME="IDX161">.</A>
<H2><A NAME="SEC96" HREF="zlex_toc.html#SEC96">Flushing a Buffer: <CODE>yy_flush_buffer</CODE></A></H2>
The macro call <CODE>yy_flush_buffer(b)</CODE> flushes the buffer with
<CODE>YY_BUFFER_STATE b</CODE>.  When the scanner subsequently tries to read a
character from the buffer, the buffer will be refreshed.  There is no
canonical name for the <CODE>yy_flush_buffer</CODE> macro as, for backwards
compatibility with <CODE>flex</CODE>, the name <CODE>YY_FLUSH_BUFFER</CODE> does something
somewhat different: specifically, it is used without any arguments to
specify an action to flush the <EM>current</EM> buffer (equivalent to
<CODE>yy_flush_buffer(YY_CURRENT_BUFFER)</CODE>).
<P>
From files other than the Zlex source file, the library function with
prototype 
<P>
<PRE>
void 
yyFlushBuffer(YYDataHandle d, YY_BUFFER_STATE b);
</PRE>
<P>
can be used to flush buffer <CODE>b</CODE> for the scanner whose internal state is
encapsulated in <CODE>d</CODE>.
<P>
<A NAME="IDX162">.</A>
<A NAME="IDX163">.</A>
<A NAME="IDX164">.</A>
<A NAME="IDX165">.</A>
<H2><A NAME="SEC97" HREF="zlex_toc.html#SEC97">Creating a In-Memory Buffer: <CODE>yy_scan_buffer</CODE></A></H2>
The macro <CODE>yy_scan_buffer(memBuf, len)</CODE> creates and returns a
<CODE>YY_BUFFER_STATE</CODE> which contains the contents of <CODE>char *memBuf</CODE>
having a total of <CODE>yy_size_t len</CODE> bytes.  <CODE>memBuf</CODE> is not copied:
hence the programmer should ensure that <CODE>memBuf</CODE> is retained until the
processing of the <CODE>YY_BUFFER_STATE</CODE> returned by <CODE>yy_scan_buffer</CODE>
is completed.  <CODE>memBuf</CODE> will be used when the newly created buffer is
scanned: in fact, <CODE>memBuf</CODE> may even be temporarily modified during the
course of scanning.
<P>
The last two bytes of <CODE>memBuf</CODE> must be <EM>sentinel</EM> characters (the
sentinel character defaults to <CODE>'\0'</CODE> unless changed by the
<SAMP>`--sentinel'</SAMP> option (see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>)).  If this is not true, then a
<CODE>NULL</CODE> <CODE>YY_BUFFER_STATE</CODE> is returned.  These two sentinel
characters will not be scanned when the scanner switches to this buffer:
hence the characters which will be scanned will be <CODE>memBuf[0]</CODE> ...
<CODE>memBuf[len - 3]</CODE> inclusive.
<P>
The canonical name <CODE>YY_MEM_BUFFER</CODE> can also be used for this macro.  
<P>
From files other than the Zlex source file, the library function with
prototype 
<P>
<PRE>
YY_BUFFER_STATE 
yyMemBuffer(YYDataHandle d, char *memBuf, yy_size_t len);
</PRE>
<P>
can be used to create a memory buffer for the scanner whose state is
encapsulated in <CODE>d</CODE>, with the other arguments being as defined for the
macro.  It returns the <CODE>YY_BUFFER_STATE</CODE> handle for the created buffer;
<CODE>NULL</CODE> if <CODE>memBuf</CODE> does not have the two sentinel characters at
its end; it aborts with an error message if it cannot create the buffer
because it is out of memory.
<P>
It is important to realize that if the same memory area is used to create
multiple Zlex buffers, then each Zlex buffer must be deleted before a new
Zlex buffer is created from the same memory area.
<P>
The following function illustrates the use of in-memory buffers to paste
tokens together as is required by the <CODE>##</CODE> operator in a C
preprocessor.  We assume that a <CODE>Token</CODE> is a <CODE>struct</CODE> with two
fields: a small integer <CODE>tok</CODE> giving the token number, and another
small integer <CODE>id</CODE> which gives the text associated with the token.  We
also assume the existence of the following routines:
<P>
<DL COMPACT>
<DT><CODE>getIDString(id)</CODE>
<DD>Returns
the text associated with a <CODE>id</CODE>.

<DT><CODE>getIDLen(id)</CODE>
<DD>Returns the
length of the text associated with a <CODE>id</CODE>.

<DT><CODE>MALLOC()</CODE>
<DD><DT><CODE>FREE()</CODE>
<DD>These are merely error-checking versions of the standard-library
<CODE>malloc()</CODE> and <CODE>free()</CODE> respectively.

<DT><CODE>error()</CODE>
<DD>Prints out error messages.

<DT><CODE>yylex()</CODE>
<DD>The generated scanner function.  We assume that it is setup to return a
<CODE>Token</CODE> instead of simply a <CODE>int</CODE> (see section <A HREF="zlex.html#SEC117">Return Value on Termination: <CODE>YY_EOF_OUT</CODE></A>).

</DL>
<PRE>
Token
tokenPaste(Token token1, Token token2)
/* Paste tokens token1 and token2 together, returning resulting token.
 * Signal an error if the pasted token is not proper.
 */
{
  const unsigned id1= token1.id;
  const unsigned id2= token2.id;
  const unsigned len1= getIDLen(id1);
  const unsigned len2= getIDLen(id2);
  const unsigned bufSize= len1 + len2 + 1 + 2; 	/* 1 '\n' + 2 sentinel chars. */
  enum { AUTO_BUF_SIZE= 100 };
  char autoBuffer[AUTO_BUF_SIZE];
  char *const autoBuf= autoBuffer;
  char *const dynamicBuf= (bufSize &#60;= AUTO_BUF_SIZE) ? NULL : MALLOC(bufSize);
  char *const *bufP= (dynamicBuf) ? &#38;dynamicBuf : &#38;autoBuf;
  Token tokenZ, eolToken;
  YY_BUFFER_STATE oldBuf= YY_CURRENT_BUFFER;
  YY_BUFFER_STATE pasteBuf;
  strncpy(*bufP, getIDString(id1), len1);
  strncpy(*bufP + len1, getIDString(id2), len2);
  *(*bufP + bufSize - 3)= '\n';
  *(*bufP + bufSize - 2)= *(*bufP + bufSize - 1)= '\0';
  pasteBuf= yy_scan_buffer(*bufP, bufSize);
  yy_switch_to_buffer(pasteBuf);
  tokenZ= yylex(); eolToken= yylex();
  if (eolToken.tok != '\n') {
    error("Invalid token produced by ## pasting of `%s' and `%s'.",
	  getIDString(id1), getIDString(id2));
  }
  yy_delete_buffer(pasteBuf);
  yy_switch_to_buffer(oldBuf);
  if (dynamicBuf) FREE(dynamicBuf);
  return tokenZ;  
}
</PRE>
The function creates the in-memory buffer on the runtime stack if the
required amount of memory is smaller than a predetermined amount; otherwise
it creates the in-memory buffer on the heap.  It uses <CODE>bufP</CODE> to point
to the chosen buffer.  It remembers the original Zlex buffer in the
<CODE>YY_BUFFER_STATE</CODE> variable <CODE>oldBuf</CODE>.  It then uses the standard
library function <CODE>strncpy()</CODE> to copy the text of the tokens to be
catenated into the chosen buffer.  It terminates the copied text by a
<CODE>'\n'</CODE> followed by the two required <CODE>'\0'</CODE> sentinel characters.
It then creates a Zlex buffer using <CODE>yy_scan_buffer()</CODE>.  It switches to
the newly created buffer (see section <A HREF="zlex.html#SEC100">Switching Buffers: <CODE>yy_switch_to_buffer</CODE></A>) and then reads two
tokens from it: it expects the first token to be the catenated token which
is desired, and the second token to be a <CODE>'\n'</CODE>.  It then deletes the
created Zlex buffer and switches back to the original Zlex buffer
<CODE>oldBuf</CODE>.  Finally, if the in-memory buffer was allocated on the heap
it frees it.
<P>
<A NAME="IDX166">.</A>
<A NAME="IDX167">.</A>
<A NAME="IDX168">.</A>
<A NAME="IDX169">.</A>
<H2><A NAME="SEC98" HREF="zlex_toc.html#SEC98">Creating a Buffer from In-Memory Bytes: <CODE>yy_scan_bytes</CODE></A></H2>
The macro <CODE>yy_scan_bytes(bytes, len)</CODE> creates and returns a
<CODE>YY_BUFFER_STATE</CODE> which contains the contents of <CODE>char *bytes</CODE>
having a total of <CODE>yy_size_t len</CODE> bytes.  The contents of <CODE>bytes</CODE>
is copied into the newly created buffer.  <CODE>bytes</CODE> itself will not be
used at all when the newly created buffer is scanned and can be destroyed
once the buffer has been created.
<P>
The canonical name <CODE>YY_BYTES_BUFFER</CODE> can also be used for this macro.  
<P>
From files other than the Zlex source file, the library function with
prototype 
<P>
<PRE>
YY_BUFFER_STATE 
yyBytesBuffer(YYDataHandle d, char *bytes, yy_size_t len);
</PRE>
<P>
can be used to create a memory buffer for the scanner whose state is
encapsulated in <CODE>d</CODE>, with the other arguments being as defined for the
macro.  It returns the <CODE>YY_BUFFER_STATE</CODE> handle for the created buffer,
aborting with an error message if it cannot create the buffer because it is
out of memory.
<P>
<A NAME="IDX170">.</A>
<A NAME="IDX171">.</A>
<A NAME="IDX172">.</A>
<A NAME="IDX173">.</A>
<H2><A NAME="SEC99" HREF="zlex_toc.html#SEC99">Creating a Buffer from a In-Memory String: <CODE>yy_scan_string</CODE></A></H2>
The macro <CODE>yy_scan_string(str)</CODE> creates and returns a
<CODE>YY_BUFFER_STATE</CODE> which contains the contents of the
<KBD>NUL</KBD>-terminated C-string <CODE>char *str</CODE> having a total of
<CODE>yy_size_t len</CODE> bytes (not counting the terminating <KBD>NUL</KBD>).  The
contents of <CODE>str</CODE> is copied into the newly created buffer.  <CODE>str</CODE>
itself will not be used at all when the newly created buffer is scanned
and can be destroyed once the buffer has been created.
<P>
The canonical name <CODE>YY_STRING_BUFFER</CODE> can also be used for this macro.  
<P>
From files other than the Zlex source file, the library function with
prototype 
<P>
<PRE>
YY_BUFFER_STATE 
yyStringBuffer(YYDataHandle d, char *str);
</PRE>
<P>
can be used to create a memory buffer for the scanner whose state is
encapsulated in <CODE>d</CODE>, with the <CODE>str</CODE> argument as for the
macro.  It returns the <CODE>YY_BUFFER_STATE</CODE> handle for the created buffer,
aborting with an error message if it cannot create the buffer because it is
out of memory.
<P>
<A NAME="IDX174">.</A>
<A NAME="IDX175">.</A>
<A NAME="IDX176">.</A>
<A NAME="IDX177">.</A>
<H2><A NAME="SEC100" HREF="zlex_toc.html#SEC100">Switching Buffers: <CODE>yy_switch_to_buffer</CODE></A></H2>
The macro <CODE>yy_switch_to_buffer(b)</CODE> sets up the scanner to scan from
the previously created buffer identied by the <CODE>YY_BUFFER_STATE
b</CODE>. The contents of either buffer are not affected.
<P>
The canonical name <CODE>YY_SWITCH_TO_BUFFER</CODE> can also be used for this macro.  
<P>
From files other than the Zlex source file, the library function with
prototype 
<P>
<PRE>
void
yyStringBuffer(YYDataHandle d, YY_BUFFER_STATE b);
</PRE>
<P>
can be used to create a memory buffer for the scanner whose state is
encapsulated in <CODE>d</CODE>, with the <CODE>b</CODE> argument as for the
macro.
<P>
<CODE>yy_switch_to_buffer</CODE> should be the only way the Zlex programmer
changes the current buffer.
<P>
<A NAME="IDX178">.</A>
<A NAME="IDX179">.</A>
<H2><A NAME="SEC101" HREF="zlex_toc.html#SEC101">Buffer Management Example</A></H2>
The following example illustrates the use of the buffer management routines
to implement a nested file inclusion facility similar to that of C.  A line
starting with the <KBD>#</KBD> character followed by the word <SAMP>`include'</SAMP> and
a <VAR>file-name</VAR> is replaced by the contents of <VAR>file-name</VAR>.
<P>
<PRE>
%{
enum { MAX_INCL_DEPTH= 3 };

static YY_BUFFER_STATE inclStk[MAX_INCL_DEPTH];
static unsigned inclSP= 0;

static void includeFile(char *fName);

%}

fileName        [0-9a-zA-Z./]+

%x INCLUDE
%%
^[\t ]*#[\t ]*include   BEGIN INCLUDE;
&#60;INCLUDE&#62;{fileName}     includeFile(yytext); BEGIN INITIAL;
&#60;INCLUDE&#62;[\t ]+         /* No action. */
&#60;INCLUDE&#62;\n             BEGIN INITIAL;
&#60;&#60;EOF&#62;&#62;                 { if (inclSP == 0) 
                            yyterminate();
                          else {
                            yy_switch_to_buffer(inclStk[--inclSP]);
                            BEGIN INCLUDE;
                          }
                        }
%%

static void includeFile(char *fName) 
{
  if (inclSP == MAX_INCL_DEPTH) {
    fprintf(stderr, "Includes nested too deeply.\n");
    return;
  }
  inclStk[inclSP++]= YY_CURRENT_BUFFER;
  yyin= fopen(fName, "r");
  if (!yyin) {
    fprintf(stderr, "Could not open %s.\n", fName); exit(1);
  }
  yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
}
</PRE>
<P>
<H1><A NAME="SEC102" HREF="zlex_toc.html#SEC102">Using Intra-Token Patterns</A></H1>
<P>
Sometimes it is necessary to do pre-lexical processing on the characters
scanned by the generated scanner before they are tokenized by the scanner.
An example of pre-lexical processing would be mapping certain sequences of
characters into others.  The easiest way to do so is to intercept the input
to the scanner: Zlex provides a way for the Zlex programmer to do just that
by redefining the <CODE>YY_INPUT()</CODE> macro. See section <A HREF="zlex.html#SEC77">Redefining the Input Macro <CODE>YY_INPUT</CODE></A>. Though this is adequate for most situations, it is not appropriate
for all situations since Zlex buffers its input.  The following example
illustrates the problem.
<P>
ANSI-C requires that all occurrences of escaped newlines (a <SAMP>`\'</SAMP>
followed by a newline) in the input be deleted.  It is required that this be
done before tokens be recognized: for example a <SAMP>`/'</SAMP> followed by an
escaped newline followed immediately by a <SAMP>`*'</SAMP> should be recognized as
the start of a comment.  This can be done relatively easily by defining
<CODE>YY_INPUT()</CODE> to read the C source file into a buffer which is then
processed to delete escaped newlines.  Unfortunately this does not allow the
scanner to keep track of the source line number of the current token for
proper reporting of error messages.  What is needed is to perform the
pre-lexical processing incrementally as each token is scanned.
<P>
Intra-token patterns allow this type of incremental pre-lexical processing.
When a <DFN>intra-token pattern</DFN> is recognized <EM>within</EM> a token, the
scanning of the token is suspended and the action associated with
the intra-token pattern is executed.  Then the suspended scanning of
the token is resumed. Thus, the only effects of recognizing the intra-token
pattern are the possible side-effects (if any) of the intra-token action.
<P>
<H2><A NAME="SEC103" HREF="zlex_toc.html#SEC103">Intra-Token Pattern Syntax</A></H2>
<P>
Syntactically, an intra-token pattern consist of the <SAMP>`+'</SAMP> character
followed by a regular expression subject to the following restrictions:
<P>
<UL>

<LI>
The regular expression is restricted to
match only fixed length regular expressions (thus precluding the use of the
<SAMP>`?'</SAMP> (optional), <SAMP>`+'</SAMP> (one-or-more) or <SAMP>`*'</SAMP> (closure) operators
among others). 

<LI>
Qualifying an intra-token pattern by start states is not
allowed.

</UL>
<P>
For example, <CODE>+\\\n</CODE> is an intra-token pattern which matches an
escaped newline.
<P>
<H2><A NAME="SEC104" HREF="zlex_toc.html#SEC104">Actions for Intra-Token Patterns</A></H2>
<P>
<CODE>yytext</CODE> and <CODE>yyleng</CODE> (see section <A HREF="zlex.html#SEC59">Accessing the Current Lexeme</A>) are
available as usual within intra-token pattern actions.  The special 
<CODE>YY_BACKUP</CODE> action (see section <A HREF="zlex.html#SEC105">Backing Up Within a Intra-Token Pattern: <CODE>YY_BACKUP</CODE></A>) is also available within
intra-token pattern actions.  Since an intra-token pattern represents
a interrupted scan of a token, the action for an intra-token pattern are
subject to the following rather severe restrictions:
<P>
<UL>

<LI>
The effect of any other of Zlex's action facilities except those
explicitly mentioned above is undefined within an intra-token pattern
action.

<LI>
An intra-token pattern is not allowed to share its action with that of any
other pattern.  Hence the action associated with an intra-token pattern or
the pattern immediately before an intra-token pattern cannot be <SAMP>`|'</SAMP>.

<LI>
An intra-token pattern action should not terminate by performing a
control transfer like a <CODE>return</CODE>.

</UL>
<P>
<A NAME="IDX180">.</A>
<A NAME="IDX181">.</A>
<H2><A NAME="SEC105" HREF="zlex_toc.html#SEC105">Backing Up Within a Intra-Token Pattern: <CODE>YY_BACKUP</CODE></A></H2>
<P>
Intra-token patterns are intended for doing pre-lexical processing which
needs to be done incrementally during scanning.  It is expected that this
processing will usually involve translating the token matching the
intra-token pattern to another token and then continue scanning.  The
<CODE>YY_BACKUP</CODE> action is tailored for such processing.
<P>
The macro <CODE>YY_BACKUP(<VAR>len</VAR>, <VAR>string</VAR>)</CODE> specifies an action to
be used only within actions for intra-pattern tokens.  The length <VAR>len</VAR>
must be no greater than the length of the intra-token pattern and
<VAR>string</VAR> should be a <KBD>NUL</KBD>-terminated C-string.  The effect of
<CODE>YY_BACKUP(<VAR>len</VAR>, <VAR>string</VAR>)</CODE> is to backup the scanner automaton
over the last <VAR>len</VAR> characters of the intra-token pattern, replacing
those <VAR>len</VAR> characters by <VAR>string</VAR>. <CODE>YY_BACKUP</CODE> may perform 
a control transfer: hence it should not be followed by any code to which
control is expected to fall through after <CODE>YY_BACKUP</CODE>.
<P>
For example, to delete escaped newlines in a C-scanner, we could use
the following pattern-action pair.
<P>
<PRE>
+\\\n           YY_BACKUP(2, "");
</PRE>
<P>
<H1><A NAME="SEC106" HREF="zlex_toc.html#SEC106">End-of-File and Termination</A></H1>
<P>
The generated scanner normally terminates when an <CODE>EOF</CODE> is received on
the input stream.  This default action can be changed in two ways:
<P>
<OL>
<LI>
An <CODE>EOF</CODE> on the input stream need not terminate the scanner provided
the Zlex programmer sets up the input to come from another source.
<LI>
A scanner can terminate before an <CODE>EOF</CODE> is received from the input
stream.
</OL>
<P>
<A NAME="IDX182">.</A>
<A NAME="IDX183">.</A>
<H2><A NAME="SEC107" HREF="zlex_toc.html#SEC107">Wrapping Up: <CODE>yywrap</CODE></A></H2>
A function whose default prototype is <CODE>int yywrap(void)</CODE> is called by
the scanner when it detects end-of-file on its current input stream
<CODE>yyin</CODE>.  If the function returns non-zero then the
scanner proceeds to wrap-up its processing; it processes its
<CODE>&#60;&#60;EOF&#62;&#62;</CODE> actions if any (see section <A HREF="zlex.html#SEC56">End of File Patterns</A>) and if these
actions do not change its flow of control, it returns <CODE>YY_EOF_OUT</CODE>
(which defaults to <CODE>0</CODE>) indicating an end-of-file token.
<P>
If the call to <CODE>yywrap</CODE> returns <CODE>0</CODE>, then the scanner assumes that
the function has set up <CODE>yyin</CODE> to continue scanning.  It does not
execute the actions associated with any <CODE>&#60;&#60;EOF&#62;&#62;</CODE> patterns but merely
continues scanning.
<P>
Like Zlex variable names, the name of this function can be changed to an
arbitrary name by defining the macro <CODE>YY_WRAP</CODE> to the new name.
Alternatively, the prefix used for the name can be changed by using the
<SAMP>`--prefix'</SAMP> option (see section <A HREF="zlex.html#SEC21">Function Names</A>).
<P>
The Zlex library provides a <CODE>yywrap()</CODE> function which simply returns 
<CODE>1</CODE>.  
<P>
<A NAME="IDX184">.</A>
<H2><A NAME="SEC108" HREF="zlex_toc.html#SEC108"><CODE>&#60;&#60;EOF&#62;&#62;</CODE> Pattern Actions</A></H2>
If the <CODE>yywrap</CODE> function (see section <A HREF="zlex.html#SEC107">Wrapping Up: <CODE>yywrap</CODE></A>) returns non-zero, then
the scanner executes the actions associated with its <CODE>&#60;&#60;EOF&#62;&#62;</CODE> actions
if any.  These actions provide another opportunity for the programmer to
reset the scanner so as to continue scanning.  The following points need to
be noted:
<P>
<UL>
<LI>
<CODE>yytext</CODE> and <CODE>yyleng</CODE> are not defined for <CODE>&#60;&#60;EOF&#62;&#62;</CODE> patterns.
Hence the actions for <CODE>&#60;&#60;EOF&#62;&#62;</CODE> patterns should not refer to these
variables.

<LI>
If <CODE>yyin</CODE> is pointed to a new <CODE>FILE</CODE> pointer within an
<CODE>&#60;&#60;EOF&#62;&#62;</CODE> action, then scanning will continue.  For compatibility
with old versions of <CODE>flex</CODE>, the <CODE>YY_NEW_FILE</CODE> and
<CODE>YY_RESTART</CODE> actions (see section <A HREF="zlex.html#SEC110">Restarting a Scanner: <CODE>yyrestart</CODE></A>) may be used
after resetting <CODE>yyin</CODE> but is not necessary.

<LI>
The scanner can switch to a new buffer by using a <CODE>yy_switch_to_buffer</CODE>
action (see section <A HREF="zlex.html#SEC100">Switching Buffers: <CODE>yy_switch_to_buffer</CODE></A>).

<LI>
The scanner can execute a return statement.

<LI>
It can execute a <CODE>yyterminate()</CODE> action (see section <A HREF="zlex.html#SEC109">Terminating a Scanner: <CODE>yyterminate</CODE></A>).

<LI>
Control can simply fall off the end of the <CODE>&#60;&#60;EOF&#62;&#62;</CODE> action.  In that
case, the scanner will return to its caller with a <CODE>YY_EOF_OUT</CODE> (which
defaults to <CODE>YY_NULL</CODE>).
</UL>
<P>
<A NAME="IDX185">.</A>
<A NAME="IDX186">.</A>
<A NAME="IDX187">.</A>
<A NAME="IDX188">.</A>
<H2><A NAME="SEC109" HREF="zlex_toc.html#SEC109">Terminating a Scanner: <CODE>yyterminate</CODE></A></H2>
<CODE>yyterminate()</CODE> terminates the scanner and returns a <CODE>YY_EOF_OUT</CODE>
(which defaults to 0) to the caller.  Subsequent calls to the scanner will
continue to return with <CODE>YY_EOF_OUT</CODE>, until a <CODE>yyrestart</CODE>,
<CODE>YY_NEW_FILE</CODE> or <CODE>yy_switch_to_buffer</CODE> action is executed.
<P>
The canonical form <CODE>YY_TERMINATE()</CODE> can also be used instead.
<P>
<A NAME="IDX189">.</A>
<A NAME="IDX190">.</A>
<A NAME="IDX191">.</A>
<A NAME="IDX192">.</A>
<H2><A NAME="SEC110" HREF="zlex_toc.html#SEC110">Restarting a Scanner: <CODE>yyrestart</CODE></A></H2>
The action <CODE>yyrestart(fileP)</CODE> restarts scanning, taking input from  the
file with the <CODE>stdio</CODE> <CODE>FILE</CODE> pointer <CODE>fileP</CODE>.  The current
contents of the Zlex buffer are discarded.  The canonical name
<CODE>YY_RESTART</CODE> can also be used instead.
<A NAME="IDX193">.</A>
<P>
If <CODE>yyin</CODE> has been pointed to a new file, then the action
<CODE>YY_NEW_FILE</CODE> (without any arguments) tells the scanner that a new file
has been setup in <CODE>yyin</CODE>.  <CODE>YY_NEW_FILE</CODE> is equivalent to
<CODE>yyrestart(yyin)</CODE>.
<P>
<H1><A NAME="SEC111" HREF="zlex_toc.html#SEC111">The Main Scanner Function</A></H1>
<P>
The top-level scanner function in a Zlex scanner has default name
<CODE>yylex</CODE>.  The user can customize the name and declaration of the
function, as well as define macros to cause certain actions to be taken.
<P>
<A NAME="IDX194">.</A>
<A NAME="IDX195">.</A>
<A NAME="IDX196">.</A>
<A NAME="IDX197">.</A>
<H2><A NAME="SEC112" HREF="zlex_toc.html#SEC112">The Main Scanner Function: <CODE>yylex</CODE></A></H2>
<P>
The name of the main scanning function defaults to <CODE>yylex</CODE>, but
like other names, the name of this function can be changed to an
arbitrary name by defining the macro <CODE>YY_LEX</CODE> to the new name.
Alternatively, the prefix used for the name can be changed by using the
<SAMP>`--prefix'</SAMP> option (see section <A HREF="zlex.html#SEC21">Function Names</A>).  Hence to change the
name of the main scanning function to <CODE>scan</CODE>, the programmer merely
need have the line
<P>
<PRE>
#define YY_LEX scan
</PRE>
in the C-code section of section 1 of the Zlex file.
<P>
<A NAME="IDX198">.</A>
<A NAME="IDX199">.</A>
<A NAME="IDX200">.</A>
<H2><A NAME="SEC113" HREF="zlex_toc.html#SEC113">Declaring the Scanner Function: <CODE>YY_DECL</CODE></A></H2>
The macro <CODE>YY_DECL</CODE> gives the default declaration of the scanner
function.  Its definition is equivalent to:
<P>
<PRE>
#ifndef YY_DECL
#define YY_DECL int YY_LEX(void)
#endif
</PRE>
<P>
The programmer can change this declaration by suitably <SAMP>`#define'</SAMP>ing
<CODE>YY_DECL</CODE> in the C-code section of section 1 of the Zlex file.  See
section <A HREF="zlex.html#SEC117">Return Value on Termination: <CODE>YY_EOF_OUT</CODE></A> for how to use <CODE>YY_DECL</CODE> to declare a
scanner function which returns a <CODE>struct</CODE> rather than a <CODE>int</CODE>.
<P>
<A NAME="IDX201">.</A>
<A NAME="IDX202">.</A>
<H2><A NAME="SEC114" HREF="zlex_toc.html#SEC114">Initialization: <CODE>YY_USER_INIT</CODE></A></H2>
The macro <CODE>YY_USER_INIT</CODE> can be defined by the programmer to be code
which will be executed when the scanner first starts up, before the first
scan.  Its definition defaults to empty code.  It is useful for initializing
variables used by the programmer.  Before the first call to the main scanner
function, the only Zlex actions guaranteed to work are the buffer creation
and switching routines (see section <A HREF="zlex.html#SEC91">Buffer Management</A>).
<P>
The scanner's buffer is statically initialized to a special initialization
state.  If there is no buffer switching action before the first call to the
scanner function, then the scanner buffer will still be in this special
initialization state at the first call.  The first call to the scanner
checks whether the buffer is in this special initialization state: if it is,
it creates a new buffer corresponding to the current <CODE>yyin</CODE>; if it not,
then it assumes that the programmer has created and switched to a valid
buffer and uses that buffer without modification.  Note that the effect of
using such a special initialization buffer in subsequent scanner calls is
undefined.
<P>
<A NAME="IDX203">.</A>
<A NAME="IDX204">.</A>
<H2><A NAME="SEC115" HREF="zlex_toc.html#SEC115">Specifying a Pre-Action for every Pattern: <CODE>YY_USER_ACTION</CODE></A></H2>
The macro <CODE>YY_USER_ACTION</CODE> can be defined by the programmer to be code
which will always be executed before any matched rule action.  Its
definition defaults to empty code.
<P>
<A NAME="IDX205">.</A>
<H2><A NAME="SEC116" HREF="zlex_toc.html#SEC116">Specifying the Separator Between Actions: <CODE>YY_BREAK</CODE></A></H2>
The user actions specified in the Zlex file are copied into the main scanner
function as part of a switch statement.  The macro <CODE>YY_BREAK</CODE> is used
to separate the actions within the <CODE>switch</CODE> statement.  Its definition
defaults to <CODE>break</CODE>.
<P>
Redefining this macro appears to be of limited utility.  This feature is
included for compatibility with <CODE>flex</CODE>.  The rationale for
including this feature in <CODE>flex</CODE> was to prevent unreachable
statement warnings when a user action naturally terminates with a
control transfer like a <CODE>return</CODE>.  With this feature, the user can
define <CODE>YY_BREAK</CODE> to be empty while ensuring that every action
terminates with a transfer of control (inserting explicit breaks, if
necessary), thus avoiding the warnings.
<P>
<A NAME="IDX206">.</A>
<A NAME="IDX207">.</A>
<H2><A NAME="SEC117" HREF="zlex_toc.html#SEC117">Return Value on Termination: <CODE>YY_EOF_OUT</CODE></A></H2>
<P>
The macro YY_EOF_OUT specifies the value to be returned by the scanner on
end-of-file after <CODE>yywrap</CODE> returns 1 and the <CODE>&#60;&#60;EOF&#62;&#62;</CODE> actions (if
any) do not reset the input <CODE>yyin</CODE>.  Its definition defaults to
<CODE>YY_NULL</CODE> (see section <A HREF="zlex.html#SEC78">The Null Value: <CODE>YY_NULL</CODE></A>) but it can be redefined by the
programmer in section 1 of the Zlex file.
<P>
For example, by using <CODE>YY_DECL</CODE> (see section <A HREF="zlex.html#SEC113">Declaring the Scanner Function: <CODE>YY_DECL</CODE></A>) macro, it is possible for the Zlex programmer to make the scanner
return a <CODE>struct</CODE> rather than a <CODE>int</CODE>.  If this is done, then the
value returned on end-of-file must also be a suitable <CODE>struct</CODE>: this
can be achieved by defining <CODE>YY_EOF_OUT</CODE> to a call of a suitable
function returning the suitable <CODE>struct</CODE>.  Appropriate definitions and
declarations are shown below:
<P>
<PRE>
%{

/* Define the type returned by the scanner. */
typedef struct {
  ...
} Token;

/* Declare a function returning a special EOF Token struct. */
Token eofToken(void);       

/* Scanner declaration. */
#define YY_DECL Token YY_LEX(void)

/* EOF return value definition. */
#define YY_EOF_OUT eofToken()
  
%}
</PRE>
<P>
<H2><A NAME="SEC118" HREF="zlex_toc.html#SEC118">Pattern Numbers: <CODE>yy_act</CODE> and <CODE>YY_NUM_RULES</CODE></A></H2>
<A NAME="IDX208">.</A>
<A NAME="IDX209">.</A>
<P>
Within the actions, the macro <CODE>yy_act</CODE> refers to the pattern number
which is currently being matched where the patterns from the Zlex source
file are numbered starting at 1.  The macro <CODE>YY_NUM_RULES</CODE> refers to
the total number of patterns for which actions exist in the generated
scanner; this will usually be greater than the number of patterns explicitly
specified by the programmer in the Zlex source file, since Zlex uses several
pseudo-actions for its own purposes.
<P>
<A NAME="IDX210">.</A>
<H1><A NAME="SEC119" HREF="zlex_toc.html#SEC119">Debugging and Errors</A></H1>
Limited facilities are provided for debugging Zlex programs.  A C macro and
a variable control whether debugging messages are output as a pattern is
recognized.  In addition, it is also possible to obtain a more detailed
trace detailing the action of the scanner as each individual character is
scanned.
<P>
<A NAME="IDX211">.</A>
<H2><A NAME="SEC120" HREF="zlex_toc.html#SEC120">Debugging Control</A></H2>
<P>
Several equivalent macros and a single variable control whether debugging
messages are output to <CODE>stderr</CODE> as patterns are matched.  
<P>
If the <SAMP>`--debug'</SAMP> option is specified when the scanner file is generated
(see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>), or if the macro <CODE>YYDEBUG</CODE> is defined when the
generated scanner file is compiled, and if at runtime, the variable with
default name <CODE>yy_Zlex_debug</CODE> has a non-zero value, then messages are
printed on <CODE>stderr</CODE> as patterns are matched.  Where applicable, the
printed messages include the source file name and line number of the matched
pattern, as well as the contents of <CODE>yytext</CODE>.  The format is similar to
that of compiler error messages of popular compilers like <CODE>gcc</CODE>; this
makes it possible to use tools like <CODE>emacs</CODE> <CODE>compile-mode</CODE> to
point to the appropriate pattern in the source file. See section `Compiling within emacs' in <CITE>The GNU Emacs Manual</CITE>.
<A NAME="IDX212">.</A>
<P>
The macro <CODE>YY_ZL_DEBUG</CODE> is equivalent to <CODE>YYDEBUG</CODE>.  This
alternate name is useful when a project uses both Zlex as well as a parser
generated by a member of the <CODE>yacc</CODE>-family of parser generators.  The
reason is that <CODE>YYDEBUG</CODE> is also used for similar purposes by such
parser-generators; if the option <CODE>-DYYDEBUG</CODE> is passed as a C-compiler
option to a <TT>`Makefile'</TT> for the project, both the generated Zlex scanner
as well as the parser will run in debug-mode, resulting in rather confusing
output. 
<A NAME="IDX213">.</A>
<P>
The <CODE>extern</CODE> variable with default name <CODE>yy_zlex_debug</CODE> allows
debugging messages to be turned on and off dynamically: messages are printed
only when the variable has a non-zero value.  When debugging is turned on
as described above, the variable is declared in the generated scanner and
initialized to <CODE>1</CODE>: hence message printing is initially enabled.
<A NAME="IDX214">.</A>
<P>
Like all other variable names, the name of this variable can be changed
to an arbitrary name by defining the macro <CODE>YY_ZLEX_DEBUG</CODE> to the
new name.  Alternatively, the prefix used for the name can be changed by
using the <SAMP>`--prefix'</SAMP> option (see section <A HREF="zlex.html#SEC20">Variable Names</A>).
<P>
<H2><A NAME="SEC121" HREF="zlex_toc.html#SEC121">A Debugging Example</A></H2>
<P>
Assume that the following scanner is defined in file <TT>`debug.l'</TT>.
<P>
<PRE>
 01 /* Scanner which illustrates debugging messages. */
 02 
 03 %option debug
 04 
 05 %%
 06 
 07 [[:digit:]]+                |
 08 [[:alpha:]]+                REJECT;
 09 .|\n
</PRE>
<P>
If the generated scanner is compiled and run on the input consisting of the
single line
<P>
<PRE>
ab12
</PRE>
<P>
the following output is produced on <CODE>stderr</CODE>.
<P>
<PRE>
debug.l:8: yytext= `ab'.
debug.l:8: yytext= `a'.
debug.l:9: yytext= `a'.
debug.l:8: yytext= `b'.
debug.l:9: yytext= `b'.
debug.l:7: yytext= `12'.
debug.l:7: yytext= `1'.
debug.l:9: yytext= `1'.
debug.l:7: yytext= `2'.
debug.l:9: yytext= `2'.
debug.l:9: yytext= `
'.
--EOF.
</PRE>
<P>
<A NAME="IDX215">.</A>
<H2><A NAME="SEC122" HREF="zlex_toc.html#SEC122">Scanner Tracing</A></H2>
If the scanner is compiled with the C macro <CODE>YYTRACE</CODE> <CODE>#define</CODE>d,
then when the scanner is run it provides a detailed trace showing the action
it takes at every character it scans.  The trace shows the transitions
of the underlying finite automaton.  To decipher this trace, it is
necessary to have compiled the scanner using the <SAMP>`--trace'</SAMP> option
(see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>).  This is useful mainly for maintaining Zlex.
<P>
<H2><A NAME="SEC123" HREF="zlex_toc.html#SEC123">Runtime Errors: <CODE>yyerr</CODE></A></H2>
<P>
It is possible for Zlex to encounter runtime errors under several
conditions: 
<P>
<UL>
<LI>
Dynamic memory allocation fails.

<LI>
An error occurs while reading an input file.

<LI>
The programmer attempts to access an empty start state stack.

<LI>
The programmer attempts to switch to a <CODE>NULL</CODE> buffer.

<LI>
The scanner encounters a character which is not matched by any pattern and
the <CODE>--suppress-default</CODE> option (see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>) has been specified. 
</UL>
<P>
When a runtime error is encountered, the generated scanner writes a message
on the <CODE>FILE</CODE> pointer <CODE>yyerr</CODE> and terminates execution of the
program.  
<A NAME="IDX216">.</A>
<A NAME="IDX217">.</A>
<P>
Like all other variable names, the name of this variable can be changed
to an arbitrary name by defining the macro <CODE>YY_ERR</CODE> to the
new name.  Alternatively, the prefix used for the name can be changed by
using the <SAMP>`--prefix'</SAMP> option (see section <A HREF="zlex.html#SEC20">Variable Names</A>).
<P>
When the scanner function is first entered it initializes <CODE>yyerr</CODE> to
<CODE>stderr</CODE>, unless the programmer has already initialized it to a
non-<CODE>NULL</CODE> <CODE>FILE</CODE> pointer.  So if the generated scanner should
output error messages to a file other than the standard error, the
programmer need only initialize <CODE>yyerr</CODE> to a suitable <CODE>FILE</CODE>
pointer.
<A NAME="IDX218">.</A>
<P>
All error messages are preceeded by the string which is the value of the
macro <CODE>YY_PROGRAM_NAME</CODE> which defaults to <CODE>"Zlex scanner"</CODE>.  This
macro can be redefined by the programmer in section 1 of the Zlex source file.
<P>
<H1><A NAME="SEC124" HREF="zlex_toc.html#SEC124">Multiple Scanners</A></H1>
<P>
Sometimes it is necessary to include multiple scanners in a program.  For
example, an application may need one scanner to scan a data file and another
scanner to scan interactive user input.  
<P>
Most of the global objects used by a generated scanner are declared
<CODE>static</CODE>.  Hence their names are local to the generated C file.  Since
different scanners are generated in different C files, the semantics of C
preclude the possibility of a clash between the <CODE>static</CODE> names used in
different scanners.  However there will be a link-time clash between the
<CODE>extern</CODE> names used for global objects declared in different scanners.
To circumvent this problem, Zlex allows the programmer to choose the names
for the <CODE>extern</CODE> objects using one of the following schemes:
<P>
<OL>
<LI>
Using the
<SAMP>`--prefix'</SAMP> option (see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>).  This is the simpler alternative.

<LI>
Defining macros giving the name of each <CODE>extern</CODE> object.
</OL>
<P>
<H2><A NAME="SEC125" HREF="zlex_toc.html#SEC125">Prefix Option</A></H2>
By default the name of each <CODE>extern</CODE> scanner object starts with the
prefix <SAMP>`yy'</SAMP>.  This prefix can be changed by using the <SAMP>`--prefix'</SAMP>
option (see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>).  The names which are affected are:
<P>
<DL COMPACT>
<DT><CODE>yy_current_buffer</CODE>
<DD>See section <A HREF="zlex.html#SEC93">The Current Buffer: <CODE>yy_current_buffer</CODE></A>.
<DT><CODE>yy_Zlex_debug</CODE>
<DD>See section <A HREF="zlex.html#SEC120">Debugging Control</A>.
<DT><CODE>yydataP</CODE>
<DD>See section <A HREF="zlex.html#SEC24">Passing the Scanner State to Zlex Library Routines</A>.
<DT><CODE>yyerr</CODE>
<DD>See section <A HREF="zlex.html#SEC123">Runtime Errors: <CODE>yyerr</CODE></A>.
<DT><CODE>yyin</CODE>
<DD>See section <A HREF="zlex.html#SEC75">Input File Pointer: <CODE>yyin</CODE></A>.
<DT><CODE>yyleng</CODE>
<DD>See section <A HREF="zlex.html#SEC61">Current Lexeme Length: <CODE>yyleng</CODE></A>.
<DT><CODE>yylex</CODE>
<DD>See section <A HREF="zlex.html#SEC112">The Main Scanner Function: <CODE>yylex</CODE></A>.
<DT><CODE>yylineno</CODE>
<DD>See section <A HREF="zlex.html#SEC84">Current Line Number: <CODE>yylineno</CODE></A>.
<DT><CODE>yyout</CODE>
<DD>See section <A HREF="zlex.html#SEC89">Output File Pointer: <CODE>yyout</CODE></A>.
<DT><CODE>yytext</CODE>
<DD>See section <A HREF="zlex.html#SEC60">Current Lexeme Text: <CODE>yytext</CODE></A>.
<DT><CODE>yywrap</CODE>
<DD>See section <A HREF="zlex.html#SEC107">Wrapping Up: <CODE>yywrap</CODE></A>.
</DL>
<P>
<H2><A NAME="SEC126" HREF="zlex_toc.html#SEC126">Redefining Name Macros</A></H2>
Another method to ensure that the names of <CODE>extern</CODE> objects do not
clash between multiple scanners is to redefine the macros which specify the
names of these objects.  This should be done in a C-code section in section
1 of the Zlex file.  The macros and the objects they name are:
<P>
<DL COMPACT>
<DT><CODE>YY_CURRENT_BUFFER</CODE>
<DD>Names <CODE>yy_current_buffer</CODE> (see section <A HREF="zlex.html#SEC93">The Current Buffer: <CODE>yy_current_buffer</CODE></A>).
<DT><CODE>YY_DATA_P</CODE>
<DD>Names <CODE>yydataP</CODE> (see section <A HREF="zlex.html#SEC24">Passing the Scanner State to Zlex Library Routines</A>).
<DT><CODE>YY_ERR</CODE>
<DD>Names <CODE>yyerr</CODE> (see section <A HREF="zlex.html#SEC123">Runtime Errors: <CODE>yyerr</CODE></A>).
<DT><CODE>YY_IN</CODE>
<DD>Names <CODE>yyin</CODE> (see section <A HREF="zlex.html#SEC75">Input File Pointer: <CODE>yyin</CODE></A>).
<DT><CODE>YY_LENG</CODE>
<DD>Names <CODE>yyleng</CODE> (see section <A HREF="zlex.html#SEC61">Current Lexeme Length: <CODE>yyleng</CODE></A>).
<DT><CODE>YY_LEX</CODE>
<DD>Names <CODE>yylex</CODE> (see section <A HREF="zlex.html#SEC112">The Main Scanner Function: <CODE>yylex</CODE></A>).
<DT><CODE>YY_LINENO</CODE>
<DD>Names <CODE>yylineno</CODE> (see section <A HREF="zlex.html#SEC84">Current Line Number: <CODE>yylineno</CODE></A>).
<DT><CODE>YY_OUT</CODE>
<DD>Names <CODE>yyout</CODE> (see section <A HREF="zlex.html#SEC89">Output File Pointer: <CODE>yyout</CODE></A>).
<DT><CODE>YY_TEXT</CODE>
<DD>Names <CODE>yytext</CODE> (see section <A HREF="zlex.html#SEC60">Current Lexeme Text: <CODE>yytext</CODE></A>).
<DT><CODE>YY_WRAP</CODE>
<DD>Names <CODE>yywrap</CODE> (see section <A HREF="zlex.html#SEC107">Wrapping Up: <CODE>yywrap</CODE></A>).
<DT><CODE>YY_ZLEX_DEBUG</CODE>
<DD>Names <CODE>yy_Zlex_debug</CODE> (see section <A HREF="zlex.html#SEC120">Debugging Control</A>).
</DL>
<P>
The generated scanner sets these macros to their default values (the default
values factor in the <SAMP>`--prefix'</SAMP> option if it has been specified) only
if they have not already been defined in section 1 of the Zlex file.  Hence
the Zlex programmer can easily make the scanner use different external
names, by simply defining these macros to suitable names in section 1 of the
Zlex file.
<P>
<H2><A NAME="SEC127" HREF="zlex_toc.html#SEC127">Renaming Example</A></H2>
For example, to build a scanner which uses the names <CODE>yylex1</CODE>,
<CODE>yytext1</CODE>, <CODE>yyleng1</CODE>, <CODE>yyin1</CODE>, <CODE>yyout1</CODE> for some of the
<CODE>extern</CODE> objects, section 1 of the Zlex file would contain the
following <CODE>#define</CODE>'s:
<P>
<PRE>
%{

#define YY_LEX  yylex1
#define YY_TEXT yytext1
#define YY_LENG yyleng1
#define YY_IN   yyin1
#define YY_OUT  yyout1

%}
</PRE>
<P>
The rest of the program would access this generated scanner as follows: The
main scanning function would be called as <CODE>yylex1()</CODE>.  The lexeme text
and length of the current token would be found in <CODE>yytext1</CODE> and
<CODE>yyleng1</CODE>.  The <CODE>FILE</CODE> pointers <CODE>yyin1</CODE> and <CODE>yyout1</CODE>
would be used for the input and output files of the generated scanner.  The
function <CODE>yywrap()</CODE> will be called on end-of-file; this will be the
<CODE>yywrap()</CODE> provided by the Zlex library, unless the Zlex programmer
defines one elsewhere in the program.
<P>
<H1><A NAME="SEC128" HREF="zlex_toc.html#SEC128">Invoking Zlex</A></H1>
<P>
The command line needed to invoke Zlex has the format:
<P>
<PRE>
zlex [<VAR>Options List</VAR>] <VAR>lex-file</VAR> [<VAR>lex-file</VAR>...]
</PRE>
<P>
<P>
<UL>

<LI>
If no <VAR>lex-file</VAR>s are specified on
the command line and the <SAMP>`--lex-compat'</SAMP> option is not specified, then a
help message is printed on the standard output.  

<LI>
If no <VAR>lex-file</VAR>s are specified on the command line and the
<SAMP>`--lex-compat'</SAMP> option is specified, then Zlex reads the source file
from its standard input.

<LI>
If multiple <VAR>lex-files</VAR>s are specified, then their concatenation is
treated as a single logical file.

<LI>
A <VAR>lex-file</VAR> specified by the single character <SAMP>`-'</SAMP> stands for the
standard input.

</UL>
<P>
<H2><A NAME="SEC129" HREF="zlex_toc.html#SEC129">Option Conventions</A></H2>
<P>
A word which constitutes a command-line argument has two possible types: it
is a <DFN>option word</DFN> if it begin with a <SAMP>`-'</SAMP> or <SAMP>`--'</SAMP> (with
certain exceptions noted below), or if it follows an option word which
requires an argument.  Otherwise it is a <DFN>non-option word</DFN>.  An option
word specifies the value of a Zlex option; a non-option word specifies a
file name.
<P>
<UL>
<LI>
Options with short single character names must begin with a single <SAMP>`-'</SAMP>.

<LI>
Options with long multiple-character names must begin with <SAMP>`--'</SAMP>.  The
name can consists of any alphanumeric characters along with <SAMP>`-'</SAMP> and
<SAMP>`_'</SAMP> characters.

<LI>
When a option is specified using a long name, it is sufficient to specify an
unambiguous prefix of its name.

<LI>
If an option has a value which must be one of several prespecified values,
then it is sufficient to specify an unambiguous prefix of the value, in a
manner similar to long option names.

<LI>
It is possible to specify an option value in the same word as the option
name.  For short option names, there should not be any intervening
characters between the short name and the value.  For long option names, the
long name should be separated from the value using a single <SAMP>`='</SAMP>
character. 

<LI>
If an option has an <EM>optional</EM> value, then the value must be provided
in the same word as the option name, as outlined above.

<LI>
If an option has a <EM>required</EM> value, then the value may be provided in
the same word as the option name as outlined above, or it may be
provided in the next word.  In the latter case, the entire next word is
taken to be the value (even if it looks like an option starting with
<SAMP>`-'</SAMP> or <SAMP>`--'</SAMP>).

<LI>
Short names for multiple options which are not allowed to have any values
may be combined into a single word.  For example, if the options <SAMP>`-l'</SAMP>
and <SAMP>`-7'</SAMP> are not allowed to have any values, then instead of specifying
them using two words as <SAMP>`-l -7'</SAMP>, they can be specified using a single
word <SAMP>`-l7'</SAMP>.

<LI>
If an option is given two incompatible values, then the option which is
specified later dominates.

<LI>
If the option consisting simply of the two characters <SAMP>`--'</SAMP> is
specified, then all the remaining words on the command line will not be
treated as options irrespective of whether they start with <SAMP>`-'</SAMP> or
<SAMP>`--'</SAMP>.  This makes it possible to specify file names starting with a
<SAMP>`-'</SAMP>.

<LI>
Option words and non-option words may be arbitrarily interspersed.

<LI>
Command-line options always override the options specified elsewhere
(see section <A HREF="zlex.html#SEC130">Option Sources</A>).

</UL>
<P>
<H2><A NAME="SEC130" HREF="zlex_toc.html#SEC130">Option Sources</A></H2>
<P>
Besides the command-line, Zlex can read its options from several different
sources.  In order of increasing priority these sources are the following:
<P>
<UL>

<LI>
The file <TT>`zlex.opt'</TT>.  The file should contain only option names and
values separated by whitespace (newline counts as whitespace).  In addition
it may contain comments enclosed within <SAMP>`/*'</SAMP> and <SAMP>`*/'</SAMP>.  The file
is searched for using Zlex's search list (see section <A HREF="zlex.html#SEC138">Data Search List</A>).

The use of this file for setting defaults, makes it possible for a site to
setup default options for Zlex different from its builtin defaults.  It also
makes it easy to drop Zlex into a GUI toolset where options are set using a
graphical user interface.

<LI>
The environment variable <CODE>ZLEX_OPTIONS</CODE>.  If this variable is set, then
its value should contain only options and option values separated by
whitespace as on the command-line.  The procedure for setting environment
variables depends on the system you are using: under the UNIX shell
<CODE>csh</CODE> the <CODE>setenv</CODE> command can be used, under the MS-DOS
command-interpreter the <CODE>set</CODE> command can be used; under the UNIX shell
<CODE>sh</CODE> or <CODE>ksh</CODE> the <CODE>export</CODE> command can be used.

<LI>
It is also possible to specify options directly within the Zlex source file
using the <CODE>%option</CODE>, <CODE>%array</CODE> or <CODE>%pointer</CODE>
directives (see section <A HREF="zlex.html#SEC13">Declarations Section</A>).  

</UL>
<P>
Options specified by the environment variable <CODE>ZLEX_OPTIONS</CODE> overrides
the options specified in the <TT>`zlex.opt'</TT> file.  Options specified in the
Zlex source file override options specified in the <TT>`zlex.opt'</TT> file or
<CODE>ZLEX_OPTIONS</CODE> environment variable.  Finally, command-line options
always override options specified by all other sources.
<P>
<H2><A NAME="SEC131" HREF="zlex_toc.html#SEC131">Options</A></H2>
<P>
Zlex provides a largely orthogonal set of options.  We can roughly classify
the options according to which aspect of Zlex's functionality they affect.
<P>
<H3><A NAME="SEC132" HREF="zlex_toc.html#SEC132">Runtime Input Options</A></H3>
<P>
These options control how the generated Zlex scanner treats its input.
<P>
<DL COMPACT>

<DT><CODE>--16-bit</CODE>
<DD>Generate a 16-bit scanner which supports upto 65536 characters.  It is the
programmers responsibility to ensure that all input characters have a
character code between 0 and 65535 inclusive.  This option should be used if
the generated scanner is to support Unicode characters.

<DT><CODE>--7-bit</CODE>
<DD><DT><CODE>-7</CODE>
<DD>Generate a 7-bit scanner which supports upto 128 characters.  It is the
programmers responsibility to ensure that all input characters have
a character code between 0 and 127 inclusive.  

<DT><CODE>--8-bit</CODE>
<DD><DT><CODE>-8</CODE>
<DD>Generate a 8-bit scanner which supports upto 256 characters.  It is the
programmers responsibility to ensure that all input characters have
a character code between 0 and 255 inclusive.  

<DT><CODE>--ignore-case[=1|0]</CODE>
<DD><DT><CODE>-i[1|0]</CODE>
<DD><DT><CODE>--caseless[=1|0]</CODE>
<DD><DT><CODE>--case-insensitive[=1|0]</CODE>
<DD>Controls the case sensitivity of the generated scanner.  If the value of the
option is specified as 1, then the generated scanner will not distinguish
between upper-case and lower-case characters.  Note however, that the
generated scanner will retain the case of the characters constituting the
current lexeme in <CODE>yytext</CODE>.  If this option is not specified, then the
generated scanner will be case-sensitive.

<DT><CODE>--sentinel=CHAR-CODE</CODE>
<DD><DT><CODE>-S CHAR-CODE</CODE>
<DD>Use the character with decimal code <CODE>CHAR-CODE</CODE> as the sentinel
character.  Scanning the sentinel character is likely to be slower than
scanning non-sentinel characters; this option allows the programmer to
change the sentinel character to a character which may not occur frequently
in the scanner input.  If this option is not specified, then the sentinel
character defaults to the character whose code is 0.

<DT><CODE>--stdio[=1|0]</CODE>
<DD>By default, the generated scanner uses the underlying systems <CODE>read()</CODE>
function to read its input.  If this option is specified, it uses a the
<CODE>stdio</CODE> <CODE>fread()</CODE> function instead.  It may be necessary to
specify this option if your system does not take kindly to mixing
<CODE>stdio</CODE> <CODE>FILE</CODE> descriptors with <CODE>read()</CODE>.  The generated
scanner may be somewhat slower, and its interactive operation may suffer,
depending on the implementation of the <CODE>fread()</CODE> function provided by
the <CODE>stdio</CODE> library.  This option will not have any effect if the
programmer has redefined the <CODE>YY_INPUT</CODE> macro (see section <A HREF="zlex.html#SEC77">Redefining the Input Macro <CODE>YY_INPUT</CODE></A>).

</DL>
<P>
<H3><A NAME="SEC133" HREF="zlex_toc.html#SEC133">Runtime Algorithm Options</A></H3>
<P>
The options described in this section affect aspects of the algorithm used
by the generated scanner.  Options which affect scanner tables are described
in section <A HREF="zlex.html#SEC135">Table Scanner Options</A>.  Options which affect generated scanners
which minimize their use of tables are described in section <A HREF="zlex.html#SEC134">Code Scanner Options</A>. 
<P>
<DL COMPACT>

<DT><CODE>--array[=1|0]</CODE>
<DD>Implement <CODE>yytext</CODE> as an array instead of the default pointer.  This
will usually lead to a slower scanner.

<DT><CODE>--backup-optimize[=1|0]</CODE>
<DD>If value of this option is specified as 1, then the generated scanner
optimized for backing up.  This may slow down the scanning of normal
patterns somewhat, but is likely to speedup the scanning of patterns which
require the scanner to backup.  This option should be used only if the
scanner's patterns require a lot of backing up, or if the scanner makes
heavy use of <CODE>REJECT</CODE>.  By default, backup-optimization is off.
See section <A HREF="zlex.html#SEC139">Efficiency</A>. 

<DT><CODE>--default-action echo|error|fatal|ignore</CODE>
<DD>This option controls the action of the generated scanner if it encounters a
input character which does not match any action.  The effects of the
different option values is described below:

<DL COMPACT>

<DT><CODE>echo</CODE>
<DD>The unmatched character is echoed to <CODE>yyout</CODE>.  This is the default.

<DT><CODE>error</CODE>
<DD>An error message is output to <CODE>yyerr</CODE> and scanning continues.

<DT><CODE>fatal</CODE>
<DD>An error message is output to <CODE>yyerr</CODE> and the program is terminated.

<DT><CODE>ignore</CODE>
<DD>The unmatched character is simply ignored and scanning continues.

</DL>

<DT><CODE>--equiv-classes[=1|0]</CODE>
<DD><DT><CODE>--ecs[=1|0]</CODE>
<DD><DT><CODE>-E[1|0]</CODE>
<DD>It is often the case that the behavior of the generated scanner is identical
for certain classes of input characters.  When this option is specified,
Zlex partitions the input characters into equivalence classes such that the
behavior of the generated scanner is guaranteed to be identical for all the
characters in an equivalence class.  This option usually leads to large
space savings while paying only a small time cost and is on by default.

<DT><CODE>--prefix PREFIX</CODE>
<DD><DT><CODE>-P PREFIX</CODE>
<DD>Use prefix as the prefix of certain global names in the generated scanner
(the default prefix is <SAMP>`yy'</SAMP>).  See section <A HREF="zlex.html#SEC125">Prefix Option</A>.

<DT><CODE>--reject[=1|0]</CODE>
<DD>Support REJECT actions in the generated scanner.  If <CODE>--reject=0</CODE> is
specified, then any <CODE>REJECT</CODE> action in the source file will result in a
compile-time errors when the generated scanner is compiled.  The default is
to support <CODE>REJECT</CODE> actions.

<DT><CODE>--yylineno[=1|0]</CODE>
<DD>Maintain the current line number within the input in the global variable
<CODE>yylineno</CODE> (see section <A HREF="zlex.html#SEC84">Current Line Number: <CODE>yylineno</CODE></A>).  The default action is to not
support <CODE>yylineno</CODE>.  Using <CODE>yylineno</CODE> may lead to a somewhat
larger scanner but will not slow down the matching of patterns which do not
contain newlines.  It is the programmer's responsibility to suitably update
<CODE>yylineno</CODE> after scanner actions like <CODE>yyless</CODE> or <CODE>unput</CODE>
(see section <A HREF="zlex.html#SEC79">Modifying Characters in the Input Stream</A>).  yylineno is maintained on a per buffer basis and
is automatically saved and restored on a buffer switch.

</DL>
<P>
<H3><A NAME="SEC134" HREF="zlex_toc.html#SEC134">Code Scanner Options</A></H3>
<P>
Zlex supports the generation of code-scanners which do not use an explicit
scanner state or scan tables.  Instead these scanners use the program
counter to implicitly maintain the scanner state.  The current
implementation is disappointing: the generated scanners are fairly large but
are not appreciably faster.
<P>
Some limitatitions are imposed by the current implementation on code
scanners:
<P>
<UL>

<LI>
Code scanners cannot be built for any source file which contains a right
context pattern (see section <A HREF="zlex.html#SEC49">Right Context</A>) in which <EM>both</EM> the regular
expression and the context match strings of indeterminate length.

<LI>
Code scanners cannot be built with backing up optimized using
<CODE>--backup-optimize=1</CODE>.  

</UL>
<P>
When Zlex builds a code scanner it analyzes each state before deciding what
kind of code to build for a state.  The kinds of code built for a state are:
<P>
<DL COMPACT>
<DT>Linear Code
<DD>The code for the state is organized as a linear sequence of tests on the
current input character to find the next state.

<DT>Binary Code
<DD>The code for the state is organized as a binary search on the
current input character to find the next state.

<DT>Switch Code
<DD>The code for the state is organized as a switch on the current input
character to find the next state.

</DL>
<P>
The options for generating code scanners allow the programmer to control the
parameters of the algorithm Zlex uses for choosing between the above code
alternatives:
<P>
<DL COMPACT>

<DT><CODE>--code-scan[=1|0]</CODE>
<DD>This options generates a scanner with the DFA encoded in code instead of the
default encoding within scanner tables.

<DT><CODE>--bin-code-param N</CODE>
<DD>A binary search is used for a state only when the number of input ranges (a
<DFN>range</DFN> is a sequence of consecutive input characters which have the
same successor state) is less than or equal to <CODE>N</CODE>.  Otherwise switch
code is used.  The default value of <CODE>N</CODE> is 16.

<DT><CODE>--lin-code-param N</CODE>
<DD>A linear search is used for a state only when the number of successor states
is less than or equal to <CODE>N</CODE>.  Otherwise binary search or switch code
is used.  The default value of <CODE>N</CODE> is 4.

<DT><CODE>--transition-compress[=1|0]</CODE>
<DD>This option compresses transitions from non-switch states in the scanner.
If the code for a successor state of a non-switch state has not already been
output, then the code for the successor is directly inserted within the code
for the predecessor state, rather than a transition to separate code for the
successor.

</DL>
<P>
If both <CODE>--bin-code-param</CODE> and <CODE>--lin-code-param</CODE> are specified as
0, then only switch code is produced for all state transitions.  
<P>
In addition, if the compiler supports labels as first class objects and
provided a method to access the addresses of code labels, switches are
directly coded as a branch through a jump table.  For example, <CODE>gcc</CODE>
allows taking the address of a <VAR>label</VAR> using <CODE>&#38;&#38;<VAR>label</VAR></CODE>.  
See section `Labels as Values' in <CITE>Using and Porting GNU cc</CITE>.
Specifically, the following macros can be used to support this:
<P>
<DL COMPACT>

<DT><CODE>YY_LABEL_VARS</CODE>
<DD>If this macro is defined, then the compiler allows access to the address of a
label. 


<DT><CODE>YY_LABEL_TYPEDEF(<VAR>type</VAR>)</CODE>
<DD>This macro should expand to a <CODE>typedef</CODE> used to define the <VAR>type</VAR>
used to represent the address of a code label.  For <CODE>gcc</CODE>, the default
definition is:

<PRE>
#ifndef YY_LABEL_TYPEDEF /* How compiler declares vars containing labels. */
#define YY_LABEL_TYPEDEF(type)	typedef void *type
#endif
</PRE>

<DT><CODE>YY_LABEL_ADDR(<VAR>label</VAR>)</CODE>
<DD>This macro should expand to the address of <VAR>label</VAR>.  For <CODE>gcc</CODE>, the
default definition is:

<PRE>
#ifndef YY_LABEL_ADDR	/* How compiler takes the address of a label. */
#define YY_LABEL_ADDR(label)	&#38;&#38;label
#endif
</PRE>


</DL>
<P>
<H3><A NAME="SEC135" HREF="zlex_toc.html#SEC135">Table Scanner Options</A></H3>
<P>
Zlex supports 3 options which control the details of the table compression
algorithm used and 3 options which control the type of table entries.  This
leads to a total of 9 different kinds of table accesses.
<P>
The options are the following:
<P>
<DL COMPACT>

<DT><CODE>--compress <VAR>compression_algorithm</VAR></CODE>
<DD>This option controls the table compression algorithm used.  The permissible
values for <VAR>compression_algorithm</VAR> are shown below ordered from the
least compressed and fastest, to the most compressed and slowest:

<DL COMPACT>

<DT><CODE>none</CODE>
<DD>No table compression is used. 

<DT><CODE>comb</CODE>
<DD>A comb-compression algorithm is used to compress the tables.

<DT><CODE>iterative</CODE>
<DD>A iterative comb-compression algorithm is used to compress the tables. 

</DL>

<DT><CODE>--table <VAR>entry_type</VAR></CODE>
<DD>This option controls the type of table entries.  The permissible values for
<VAR>entry_type</VAR> are shown below ordered from the most memory intensive but
fastest, to the least memory intensive and slowest:

<DL COMPACT>

<DT><CODE>address</CODE>
<DD>Each Table entry contain pre-computed addresses.  This avoids computing the
addresses at runtime.

<DT><CODE>difference</CODE>
<DD>Each table entry contain the difference between the first entry
for the current state in the table and the first entry of the successor
state in the table.

<DT><CODE>state</CODE>
<DD>Each table entry directly contains the number of the successor state.

</DL>

<DT><CODE>--col-waste-percent <VAR>percent</VAR></CODE>
<DD>When <CODE>--compress=no</CODE> and <CODE>--table=state</CODE>, use a 2-dimensional
table with the # of columns a power of 2 if the percentage of wasted columns
is &#60;= <VAR>percent</VAR>. The default value is 50%.

<DT><CODE>--align[=1|0]</CODE>
<DD><DT><CODE>-a[1|0]</CODE>
<DD>By default, Zlex generated scanners do not explicitly specify the types for
various integral quantities.  Instead, Zlex sets up the generated scanner so
that when it is compiled, the compiler automatically chooses the smallest
integral type which can accomodate all possible values in the range of the
quantity.  This approach has the advantage that generated scanners are
conservative in their use of memory, as well as allowing a Zlex scanner to
be generated on one machine, while being compiled and executed on another
machine.  Unfortunately, such an approach can cause performance problems on
some architectures which may perform suboptimally on smaller integral types.
This option allows the programmer to force the types for all integral
quantities to be <CODE>int</CODE>.

</DL>
<P>
<H3><A NAME="SEC136" HREF="zlex_toc.html#SEC136">Miscellaneous Options</A></H3>
<P>
This section describes miscellaneous Zlex options including options to print
out generated scanner statistics and options to turn on runtime tracing in
the generated scanner.
<P>
<DL COMPACT>

<DT><CODE>--debug[=1|0]</CODE>
<DD><DT><CODE>-d[1|0]</CODE>
<DD>Turn on debugging in the generated scanner.  A similar effect can be
obtained by defining <CODE>YYDEBUG</CODE> or <CODE>YY_ZL_DEBUG</CODE> when compiling the
scanner (see section <A HREF="zlex.html#SEC119">Debugging and Errors</A>).

<DT><CODE>--help</CODE>
<DD><DT><CODE>-h</CODE>
<DD>Print out a help message giving a brief description of all the options, as
well as a description of Zlex's current environment.

<DT><CODE>--lex-compat</CODE>
<DD><DT><CODE>-l</CODE>
<DD>Maximize lex compatibility (equivalent to <CODE>--array</CODE> <CODE>--yylineno</CODE>
<CODE>--reject</CODE>).  Also if no <VAR>lex-file</VAR>s are specified on the
command-line, then read the zlex source file from the standard input.

<DT><CODE>--line-dir</CODE>
<DD>Output <CODE>#line</CODE> directives to the generated scanner (default).

<DT><CODE>--output <VAR>filename</VAR></CODE>
<DD><DT><CODE>-o <VAR>filename</VAR></CODE>
<DD>The generated scaner is written to <VAR>filename</VAR>.  By default, the name of
the generated scanner is <TT>`lex.yy.c'</TT>.

<DT><CODE>--to-stdout[=1|0]</CODE>
<DD><DT><CODE>-t[1|0]</CODE>
<DD>Write the generated scanner to stdout, as opposed to the default action of
writing it to a file <TT>`lex.yy.c'</TT>.

<DT><CODE>--trace[=<VAR>trace_file</VAR>]</CODE>
<DD>Run Zlex in trace mode, generating extensive output. This option is used
mainly for maintaining Zlex.  To use this option it is necessary that the C
preprocessor symbol <CODE>DO_TRACE</CODE> is defined when Zlex is built.  If
<VAR>trace_file</VAR> is omitted, then the trace is produced in a file whose name
is the basename of the first source file with its extension <SAMP>`.l'</SAMP> (if any)
removed and extension <SAMP>`.trc'</SAMP> added.

<DT><CODE>--verbose[=1|0]</CODE>
<DD><DT><CODE>-v[1|0]</CODE>
<DD>Generate somewhat verbose statistics describing DFA on stdout. No statistics
are generated by default.

<DT><CODE>--version</CODE>
<DD><DT><CODE>-V</CODE>
<DD>Print the currrent version number of Zlex and exit.

<DT><CODE>--whitespace</CODE>
<DD><DT><CODE>-w</CODE>
<DD>Allow whitespace within lex patterns (see section <A HREF="zlex.html#SEC58">Whitespace Within Patterns</A>).


</DL>
<P>
<H3><A NAME="SEC137" HREF="zlex_toc.html#SEC137">Alphabetical Listing of all Options</A></H3>
<P>
This section contains a short description of all options, sorted by long option
name.  Each option contains a reference to the section where it is discussed
in more detail.
<P>
<DL COMPACT>

<DT><CODE>--16-bit</CODE>
<DD>Generate a unicode-ready scanner which handles 16-bit characters.
See section <A HREF="zlex.html#SEC132">Runtime Input Options</A>.

<DT><CODE>--7-bit</CODE>
<DD><DT><CODE>-7</CODE>
<DD>Generate a scanner which handles only 7-bit characters.
See section <A HREF="zlex.html#SEC132">Runtime Input Options</A>.

<DT><CODE>--8-bit</CODE>
<DD><DT><CODE>-8</CODE>
<DD>Generate a scanner which handles 8-bit characters (default).
See section <A HREF="zlex.html#SEC132">Runtime Input Options</A>.

<DT><CODE>--align[=1|0]</CODE>
<DD><DT><CODE>-a[1|0]</CODE>
<DD>Generate a scanner which does not use short integer tables 
(default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC135">Table Scanner Options</A>.

<DT><CODE>--array[=1|0]</CODE>
<DD>Implement yytext as an array (default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC133">Runtime Algorithm Options</A>.

<DT><CODE>--backup-optimize[=1|0]</CODE>
<DD>Optimize the scanner for patterns which require it to backup 
(default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC133">Runtime Algorithm Options</A>.

<DT><CODE>-c</CODE>
<DD>Deprecated option included for POSIX compliance.

<DT><CODE>--bin-code-param <VAR>n</VAR></CODE>
<DD>Binary search in code-scanner if # input ranges &#60;= <VAR>n</VAR> 
(default: <CODE>16</CODE>).
See section <A HREF="zlex.html#SEC134">Code Scanner Options</A>.

<DT><CODE>--code-scan[=1|0]</CODE>
<DD>Generated scanner encodes DFA in code instead of tables 
(default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC134">Code Scanner Options</A>.

<DT><CODE>--compress <VAR>type</VAR></CODE>
<DD><DT><CODE>-C <VAR>type</VAR></CODE>
<DD>Use table compression of <VAR>type</VAR> <CODE>no</CODE>, <CODE>comb</CODE> or 
<CODE>iterative</CODE> (default: <CODE>comb</CODE>).
See section <A HREF="zlex.html#SEC135">Table Scanner Options</A>.

<DT><CODE>--col-waste-percent <VAR>percent</VAR></CODE>
<DD>When --compress=none &#38; --table=state, use a 2-dimensional table with
the # of columns a power of 2 if the percentage of wasted columns is &#60;= 
<VAR>percent</VAR> (<CODE>0</CODE> &#60;= <VAR>percent</VAR> and <VAR>percent</VAR> &#60;= 100) 
(default: <CODE>50</CODE>).
See section <A HREF="zlex.html#SEC135">Table Scanner Options</A>.

<DT><CODE>--debug[=1|0]</CODE>
<DD><DT><CODE>-d[1|0]</CODE>
<DD>Turn on debugging in generated scanner (default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC136">Miscellaneous Options</A>.

<DT><CODE>--default-action <VAR>act</VAR></CODE>
<DD><DT><CODE>-s <VAR>act</VAR></CODE>
<DD>Set default action for unmatched character to <VAR>act</VAR> <CODE>echo</CODE>, 
<CODE>error</CODE>, <CODE>fatal</CODE> or <CODE>ignore</CODE> 
(default: <CODE>echo</CODE>).
See section <A HREF="zlex.html#SEC133">Runtime Algorithm Options</A>.

<DT><CODE>--ecs[=1|0]</CODE>
<DD><DT><CODE>-E[1|0]</CODE>
<DD><DT><CODE>--equiv-classes[=1|0]</CODE>
<DD>Partition input characters into equivalence classes 
(default: <CODE>1</CODE>).
See section <A HREF="zlex.html#SEC133">Runtime Algorithm Options</A>.

<DT><CODE>--help</CODE>
<DD><DT><CODE>-h</CODE>
<DD>Print summary of options and exit.
See section <A HREF="zlex.html#SEC136">Miscellaneous Options</A>.

<DT><CODE>--ignore-case[=1|0]</CODE>
<DD><DT><CODE>-i[1|0]</CODE>
<DD><DT><CODE>--caseless[=1|0]</CODE>
<DD><DT><CODE>--case-insensitive[=1|0]</CODE>
<DD>Generate a case insensitive scanner (default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC132">Runtime Input Options</A>.

<DT><CODE>--lex-compat</CODE>
<DD><DT><CODE>-l</CODE>
<DD>Lex compatibility (equivalent to --array --yylineno --reject).
See section <A HREF="zlex.html#SEC136">Miscellaneous Options</A>.

<DT><CODE>--lin-code-param <VAR>n</VAR></CODE>
<DD>Linear search in code-scanner if # successors &#60;= <VAR>n</VAR> 
(default: <CODE>4</CODE>).
See section <A HREF="zlex.html#SEC134">Code Scanner Options</A>.

<DT><CODE>--line-dir[=1|0]</CODE>
<DD>Output #line directives to generated scanner (default: <CODE>1</CODE>).
See section <A HREF="zlex.html#SEC136">Miscellaneous Options</A>.

<DT><CODE>-n</CODE>
<DD>Deprecated option included for POSIX compliance.

<DT><CODE>--output <VAR>filename</VAR></CODE>
<DD><DT><CODE>-o <VAR>filename</VAR></CODE>
<DD>Generate scanner in file <VAR>filename</VAR> (default: <CODE>lex.yy.c</CODE>).
See section <A HREF="zlex.html#SEC136">Miscellaneous Options</A>.

<DT><CODE>--prefix <VAR>prefix</VAR></CODE>
<DD><DT><CODE>-P <VAR>prefix</VAR></CODE>
<DD>Use <VAR>prefix</VAR> as prefix of certain global names in
generated scanner 
(default: <CODE>yy</CODE>).
See section <A HREF="zlex.html#SEC133">Runtime Algorithm Options</A>.

<DT><CODE>--sentinel <VAR>char-code</VAR></CODE>
<DD><DT><CODE>-S <VAR>char-code</VAR></CODE>
<DD>Use character with decimal code <VAR>char-code</VAR> as sentinel 
(default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC132">Runtime Input Options</A>.

<DT><CODE>--reject[=1|0]</CODE>
<DD>Allow REJECT actions in generated scanner (default: <CODE>1</CODE>).
See section <A HREF="zlex.html#SEC133">Runtime Algorithm Options</A>.

<DT><CODE>--stdio[=1|0]</CODE>
<DD>Use standard I/O for all scanner input (default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC132">Runtime Input Options</A>.

<DT><CODE>--table <VAR>type</VAR></CODE>
<DD><DT><CODE>-T <VAR>type</VAR></CODE>
<DD>Use table entries of <VAR>type</VAR> <CODE>address</CODE>, 
<CODE>difference</CODE> or <CODE>state</CODE> (default: <CODE>state</CODE>).
See section <A HREF="zlex.html#SEC135">Table Scanner Options</A>.

<DT><CODE>--to-stdout[=1|0]</CODE>
<DD><DT><CODE>-t[1|0]</CODE>
<DD>Write generated scanner to stdout (default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC136">Miscellaneous Options</A>.

<DT><CODE>--trace[=<VAR>trace_file</VAR>]</CODE>
<DD><DT><CODE>-T[<VAR>trace_file</VAR>]</CODE>
<DD>Run zlex in trace mode, generating extensive output in file 
<VAR>trace_file</VAR> which defaults to stdout.
See section <A HREF="zlex.html#SEC136">Miscellaneous Options</A>.

<DT><CODE>--transition-compress[=1|0]</CODE>
<DD>Compress transitions for non-switch states in code scanner 
(default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC134">Code Scanner Options</A>.

<DT><CODE>--verbose[=1|0]</CODE>
<DD><DT><CODE>-v[1|0]</CODE>
<DD>Generate somewhat verbose statistics describing DFA 
(default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC136">Miscellaneous Options</A>.

<DT><CODE>--version</CODE>
<DD><DT><CODE>-V</CODE>
<DD>Print version number and exit.
See section <A HREF="zlex.html#SEC136">Miscellaneous Options</A>.

<DT><CODE>--whitespace[=1|0]</CODE>
<DD><DT><CODE>-w[1|0]</CODE>
<DD>Allow whitespace within lex patterns (default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC136">Miscellaneous Options</A>.

<DT><CODE>--yylineno[=1|0]</CODE>
<DD>Maintain count of line number in global variable yylineno 
(default: <CODE>0</CODE>).
See section <A HREF="zlex.html#SEC133">Runtime Algorithm Options</A>.


</DL>
<P>
<H2><A NAME="SEC138" HREF="zlex_toc.html#SEC138">Data Search List</A></H2>
<P>
When Zlex is run, it looks for certain data files (a skeleton file
<TT>`zlexskl.c'</TT> and an options file <TT>`zlex.opt'</TT> (see section <A HREF="zlex.html#SEC130">Option Sources</A>)) in certain standard directories (the skeleton file <EM>must</EM>
exist, but the option file need not exist).  The search list specifying
these standard directories is fixed when Zlex is installed; it can be
printed out using Zlex's the <SAMP>`--help'</SAMP> option (see section <A HREF="zlex.html#SEC137">Alphabetical Listing of all Options</A>).
<P>
The search list consists of a list of colon-separated directory names (the
directory names may or may not have terminating slashes) or environment
variables (starting with a <SAMP>`$'</SAMP>).  If a directory name starts with a
<SAMP>`$'</SAMP>, then the first (only the first) <SAMP>`$'</SAMP> must be repeated.  An
empty component in the search list specifies the current directory.
Typically the search list contains the current directory.  
Also typically, the environment variable <CODE>ZLEX_SEARCH_PATH</CODE> is present
in the search list -- this causes Zlex to check if the variable is set in
the environment.  If it is, then Zlex expects it to specify a search list
which it recursively searches.
<P>
Typically, the search list compiled into Zlex looks something like the
following:
<P>
<PRE>
$ZLEX_SEARCH_PATH:.:$HOME:/usr/local/share/zlex-<VAR>Version</VAR>
</PRE>
<P>
Since the search list will typically contain an environment variable like
<CODE>ZLEX_SEARCH_PATH</CODE> it is possible to change the set of standard
directories searched by Zlex even after installation by specifying a 
value for the variable.  For example, if with the above search list,
<CODE>ZLEX_SEARCH_PATH</CODE> is set to <CODE>/usr/lib:/usr/opt/lib</CODE>, then 
the effective search list becomes:
<P>
<PRE>
/usr/lib:/usr/opt/lib:.:$HOME:/usr/local/share/zlex-<VAR>Version</VAR>
</PRE>
<P>
<H1><A NAME="SEC139" HREF="zlex_toc.html#SEC139">Efficiency</A></H1>
<P>
To produce a high performance scanner, the Zlex programmer needs to
understand the performance tradeoffs between different Zlex features.
<P>
<H2><A NAME="SEC140" HREF="zlex_toc.html#SEC140">Patterns versus Actions</A></H2>
<P>
The primary consideration used when designing Zlex was to maximize the
performance in the basic task of a scanner: recognizing tokens.  The
performance of special actions was a secondary consideration, except that
the presence of such actions was not allowed to impact the
performance of those parts of the scanner which did not depend on them.
<P>
These design decisions make it desirable for the Zlex programmer to use
patterns rather than actions whenever possible.  Many of the actions involve
a function call with its consequent overhead.  For example, it is
preferable to process comments using start states (see section <A HREF="zlex.html#SEC72">Start States Example: C comments</A>), rather than processing them using <CODE>input</CODE> (see section <A HREF="zlex.html#SEC76">Direct Input: <CODE>input</CODE></A>). 
<P>
<H2><A NAME="SEC141" HREF="zlex_toc.html#SEC141">Maximizing Token Length</A></H2>
<P>
There is some overhead involved in setting up for scanning a token and
completing a token.  To minimize this overhead, it is preferable to maximize
the token length.  For example, when scanning through a comment
(see section <A HREF="zlex.html#SEC72">Start States Example: C comments</A>), it is preferable to process the comment a
line at a time, rather than a single character at a time.
<P>
<H2><A NAME="SEC142" HREF="zlex_toc.html#SEC142">Backtracking</A></H2>
<P>
Backtracking (both that caused during scanning due to overlapping patterns,
and that forced by explicit <CODE>REJECT</CODE>s) will naturally lead to somewhat
lower performance because characters will be scanned multiple times.  The
backtracking performance of Zlex is reasonably good and backtracking can be
used moderately within a scanner without impacting the overall performance
terribly.
<P>
<H2><A NAME="SEC143" HREF="zlex_toc.html#SEC143">Generalized Right Context Efficiency</A></H2>
<P>
In a generalized right context pattern of the form
<CODE><VAR>RE</VAR>/<VAR>context</VAR></CODE> the efficiency of the pattern matching depends
on the form of <VAR>RE</VAR> and <VAR>context</VAR>.  If the length of the string
which matches <VAR>RE</VAR> is <VAR>m</VAR>, and the length of the string matching
<VAR>context</VAR> is <VAR>n</VAR> then:
<P>
<UL>
<LI>
If either <VAR>RE</VAR> or <VAR>context</VAR> match only tokens of a fixed length,
then the total number of characters scanned will be <CODE><VAR>m</VAR> +
<VAR>n</VAR></CODE>.

<LI>
It neither <VAR>RE</VAR> or <VAR>context</VAR> match only tokens of a fixed length,
and there is no overlap between the end of tokens which match <VAR>RE</VAR> and
the beginning of tokens which match <VAR>context</VAR>, then the total number of
characters scanned will be <CODE>2 * (<VAR>m</VAR> + <VAR>n</VAR>)</CODE>.

<LI>
It neither <VAR>RE</VAR> or <VAR>context</VAR> match only tokens of a fixed length,
and there is overlap between the end of tokens which match <VAR>RE</VAR> and the
beginning of tokens which match <VAR>context</VAR>, then in the worst-case, the
total number of characters scanned can be quadratic in the length of the
strings.  
</UL>
<P>
Hence generalized right context with the context overlapping the regular
expression should be avoided if possible.
<P>
<H1><A NAME="SEC144" HREF="zlex_toc.html#SEC144">Distributing Zlex Scanners</A></H1>
<P>
When a program is completed and is ready for distribution, there are two
common distribution models used:
<P>
<DL COMPACT>
<DT>Binary Distribution
<DD>This is the model usually used for commercial software.  In that case, the
compiled Zlex generated scanner along with some of the compiled code from
the Zlex library will form part of the distributed executable.

<DT>Source Distribution
<DD>This is the usual model used for non-commercial software and is the
preferred model.  In that case, the distribution will need to include the
generated scanner file as well as some of the sources from the Zlex library.
</DL>
<P>
<H2><A NAME="SEC145" HREF="zlex_toc.html#SEC145">Distributing Zlex Library Sources</A></H2>
<A NAME="IDX219">.</A>
<A NAME="IDX220">.</A>
<P>
There are two possibilities for distributing the Zlex library sources:
<P>
<OL>
<LI>
Distribute the complete Zlex library.  In that case, the main
<TT>`Makefile'</TT> will need to be setup to compile the entire Zlex library and
link it into the final executable.

<LI>
Distribute only that part of the library which is really required by the
generated scanner.
</OL>
<P>
(1) is conceptually straightforward.  (2) is also straightforward, except
for figuring out which parts of the Zlex library are required by the
generated scanner.  Fortunately, the Zlex distribution comes with a shell
script which automates that task.
<A NAME="IDX221">.</A>
<P>
The script understands the interdependencies of the modules which constitute
the Zlex library.  When it is run, it analyzes the object file for the
generated scanner and produces a C file which contains all the source code
which will be required by the generated scanner.  The distribution should
include this C file as well as the file <TT>`libZlexp.h'</TT> which will be
found in the Zlex library source directory.
<A NAME="IDX222">.</A>
<P>
The script is called <CODE>mklibsrc</CODE>; it usually resides in the Zlex library
source directory.  It can be invoked as:
<P>
<PRE>
<VAR>SCRIPT_PATH</VAR>/mklibsrc <VAR>OFILE</VAR> [<VAR>LIB_SRC_DIR</VAR>] [<VAR>DEST_FILE</VAR>]
</PRE>
<P>
where the parameters are defined as follows:
<DL COMPACT>

<DT><VAR>SCRIPT_PATH</VAR>
<DD>The path to the <CODE>mklibsrc</CODE> script. 

<DT><VAR>OFILE</VAR>
<DD>The name of the object file for the generated scanner. 

<DT><VAR>LIB_SRC_DIR</VAR>
<DD>The directory where the Zlex library sources reside -- it defaults to
<VAR>SCRIPT_PATH</VAR>.  

<DT><VAR>DEST_FILE</VAR>
<DD>The name of the C file which should contain the generated sources -- it
defaults to <TT>`libsrc.c'</TT>.

</DL>
<P>
For example, if we assume that the environmental variable <CODE>ZLEX_LIB_SRC</CODE>
contains the path to the Zlex library source directory, then the invocation:
<P>
<PRE>
$ZLEX_LIB_SRC/mklibsrc scan.o
</PRE>
<P>
will produce a file <TT>`libsrc.c'</TT> which contains all the source code
required from the Zlex library for the scanner object file <TT>`scan.o'</TT>.
<P>
It is unlikely but possible that the generated scanner can be compiled with
different options which affect which routines will be required from the Zlex
library.  In that case, it is necessary to repeat the above procedure for
each scanner object file produced using the different options.  The script
will accumulate the code in the specified C file.
<P>
The <CODE>mklibsrc</CODE> script is automatically generated by <CODE>m4</CODE> using a
skeletal script.  The interdependencies among the library modules are
automatically extracted using a <CODE>Perl</CODE> script.  The main portability
problem within the <CODE>mklibsrc</CODE> script is likely to be the command
<SAMP>`nm -u'</SAMP> which is used to analyze the scanner object file.
<P>
<H1><A NAME="SEC146" HREF="zlex_toc.html#SEC146">Bugs and Deficiencies</A></H1>
<P>
Internal versions of the Zlex scanner generator have been used by me since
late 1993.  In 1996, it was used by about 20 students in a compiler course:
they uncoverd 2 bugs.  There has been a major rewrite since then.
<P>
<H2><A NAME="SEC147" HREF="zlex_toc.html#SEC147">Suspicions</A></H2>
Normally, when a program has been completed, one has a reasonable idea where
bugs might still lurk.  On that basis, for what they are worth, I present my
current suspicions:
<P>
<DL COMPACT>
<DT>The Scanner Generator
<DD>I feel fairly good about the code which actually generates scanners.  Under
normal error-free operation, the weakest area may be the code which
compresses the scanner tables.  However, the bugs most likely to manifest
themselves will probably be <CODE>assert</CODE>ion failures caused by an erroneous
Zlex source file.  In that case, the Zlex programmer can simply correct the
error in the Zlex source file and continue on with reasonable confidence
(after submitting a bug report of course).

<DT>The Runtime System
<DD>Unfortunately the runtime system (the generated scanner along with the Zlex
library) is rather complex.  Because of the need for backward compatibility,
it has many poorly integrated features.  Bugs probably lurk within the
complexity and in the interactions among the features.

</DL>
<P>
<H2><A NAME="SEC148" HREF="zlex_toc.html#SEC148">Bug Reports</A></H2>
<P>
First you will need to be sure that you have found a Zlex bug:
<P>
<UL>

<LI>
If when running the Zlex scanner generator, it bombs with a assertion
failure or a core dump, you can be sure that you have uncovered a bug.

<LI>
If when running a Zlex generated scanner, it bombs or does not do what you
intended it to do, it is much more difficult to be sure whether the problem
is within the Zlex runtime system or in your code.  If it bombs within a
Zlex library routine, make sure that you called it with the proper
parameters.  If it bombs within the main scanner function, make sure that it
is not within your actions.

</UL>
<P>
If you are sure that you have uncovered a bug, try to distil it down to a
test program which is as short as possible while still exhibiting the bug.
Record a log which exhibits the bug.  Make sure that you mention the version
of Zlex you are using in your bug report.
<P>
Bug reports can be mailed to:
<P>
<PRE>
zdu@acm.org
</PRE>
<P>
<H1><A NAME="SEC149" HREF="zlex_toc.html#SEC149">Syntax of Zlex Programs</A></H1>
<P>
An informal description of the lexical and grammatical syntax of
Zlex programs follows:
<P>
<H2><A NAME="SEC150" HREF="zlex_toc.html#SEC150">Tokens</A></H2>
<P>
This is an informal description of the lexical syntax of non-trivial
Zlex tokens.
<P>
<DL COMPACT>
<DT><CODE>ACT_TOK</CODE>
<DD>A sequence of actions including C-brace actions, decorated brace actions,
indented actions, or a newline after a section 2 pattern.

<DT><CODE>CHAR_TOK</CODE>
<DD>A character which is not a lex meta-character within its current context.

<DT><CODE>COLON_BEGIN_TOK</CODE>
<DD><CODE>"[:"</CODE>.

<DT><CODE>COLON_END_TOK</CODE>
<DD><CODE>":]"</CODE>.

<DT><CODE>EOF_PAT_TOK</CODE>
<DD><CODE>"&#60;&#60;EOF&#62;&#62;"</CODE>.

<DT><CODE>ID_TOK</CODE>
<DD>An identifier.

<DT><CODE>LEX_DIR_TOK</CODE>
<DD>A lex directive at the start of a line in section 1.

<DT><CODE>MACRO_TOK</CODE>
<DD>A macro call within braces.

<DT><CODE>NEXT_ACT_TOK</CODE>
<DD><SAMP>`|'</SAMP> action (which is not part of a pattern).

<DT><CODE>NL_TOK</CODE>
<DD>A newline which terminates an option line.

<DT><CODE>NUM_TOK</CODE>
<DD>A number which occurs within braces as a repetition count.

<DT><CODE>OPTION_LINE_TOK</CODE>
<DD>The rest of the line after a <CODE>%option</CODE>.

<DT><CODE>OPTION_TOK</CODE>
<DD><CODE>^"%option"</CODE>.

<DT><CODE>SEC_TOK</CODE>
<DD><CODE>^"%%"</CODE>.

<DT><CODE>SS_ID_TOK</CODE>
<DD>An identifier which is used as a start-state name.

<DT><CODE>STARTX_TOK</CODE>
<DD><CODE>^"%"[xX]</CODE> signalling the start of an exclusive start state declaration.

<DT><CODE>START_TOK</CODE>
<DD><CODE>^"%"[sS]</CODE> signalling the start of an inclusive start state declaration.

<DT><CODE>X_OPTION_TOK</CODE>
<DD><CODE>^("%array" | "%pointer")</CODE>.
</DL>
<P>
<H2><A NAME="SEC151" HREF="zlex_toc.html#SEC151">Grammar</A></H2>
This is a grammar for Zlex programs using a yacc-like notation.  This
grammar is a slightly massaged version of one extracted automatically from
the current implementation of Zlex.
<P>
<PRE>
lexProgram
  : section1 SEC_TOK section2 
  ;
section1
  : options restSection1 
  | options 
  ;
options
  : nonEmptyOptions 
  | /* EMPTY */
  ;
nonEmptyOptions
  : optionLine 
  | nonEmptyOptions optionLine 
  ;
optionLine
  : OPTION_TOK OPTION_LINE_TOK NL_TOK 
  | X_OPTION_TOK NL_TOK 
  ;
restSection1
  : section1Line 
  | restSection1 section1Line 
  ;
section1Line
  : startDec 
  | def 
  | LEX_DIR_TOK OPTION_LINE_TOK NL_TOK 
  ;
startDec
  : START_TOK ssDefList 
  | STARTX_TOK ssDefList 
  ;
ssDefList
  : ssDefList SS_ID_TOK 
  | /* EMPTY */
  ;
def
  : ID_TOK regExp 
  | ID_TOK 
  ;
section2
  : ACT_TOK sec2Patterns 
  ;
sec2Patterns
  : sec2Patterns actPatterns 
  | /* EMPTY */
  ;
actPatterns
  : patternActions
  | '+' regExp ACT_TOK 
  ;
patternActions
  : pattern ACT_TOK
  | pattern NEXT_ACT_TOK patternActions
  ;
pattern
  : optSSList regExp optRightContext
  | optSSList '^' regExp optRightContext
  | optSSList rightContext
  | optSSList '^' rightContext
  | optSSList EOF_PAT_TOK
  ;
optRightContext
  : rightContext 
  | /* EMPTY */
  ;
rightContext
  : '$' 
  | '/' regExp 
  ;
optSSList
  : /* EMPTY */
  | '&#60;' ssUseList '&#62;' 
  ;
ssUseList
  : ssUseList ',' SS_ID_TOK 
  | SS_ID_TOK 
  ;
regExp
  : regExp '|' catRegExp 
  | catRegExp 
  ;
catRegExp
  : catRegExp postRegExp 
  | postRegExp 
  ;
postRegExp
  : postRegExp '*' 
  | postRegExp '?' 
  | postRegExp '+' 
  | postRegExp numRange 
  | baseRegExp 
  ;
baseRegExp
  : '(' regExp ')' 
  | '.' 
  | CHAR_TOK 
  | MACRO_TOK 
  | '[' classElements ']' 
  | '[' '^' classElements ']' 
  ;
classElements
  : classElement 
  | classElements classElement 
  ;
classElement
  : CHAR_TOK 
  | CHAR_TOK '-' CHAR_TOK 
  | COLON_BEGIN_TOK ID_TOK COLON_END_TOK 
  ;
numRange
  : '{' NUM_TOK '}' 
  | '{' NUM_TOK ',' '}' 
  | '{' NUM_TOK ',' NUM_TOK '}' 
  ;
</PRE>
<P>
<H1><A NAME="SEC152" HREF="zlex_toc.html#SEC152">Copying Conditions</A></H1>
<P>
Zlex: A <CODE>lex</CODE>/<CODE>flex</CODE> compatible scanner generator.
<P>
Copyright (C) 1995 Zerksis D. Umrigar
<P>
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation with one ADDENDUM mentioned below; either
version 2 of the License, or (at your option) any later version.
     
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.
     
You should have received a copy of the GNU General Public License along
with this program in the file GPL included in the Zlex distribution; if
not, write to the Free Software Foundation, Inc., 675 Mass Ave,
Cambridge, MA 02139, USA.
<P>
The addendum to the GNU General Public License is as follows: Permission
is hereby given to use the output of Zlex in non-free programs.
<P>
The reason for the addendum is that the output of Zlex -- the generated
scanner file -- contains code chunks which are verbatim copies of
sizable sections of Zlex sources.  These chunks include the code for
parts of the `yylex' function, as well as code for Zlex library
functions.  If only the terms of the GPL were to be applied to the code
within the generated scanner file, the effect would be to restrict the
use of Zlex output to free software.  Hence this document amends the
terms of the GNU General Public License to explicitly allow the use of
the output of Zlex in non-free programs.
<P>
The addendum has not been added because of sympathy for people who want
to make software proprietary.  <EM>Software should be free.</EM>
Unfortunately, it appears that limiting Zlex's use to free software does
little to encourage people to make other software free.  So the addendum
makes the practical conditions for using Zlex match the practical
conditions for using other free tools.
<P>
Questions and comments regarding Zlex can be directed to me at
zdu@acm.org
<P>
The above conditions were derived from the copying conditions published
for <CODE>bison</CODE> by the Free Software Foundation, Inc.
<P>
<H1><A NAME="SEC153" HREF="zlex_toc.html#SEC153">Concept Index</A></H1>
<H2>$</H2>
<DIR>
<LI><A HREF="zlex.html#IDX63"><CODE>$</CODE> End of line anchor</A>
</DIR>
<H2>*</H2>
<DIR>
<LI><A HREF="zlex.html#IDX43"><CODE>*</CODE> operator</A>
</DIR>
<H2>+</H2>
<DIR>
<LI><A HREF="zlex.html#IDX47"><CODE>+</CODE> operator</A>
</DIR>
<H2>-</H2>
<DIR>
<LI><A HREF="zlex.html#IDX36"><CODE>-</CODE> character class operator</A>
</DIR>
<H2>.</H2>
<DIR>
<LI><A HREF="zlex.html#IDX38"><CODE>.</CODE> regular expression</A>
</DIR>
<H2>&#60;</H2>
<DIR>
<LI><A HREF="zlex.html#IDX37"><CODE>&#60;ctype.h&#62;</CODE> character class element</A>
</DIR>
<H2>?</H2>
<DIR>
<LI><A HREF="zlex.html#IDX41"><CODE>?</CODE> operator</A>
</DIR>
<H2>^</H2>
<DIR>
<LI><A HREF="zlex.html#IDX35"><CODE>^</CODE> character class operator</A>
<LI><A HREF="zlex.html#IDX66"><CODE>^</CODE> Start of line anchor</A>
</DIR>
<H2>a</H2>
<DIR>
<LI><A HREF="zlex.html#IDX57">Ada comments</A>
<LI><A HREF="zlex.html#IDX51">And regular expression</A>
</DIR>
<H2>b</H2>
<DIR>
<LI><A HREF="zlex.html#IDX7">Backtracking during scanning</A>
<LI><A HREF="zlex.html#IDX124">Backtracking, forcing</A>
<LI><A HREF="zlex.html#IDX86">Beginning a start state</A>
<LI><A HREF="zlex.html#IDX133">Beginning of line, controlling</A>
<LI><A HREF="zlex.html#IDX131">Beginning of line, querying</A>
<LI><A HREF="zlex.html#IDX143">Buffer handle</A>
<LI><A HREF="zlex.html#IDX174">Buffer switching</A>
<LI><A HREF="zlex.html#IDX150">Buffer, creating from a file</A>
<LI><A HREF="zlex.html#IDX166">Buffer, Creating from bytes</A>
<LI><A HREF="zlex.html#IDX162">Buffer, Creating from memory data</A>
<LI><A HREF="zlex.html#IDX170">Buffer, Creating from string</A>
<LI><A HREF="zlex.html#IDX146">Buffer, current</A>
<LI><A HREF="zlex.html#IDX154">Buffer, deleting a</A>
<LI><A HREF="zlex.html#IDX158">Buffer, flushing a</A>
<LI><A HREF="zlex.html#IDX142">Buffers</A>
<LI><A HREF="zlex.html#IDX179">Buffers example</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="zlex.html#IDX59">C comment, regular expression for</A>
<LI><A HREF="zlex.html#IDX105">C comments using start states</A>
<LI><A HREF="zlex.html#IDX34">Character classes</A>
<LI><A HREF="zlex.html#IDX128">Character count</A>
<LI><A HREF="zlex.html#IDX45">Closure</A>
<LI><A HREF="zlex.html#IDX9">Code block</A>
<LI><A HREF="zlex.html#IDX8">Comments</A>
<LI><A HREF="zlex.html#IDX50">Concatenation</A>
<LI><A HREF="zlex.html#IDX60">Context</A>
<LI><A HREF="zlex.html#IDX49">Counted repetition</A>
<LI><A HREF="zlex.html#IDX151">Creating a buffer from a file</A>
<LI><A HREF="zlex.html#IDX171">Creating a buffer from a string</A>
<LI><A HREF="zlex.html#IDX167">Creating a buffer from bytes</A>
<LI><A HREF="zlex.html#IDX163">Creating a buffer from memory data</A>
<LI><A HREF="zlex.html#IDX147">Current buffer</A>
<LI><A HREF="zlex.html#IDX90">Current start state</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="zlex.html#IDX210">Debugging</A>
<LI><A HREF="zlex.html#IDX199">Declaration of scanner function</A>
<LI><A HREF="zlex.html#IDX10">Declarations</A>
<LI><A HREF="zlex.html#IDX155">Deleting a buffer</A>
<LI><A HREF="zlex.html#IDX220">Distributing the library</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="zlex.html#IDX139">Echoing yytext</A>
<LI><A HREF="zlex.html#IDX184">End of file actions</A>
<LI><A HREF="zlex.html#IDX68">End of file patterns</A>
<LI><A HREF="zlex.html#IDX206">End of file return value</A>
<LI><A HREF="zlex.html#IDX62">End of line context</A>
<LI><A HREF="zlex.html#IDX31">Escape sequences</A>
<LI><A HREF="zlex.html#IDX81">Exclusive start state</A>
</DIR>
<H2>f</H2>
<DIR>
<LI><A HREF="zlex.html#IDX13">File name</A>
<LI><A HREF="zlex.html#IDX129">File position</A>
<LI><A HREF="zlex.html#IDX22">File scope</A>
<LI><A HREF="zlex.html#IDX159">Flushing a buffer</A>
<LI><A HREF="zlex.html#IDX123">Forced backtracking</A>
<LI><A HREF="zlex.html#IDX17">Function name conventions</A>
<LI><A HREF="zlex.html#IDX21">Function scope</A>
</DIR>
<H2>g</H2>
<DIR>
<LI><A HREF="zlex.html#IDX5">generated scanner file</A>
</DIR>
<H2>h</H2>
<DIR>
<LI><A HREF="zlex.html#IDX33">Hexadecimal codes</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="zlex.html#IDX178">Include file example</A>
<LI><A HREF="zlex.html#IDX82">Inclusive start state</A>
<LI><A HREF="zlex.html#IDX106">Inclusive start states, use of</A>
<LI><A HREF="zlex.html#IDX83">Initial start state</A>
<LI><A HREF="zlex.html#IDX201">Initialization</A>
<LI><A HREF="zlex.html#IDX110">Input</A>
<LI><A HREF="zlex.html#IDX107">Input <CODE>FILE</CODE></A>
<LI><A HREF="zlex.html#IDX117">Input, modifying the</A>
<LI><A HREF="zlex.html#IDX113">Input, redefining</A>
<LI><A HREF="zlex.html#IDX180">Intra-token pattern actions</A>
<LI><A HREF="zlex.html#IDX69">Intra-token patterns</A>
</DIR>
<H2>k</H2>
<DIR>
<LI><A HREF="zlex.html#IDX44">Kleene closure</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="zlex.html#IDX64">Left context</A>
<LI><A HREF="zlex.html#IDX76">Length of token</A>
<LI><A HREF="zlex.html#IDX6">lexeme</A>
<LI><A HREF="zlex.html#IDX219">Library Distribution</A>
<LI><A HREF="zlex.html#IDX14">Line directive</A>
<LI><A HREF="zlex.html#IDX11">Line number</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="zlex.html#IDX15">Macro name conventions</A>
<LI><A HREF="zlex.html#IDX40">Macros</A>
<LI><A HREF="zlex.html#IDX28">Meta-characters</A>
</DIR>
<H2>o</H2>
<DIR>
<LI><A HREF="zlex.html#IDX32">Octal codes</A>
<LI><A HREF="zlex.html#IDX48">One or more repetition</A>
<LI><A HREF="zlex.html#IDX42">Optional regular expression</A>
<LI><A HREF="zlex.html#IDX54">Or regular expression</A>
<LI><A HREF="zlex.html#IDX136">Output <CODE>FILE</CODE></A>
</DIR>
<H2>p</H2>
<DIR>
<LI><A HREF="zlex.html#IDX58">Pascal comments</A>
<LI><A HREF="zlex.html#IDX27">Patterns</A>
<LI><A HREF="zlex.html#IDX97">Popping a start state</A>
<LI><A HREF="zlex.html#IDX55">Precedence</A>
<LI><A HREF="zlex.html#IDX56">Precedence, overriding</A>
<LI><A HREF="zlex.html#IDX19">Private names</A>
<LI><A HREF="zlex.html#IDX23">Program scope</A>
<LI><A HREF="zlex.html#IDX93">Pushing a start state</A>
</DIR>
<H2>q</H2>
<DIR>
<LI><A HREF="zlex.html#IDX30">Quoting characters</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="zlex.html#IDX29">Regular expressions</A>
<LI><A HREF="zlex.html#IDX125">Rejecting to next match</A>
<LI><A HREF="zlex.html#IDX189">Restarting the scanner</A>
<LI><A HREF="zlex.html#IDX61">Right context</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="zlex.html#IDX1">Scanner definition</A>
<LI><A HREF="zlex.html#IDX198">Scanner function declaration</A>
<LI><A HREF="zlex.html#IDX2">Scanner generator</A>
<LI><A HREF="zlex.html#IDX190">Scanner restart</A>
<LI><A HREF="zlex.html#IDX24">Scanner state</A>
<LI><A HREF="zlex.html#IDX186">Scanner termination</A>
<LI><A HREF="zlex.html#IDX194">Scanning function</A>
<LI><A HREF="zlex.html#IDX20">Scope</A>
<LI><A HREF="zlex.html#IDX4">source file</A>
<LI><A HREF="zlex.html#IDX12">Source file name</A>
<LI><A HREF="zlex.html#IDX65">Start of line</A>
<LI><A HREF="zlex.html#IDX67">Start state patterns</A>
<LI><A HREF="zlex.html#IDX102">Start state stack, top</A>
<LI><A HREF="zlex.html#IDX98">Start state, popping</A>
<LI><A HREF="zlex.html#IDX94">Start state, pushing</A>
<LI><A HREF="zlex.html#IDX80">Start states</A>
<LI><A HREF="zlex.html#IDX89">Start states, current</A>
<LI><A HREF="zlex.html#IDX84">Start states, initial</A>
<LI><A HREF="zlex.html#IDX39">String quoting</A>
<LI><A HREF="zlex.html#IDX175">Switching buffers</A>
</DIR>
<H2>t</H2>
<DIR>
<LI><A HREF="zlex.html#IDX185">Terminating the scanner</A>
<LI><A HREF="zlex.html#IDX71">Text of token</A>
<LI><A HREF="zlex.html#IDX77">Token length</A>
<LI><A HREF="zlex.html#IDX72">Token text</A>
<LI><A HREF="zlex.html#IDX101">Top of the start state stack</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="zlex.html#IDX53">Union</A>
<LI><A HREF="zlex.html#IDX120">unput</A>
<LI><A HREF="zlex.html#IDX203">User action</A>
</DIR>
<H2>v</H2>
<DIR>
<LI><A HREF="zlex.html#IDX16">Variable name conventions</A>
</DIR>
<H2>w</H2>
<DIR>
<LI><A HREF="zlex.html#IDX70">Whitespace</A>
</DIR>
<H2>y</H2>
<DIR>
<LI><A HREF="zlex.html#IDX195"><CODE>yylex</CODE></A>
</DIR>
<H2>z</H2>
<DIR>
<LI><A HREF="zlex.html#IDX46">Zero or more repetitions</A>
<LI><A HREF="zlex.html#IDX3">Zlex source file</A>
</DIR>
<H2>|</H2>
<DIR>
<LI><A HREF="zlex.html#IDX52"><CODE>|</CODE> operator</A>
</DIR>
<P>
<H1><A NAME="SEC154" HREF="zlex_toc.html#SEC154">Index of Names Used in the Generated Scanner</A></H1>
<H2>b</H2>
<DIR>
<LI><A HREF="zlex.html#IDX87">BEGIN</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="zlex.html#IDX140">ECHO</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="zlex.html#IDX85">INITIAL</A>
<LI><A HREF="zlex.html#IDX111">input</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="zlex.html#IDX221">libZlexP.h</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="zlex.html#IDX18">main</A>
<LI><A HREF="zlex.html#IDX222">mkLibSrc</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="zlex.html#IDX126">REJECT</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="zlex.html#IDX121">unput</A>
</DIR>
<H2>y</H2>
<DIR>
<LI><A HREF="zlex.html#IDX208">yy_act</A>
<LI><A HREF="zlex.html#IDX132">YY_AT_BOL</A>
<LI><A HREF="zlex.html#IDX181">YY_BACKUP</A>
<LI><A HREF="zlex.html#IDX88">YY_BEGIN</A>
<LI><A HREF="zlex.html#IDX205">YY_BREAK</A>
<LI><A HREF="zlex.html#IDX144">YY_BUFFER_STATE</A>
<LI><A HREF="zlex.html#IDX169">YY_BYTES_BUFFER</A>
<LI><A HREF="zlex.html#IDX130">YY_CHAR_NUM</A>
<LI><A HREF="zlex.html#IDX153">YY_CREATE_BUFFER</A>
<LI><A HREF="zlex.html#IDX152">yy_create_buffer</A>
<LI><A HREF="zlex.html#IDX148">YY_CURRENT_BUFFER</A>
<LI><A HREF="zlex.html#IDX149">yy_current_buffer</A>
<LI><A HREF="zlex.html#IDX200">YY_DECL</A>
<LI><A HREF="zlex.html#IDX157">YY_DELETE_BUFFER</A>
<LI><A HREF="zlex.html#IDX156">yy_delete_buffer</A>
<LI><A HREF="zlex.html#IDX141">YY_ECHO</A>
<LI><A HREF="zlex.html#IDX115">YY_EOF_IN</A>
<LI><A HREF="zlex.html#IDX207">YY_EOF_OUT</A>
<LI><A HREF="zlex.html#IDX217">YY_ERR</A>
<LI><A HREF="zlex.html#IDX161">YY_FLUSH_BUFFER</A>
<LI><A HREF="zlex.html#IDX160">yy_flush_buffer</A>
<LI><A HREF="zlex.html#IDX112">YY_GET</A>
<LI><A HREF="zlex.html#IDX109">YY_IN</A>
<LI><A HREF="zlex.html#IDX114">YY_INPUT</A>
<LI><A HREF="zlex.html#IDX79">YY_LENG</A>
<LI><A HREF="zlex.html#IDX119">YY_LESS</A>
<LI><A HREF="zlex.html#IDX165">YY_MEM_BUFFER</A>
<LI><A HREF="zlex.html#IDX193">YY_NEW_FILE</A>
<LI><A HREF="zlex.html#IDX116">YY_NULL</A>
<LI><A HREF="zlex.html#IDX209">YY_NUM_RULES</A>
<LI><A HREF="zlex.html#IDX138">YY_OUT</A>
<LI><A HREF="zlex.html#IDX100">YY_POP_STATE</A>
<LI><A HREF="zlex.html#IDX99">yy_pop_state</A>
<LI><A HREF="zlex.html#IDX218">YY_PROGRAM_NAME</A>
<LI><A HREF="zlex.html#IDX96">YY_PUSH_STATE</A>
<LI><A HREF="zlex.html#IDX95">yy_push_state</A>
<LI><A HREF="zlex.html#IDX127">YY_REJECT</A>
<LI><A HREF="zlex.html#IDX192">YY_RESTART</A>
<LI><A HREF="zlex.html#IDX164">yy_scan_buffer</A>
<LI><A HREF="zlex.html#IDX168">yy_scan_bytes</A>
<LI><A HREF="zlex.html#IDX172">yy_scan_string</A>
<LI><A HREF="zlex.html#IDX134">yy_set_bol</A>
<LI><A HREF="zlex.html#IDX135">YY_SET_BOL</A>
<LI><A HREF="zlex.html#IDX91">YY_START</A>
<LI><A HREF="zlex.html#IDX173">YY_STRING_BUFFER</A>
<LI><A HREF="zlex.html#IDX176">yy_switch_to_buffer</A>
<LI><A HREF="zlex.html#IDX177">YY_SWITCH_TO_BUFFER</A>
<LI><A HREF="zlex.html#IDX188">YY_TERMINATE</A>
<LI><A HREF="zlex.html#IDX74">YY_TEXT</A>
<LI><A HREF="zlex.html#IDX104">YY_TOP_STATE</A>
<LI><A HREF="zlex.html#IDX103">yy_top_state</A>
<LI><A HREF="zlex.html#IDX122">YY_UNPUT</A>
<LI><A HREF="zlex.html#IDX204">YY_USER_ACTION</A>
<LI><A HREF="zlex.html#IDX202">YY_USER_INIT</A>
<LI><A HREF="zlex.html#IDX183">YY_WRAP</A>
<LI><A HREF="zlex.html#IDX212">YY_ZL_DEBUG</A>
<LI><A HREF="zlex.html#IDX213">yy_zlex_debug</A>
<LI><A HREF="zlex.html#IDX214">YY_ZLEX_DEBUG</A>
<LI><A HREF="zlex.html#IDX145">YYBufHandle</A>
<LI><A HREF="zlex.html#IDX26">YYDataHandle</A>
<LI><A HREF="zlex.html#IDX25">yydataP</A>
<LI><A HREF="zlex.html#IDX211">YYDEBUG</A>
<LI><A HREF="zlex.html#IDX216">yyerr</A>
<LI><A HREF="zlex.html#IDX108">yyin</A>
<LI><A HREF="zlex.html#IDX78">yyleng</A>
<LI><A HREF="zlex.html#IDX118">yyless</A>
<LI><A HREF="zlex.html#IDX197">yylex</A>
<LI><A HREF="zlex.html#IDX75">YYLMAX</A>
<LI><A HREF="zlex.html#IDX137">yyout</A>
<LI><A HREF="zlex.html#IDX191">yyrestart</A>
<LI><A HREF="zlex.html#IDX92">YYSTATE</A>
<LI><A HREF="zlex.html#IDX187">yyterminate</A>
<LI><A HREF="zlex.html#IDX73">yytext</A>
<LI><A HREF="zlex.html#IDX215">YYTRACE</A>
<LI><A HREF="zlex.html#IDX182">yywrap</A>
</DIR>
<P>
</BODY>
</HTML>
