\input texinfo  @c -*-texinfo-*-
@c %***start of header
@setfilename zlex.info
@settitle Zlex @value{edition}
@setchapternewpage on
@c %***end of header

@syncodeindex vr fn
@syncodeindex tp fn

@ifinfo
@node top, Introduction, (dir), (dir)
@comment  node-name,  next,  previous,  up
@top Zlex

This file documents Zlex, a scanner-generator which is largely-compatible
with both @code{lex} and @code{flex}.

Copyright @copyright{} 1995 Zerksis D. Umrigar

This is the first edition of the Zlex documentation.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

@end ifinfo

@set update-date 9 February 1997
@set update-month February 1997
@set version 1.02

@titlepage
@c Use the new format for titles.
@title Zlex
@subtitle A Scanner-Generator
for Zlex Version @value{version}.
@subtitle @value{update-month}

@author Zerksis D. Umrigar
@page
@vskip 0pt plus 1filll
@comment   Include the Distribution inside the titlepage so
@c that headings are turned off. 

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1995 Zerksis D. Umrigar

@sp 2

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.

@sp 2

@end titlepage  

@menu
* Introduction::                Introduction to Zlex.
* The Scanning Process::        How Zlex generated scanners work.
* Input File Structure::        Structure of the Zlex source file.
* C Interface Conventions::     Conventions used for interfacing to C.
* Patterns::                    Patterns describe lexical syntax.
* The Current Lexeme::          Accessing attributes of the current lexeme.
* Start States::                Incorporate left context into matching.
* Scanner Input::               Controlling and accessing the input. 
* Scanner Output::              Controlling the scanner's output.
* Buffer Management::           Input buffer control.
* Using Intra-Token Patterns::  Matching @emph{within} tokens.
* End-of-File and Termination::  Controlling scanner termination. 
* The Main Scanner Function::   Structure of the scanning function.
* Debugging::                   Debugging Zlex scanners.
* Multiple Scanners::           Multiple scanners in a single program. 
* Invoking Zlex::               Zlex options.
* Efficiency::                  Tips for writing efficient scanners.
* Distributing Zlex Scanners::  How to distribute generated scanners. 
* Bugs and Deficiencies::       Problems with Zlex.
* Syntax of Zlex Programs::     A semi-formal syntax description.
* Copying::                     Copying conditions for free software. 

* Concept Index::               
* Name Index::                  

 --- The Detailed Node Listing ---

Introduction

* Scanner Generator Overview::  Introduction and terminology.
* Background::                  Historical background and motivation.
* An Example::                  A word-counting application.
* Enhancements::                Enhancements over comparative programs. 

The Scanning Process

* Pattern Conflicts::           When multiple patterns match.
* Scanner Backtracking::        Backtracking over input characters.
* Default Action::              When no pattern matches the input.    

The Structure of the Zlex Input File

* Comments::                    Comments in a Zlex source file. 
* Code Blocks::                 Different ways of indicating code to be
                                copied into the generated scanner.  
* Declarations Section::        Section for Zlex and C declarations.  
* Rules Section::               Section for pattern-action rules.  
* Code Section::                Section for C code.  
* Line Directives::             Directives for setting the current line 
                                number and source file name.

C Interface Conventions

* Naming Conventions::          Conventions used in naming Zlex entities.
* Scope of Names::              Whether Zlex names have function, file
                                or program scope.
* Scanner State::               Passing the internal scanner state to
                                library routines.

Naming Conventions

* Macros Names::                Conventions used for macro names.
* Variable Names::              Conventions used for variable names.
* Function Names::              Conventions used for function names.
* Private Names::               Conventions used for private names.

Patterns

* Meta-Characters::             Special Zlex patterns characters. 
* Regular Expressions::         Expressions describing lexical syntax. 
* Context Operators::           Making matching sensitive to context. 
* End of File Patterns::        Patterns which match end-of-file.
* Intra-Token Patterns::        Patterns which can be triggered
                                @emph{within} a token.        
* Whitespace Within Patterns::  Rules for whitespace within patterns.

Regular Expressions

* Single Characters::           Characters which stand for themselves.
* Escape Sequences::            How to escape Zlex's meta-characters and
                                specify non-printing characters.
* Character Classes::           Specify a set of characters.
* Named Character Classes::     Specify a set of characters in a
                                portable way.
* Any Character Except Newline::  A meta-character which matches any 
                                character except a newline.  
* String Quoting::              How to quote characters using @samp{"}.
* Regular Expression Macros::   Using macros for regular expressions.
* Optional Regular Expression::  Specifying that a match of a regular
                                expression is optional. 
* Zero or More Repetitions::    Specifying that a regular expression may
                                be matched 0 or more times.
* One or More Repetitions::     Specifying that a regular expression may
                                be matched 1 or more times.
* Counted Repetition::          Specifying that a regular expression may
                                be a certain number of times.
* Concatenation::               Using juxtaposition to specify the 
                                concatenation of the matches of multiple
                                regular expressions.
* Union ::                      An operator which specifies the union of
                                two regular expressions.
* Operator Precedence::         The precedence of the different regular
                                expression operators.
* Grouping Regular Expression::  Using parentheses to override the
                                default precedence.                         
* Operator Independence::       Some operators can be defined in terms
                                of others.
* Regular Expression Examples::  Examples of regular expressions to
                                describe the syntax of comments in
                                various programming languages.

Regular Expression Examples

* Ada Comments::                Regular expression for Ada comments. 
* Pascal Comments::             Regular expression for Pascal comments. 
* C Comments::                  Regular expression for C comments. 

Context Operators

* Right Context::               Right-context-sensitive matching.
* Left Context::                Left-context-sensitive matching.

Right Context

* Generalized Right Context::   Using an arbitrary regular expression to
                                specify a right context.
* End of Line::                 Matching only at end-of-line.
* Right Context Restrictions::  No multiple right context in a pattern. 

Left Context

* Start of Line::               Matching only at start of a line.
* Start State Patterns::        Generalized left context matching.

Accessing the Current Lexeme

* Lexeme Text::                 Accessing the text of a lexeme.
* Lexeme Length::               Accessing the length of a lexeme.
* Catenating Tokens::           Concatenation of successive tokens. 

Start States

* Start State Types::           Two flavors of start states.
* Start State Declarations::    How to declare start states.
* Entering a Start State::      Zlex action to change start state. 
* Current Start State::         Accessing the current start state.
* Start State Stacks::          Stacking start states.
* Start States Example::        Start states to process C comments. 
* Using Inclusive Start States::  Tips on where inclusive start states 
                                maybe useful.

Start State Stacks

* Pushing a Start State::       
* Popping the Start State Stack::  
* Top of the Start State Stack::  

Input in a Zlex Scanner

* Input File Pointer::          @code{FILE} pointer to input stream. 
* Direct Input::                Reading directly from the input.
* Redefining the Input Macro::  Controlling how buffers are filled. 
* The Null Value::              
* Modifying Input::             Putting characters into the input. 
* Rejecting to the Next Match::  Rescanning via alternate patterns. 
* Character Count::             Character count in input stream.
* Current Line Number::         Line number in input stream.
* Current Column Number::       Column number in input stream.
* Querying Beginning of Line::  Check if at beginning of a line.
* Setting Beginning of Line::   Ensure at beginning of a line.

Modifying Characters in the Input Stream

* Rescanning Lexeme Text::      Pushing back scanned characters.
* Unput::                       Pushing back arbitrary characters.

Output in a Zlex Scanner

* Output File Pointer::         @code{FILE} pointer to output stream. 
* Echoing the Current Lexeme::  Echoing current token text.

Buffer Management

* Buffer Type::                 Opaque pointer for buffers.
* Current Buffer::              Accessing the current buffer.
* Creating a Buffer::           Creating a buffer for a file.
* Deleting a Buffer::           Deleting a previously created buffer. 
* Flushing a Buffer::           Flushing contents of a buffer.
* In Memory Buffer::            Create buffer using memory area.
* Bytes Buffer::                Create buffer from arbitrary bytes.
* String Buffer::               Create buffer from a C-style string. 
* Switching Buffers::           Switching between buffers.
* Buffer Management Example::   File inclusion using buffers.

Using Intra-Token Patterns

* Intra-Token Pattern Syntax::  How to specify intra-token patterns.
* Actions for Intra-Token Patterns::  Restrictions on actions within 
                                intra-token actions.
* Backing Up::                  A special intra-token action.

End-of-File and Termination

* Wrapping Up::                 Wrapping up a scanner run.
* End-of-file Actions::         Actions for @code{<<EOF>>} patterns. 
* Terminating a Scanner::       Terminating before end-of-file.
* Restarting a Scanner::        Restarting a scanner after termination. 

The Main Scanner Function

* Main Scanner Function::       Naming the main scanner function.
* Declaring the Scanner Function::  Declaring the main scanner
                                function. 
* Initialization::              Initialization within function.
* An Action for Every Pattern::  A pre-action for every pattern. 
* Separator Between Actions::   Controlling @code{break} within actions.
* Termination Return Value::    Value returned on termination.
* Pattern Numbers::             Accessing number of matched pattern.

Debugging and Errors

* Debugging Control::           A variable and macro which controls
                                debugging.
* Debugging Example::           Debugging example using @code{REJECT}. 
* Scanner Tracing::             Detailed trace of scanner actions.
* Errors::                      Runtime error message control.

Multiple Scanners

* Prefix Option::               Controlling prefix of names.
* Redefining Name Macros::      Giving an arbitrary name to a scanner 
                                object.
* Renaming Example::            Example which uses both methods.

Invoking Zlex

* Option Conventions::          
* Option Sources::              
* Options::                     
* Data Search List::            

Options

* Runtime Input Options::       
* Runtime Algorithm Options::   
* Code Scanner Options::        
* Table Scanner Options::       
* Miscellaneous Options::      
* Options List::                

Efficiency

* Patterns versus Actions::     Patterns preferred.
* Maximizing Token Length::     Match as much as possible at a time. 
* Backtracking::                Avoid backtracking.
* Generalized Right Context Efficiency::  Avoid possible quadratic
                                complexity. 

Distributing Zlex Scanners

* Distributing Library Sources::  How to package Zlex library sources. 

Bugs and Deficiencies

* Suspicions::                  Possible problem areas in Zlex.
* Bug Reports::                 How to report bugs.        

Syntax of Zlex Programs

* Tokens::                      Lexical syntax of Zlex tokens.
* Grammar::                     YACC grammar for Zlex.
@end menu

@node Introduction, The Scanning Process, top, top
@comment  node-name,  next,  previous,  up
@chapter Introduction

In order to introduce Zlex, the process of scanning is reviewed and some
terms are introduced.  Zlex is is compared with similar programs and the
motivation for the development of yet another scanner generator is
presented.  An example is used to illustrate the operation of Zlex.

@menu
* Scanner Generator Overview::  Introduction and terminology.
* Background::                  Historical background and motivation.
* An Example::                  A word-counting application.
* Enhancements::                Enhancements over comparative programs. 
@end menu

@node Scanner Generator Overview, Background, Introduction, Introduction
@section Scanner Generator Overview
Many programming applications require scanning a input stream and
partitioning it into a token stream, where tokens are typically identified
with non-overlapping subsequences of the input stream.  For example, a
natural-language interface will need to partition a stream of characters
into a stream of words, which constitute the tokens.  A compiler for a
programming language will need to partition the stream of characters
representing a program into a stream of literals, reserved words, operators
and identifiers which constitute the tokens of the programming language.

@cindex Scanner definition
A @dfn{scanner} is a program or portion of a program which performs the task
of partitioning a input stream into a token stream.  Writing a scanner is a
very common programming task: all applications which analyze some form of
text input will usually contain some kind of scanner (even though it may not
be identified as such).  Such scanners are usually written by hand,
typically in a procedural programming language like C or Pascal, where
knowledge about the syntax of tokens is intimately interwoven into
programming constructs which specify how to recognize those tokens. Even
though scanners are usually programs of relatively modest complexity,
maintaining non-trivial hand-written scanners can still be a demanding task.

@cindex Scanner generator
A @dfn{scanner-generator} is a program which is given a formal
specification of the syntax of tokens and automatically generates a
scanner from those specifications.  Since the specifications are largely
declarative in that they specify only @emph{what} constitutes a token
without specifying @emph{how} to recognize one, they are much easier to
maintain than hand-written scanners.  A pattern language based on
regular expressions is the formalization used to specify the syntax of
tokens for most scanner generators.  The efficiency of a
automatically-generated scanner can be comparable to that of a typical
hand-written scanner.


@xref{Patterns}.
@cindex Zlex source file
@cindex source file
@cindex generated scanner file
Zlex is such a scanner generator, automatically transforming a scanner
specification into a scanner program.  It accepts a scanner
specification given in a file referred to as the @dfn{Zlex source file}
and generates a C code file referred to as the @dfn{generated scanner
file}.  The Zlex source file contains (among other things) patterns
specifying the syntax of tokens.  For each pattern there is also a
corresponding action, consisting of arbitrary C code, which is to be
executed when the input matches the pattern.  These actions are copied
verbatim into the generated scanner.  The generated scanner file needs
to be compiled and linked with the rest of the program and with the Zlex
library to produce an executable program.

The generated scanner provides a function which is the @dfn{main scanner
function}.  Whenever this scanner function is called, it scans its input
stream looking for a match with any of the specified patterns.  If it finds
such a match, it executes the action corresponding to the pattern.  If the
action terminates in a return, it returns to its caller; otherwise it
continues scanning the input looking for the next match.  If no pattern
matches the current input character, then the scanner executes a predefined
action which defaults to merely echoing the unmatched character to the
standard output.

@cindex lexeme
Once the generated scanner has recognized a token, it is typically
transformed into a small integer for processing by the rest of the
program.  A token typically has at least one attribute: its @dfn{lexeme}
which is the actual subsequence of the input-stream corresponding to
that token.  The generated scanner allows its actions to access the
lexeme for the current token.

@node Background, An Example, Scanner Generator Overview, Introduction
@section Background

Scanner-generators were popularized by the scanner-generator @code{lex}
which is distributed with the popular Unix operating system.
Unfortunately, @code{lex-generated} scanners had the reputation of being
less efficient than hand-written scanners.  An attempt to remedy this
efficiency problem resulted in @code{flex} (@pxref{top, , Flex, flex,
Flex - a scanner generator}) which was extremely successful in attaining
this stated goal.  Zlex is largely upward compatible with both
@code{flex} and lex.  Its raison d'etre is multi-faceted:

@enumerate

@item
Even though @code{lex} and @code{flex} have a large number of features,
they are not flexible enough to be used in certain situations.

@item
Even though scanning is the problem in which @code{lex} and @code{flex}
specialize, the lexical specifications for their own input languages are
severely restrictive in not allowing the free-form input typical of
modern programming languages.

@item
Personal whimsical reasons: I wanted to play around with scanner-generation
algorithms.  I also suspect that I suffer from the NIH (not-invented-here)
syndrome.

@end enumerate

The performance of Zlex-generated scanners is comparable to those
generated by @code{flex}, but its additional features enable tasks which
would be very difficult if not impossible with @code{flex}.


@node An Example, Enhancements, Background, Introduction
@section An Example

The following Zlex program counts the number of lines, words and characters
in its standard input, where a @emph{word} is a maximal string of characters
not containing a whitespace character (a whitespace character is defined to
be either a space, tab or new-line).

@example
@group
001     /* @r{Word-count program for stdin.} */
002     %%
003     %@{
004       unsigned cc= 0;       /* @r{# of chars seen so far.} */
005       unsigned wc= 0;       /* @r{# of words seen so far.} */
006       unsigned lc= 0;       /* @r{# of lines seen so far.} */
007     %@}
008
009
010     [^\t \n]+       wc++; cc+= yyleng;
011     [\t ]+          cc+= yyleng;
012     \n+             lc+= yyleng; cc+= yyleng;
013     <<EOF>>         printf("%d %d %d\n", lc, wc, cc);
@end group
@end example

The above program consists of two sections separated by a line containing
only @code{%%}.  The first section is the declarations section which is used
to declare Zlex and C entities (in the above program it is empty).  The
second section contains the patterns along with the corresponding C actions.

Lines enclosed within decorated-braces @code{%@{} and @code{%@}} are copied
directly into the generated C-file.  In this example, the lines within
decorated braces at the start of the second section are used to declare and
initialize C variables local to the generated scanner function @code{yylex}.
These variables are counters which keep track of the number of characters,
words and newlines seen so far.

Line 10 in the second section consists of a pattern to match our
specification of a @emph{word}, followed by a C action.  The @samp{[} and
@samp{]} delimit a @emph{character-class} which specifies a set of
characters.  A character-class is a regular expression which matches any
character in that class.  For example, @w{@code{[\t \n]}} matches any character
which is a tab, blank or newline (Zlex allows C-style escape sequences
starting with @samp{\} within character-classes).  The @samp{^} at the
beginning of a class denotes the negation of that character-class: hence
@code{[^\t \n]} denotes any character except a tab, blank or newline, i.e. a
non-whitespace character. The postfix operator @samp{+} denotes one or more
repetitions of the previous regular expression: hence @code{[^\t \n]+}
denotes a sequence of one or more non-whitespace characters.  Since Zlex
always prefers the longest possible match, the specified regular expression
will match ``a maximal string of characters not containing a whitespace
character'' --- namely a @emph{word}.

The action for the first pattern simply increments the word count @code{wc}
by 1 and increments the character count @code{cc} by the number of
characters matched (the variable @code{yyleng} always contains the length of
the current lexeme).  Lines 11 and 12 handle blanks/tabs and newlines in a
similar manner.  Line 13 contains a special pattern which matches
end-of-file and a action which prints out the values of the three counters.

Assuming that the above program is in the file @file{wc.l}, it can be
compiled and executed using a sequence of commands similar to the following:

@example
@group
$ zlex wc.l -o wc.c
$ cc wc.c -lzlex -o wc
$ wc
'Twas brillig, and the slithy toves
  Did gyre and gimble in the wabe:
All mimsy were the borogoves,
     And the mome raths outgrabe.
^D
@result{}       4      23     135
$
@end group
@end example

@noindent
The option @samp{-o} for both Zlex and the C-compiler cc allows naming the
output file.  The first line transforms the Zlex file @file{wc.l} to a C
file @file{wc.c}.  The second line compiles the C-file into a executable,
linking it with the Zlex library (which provides a default @code{main}
program which merely calls the generated scanner function @code{yylex}).
The third line runs the executable: the next six lines are input followed by
an end-of-file (shown as a @key{^D}).  This is followed by a line which is
the executable's output containing the number of lines, number of words and
number of characters.

@node Enhancements,  , An Example, Introduction
@section Enhancements in Zlex

The enhancements provided by Zlex over @code{lex} and @code{flex} are
the following:

@table @asis

@item 16-bit character support
Zlex supports the generation of scanners which process 16-bit character
input.  Unfortunately, due of the limitations of current editors, Zlex still
requires its own source file to be specified using 8-bit characters.  Hence
16-bit characters need to be specified using their character codes (possibly
encapsulated within macros).

With this support for 16-bit characters, it should be possible to use Zlex
to built Unicode scanners, even though Zlex does not know anything about
Unicode per se.

@item Intra-token patterns
These are patterns which can be recognized within other
tokens. @xref{Intra-Token Patterns}.  Intra-token patterns are useful
for doing the pre-lexical processing required by some programming
languages (for example, the deletion of a @samp{\} followed by a newline
character in C).

@item Column numbers
Zlex supports obtaining the column number of the current token (in
addition to the undocumented @code{yylineno} feature of @code{lex}.  The
method used does not require the generated scanner to test each incoming
character to see if it is a newline.

@item Character count
It is possible to access the count of the number of characters read from the
current source file.

@item Sharing of code among multiple scanners
Much of the code required for a Zlex scanner is linked in from the Zlex
library.  This library code can be shared among multiple scanners.  The
only code unique to each scanner will be a relatively small main scanner
function and possibly several auxiliary functions (this will be in addition
to several large data tables which will be unique to each scanner).

@item  Ambiguous right-context patterns. 
Unlike other scanner generators, Zlex can handle ambiguous right context
where the pattern to be matched overlaps with the trailing context.
@xref{Right Context}.  The worst case complexity of the method used to
identify such ambiguous trailing context can be quadratic.

@item Interactive scanners
As long as @code{<stdio>} input functions are not used (@samp{--stdio}
option @pxref{Options List}), then all Zlex generated scanners can operate
interactively without any performance degradation.

@item Code Scanners
Zlex supports the generation of directly encoded scanners in addition
to the more conventional scanners which interpret tables.  At this point,
this option does not appear particularly useful.

@item Whitespace within patterns
There is an option @samp{--whitespace} (@pxref{Options List}) which makes Zlex
more tolerant of spaces and comments in the Zlex file.  This allows the Zlex
programmer to format patterns so that they are more readable. @xref{Whitespace
Within Patterns}.

@end table
@node The Scanning Process, Input File Structure, Introduction, top
@chapter The Scanning Process

When the main scanner function is entered, it initializes its data
structures if it is the first time it has been called.  It then enters a
@dfn{select-act} loop, where it recognizes a pattern which matches a
prefix of the current input, carries out the specified C action and then
repeats the process on the unprocessed suffix of the input.  If the action
terminates in a return from the main scanner function, then when the scanner
function is called again, it merely reenters the select-act loop.

The following possibilities arise as the scanner attempts to match its
patterns with a prefix of its input:

@enumerate

@item
The prefix of the input matches one or more patterns, but it is possible
that a longer prefix could also match some patterns.  In that case, unless
one of the matched patterns is a intra-token pattern (@pxref{Intra-Token
Patterns}), the scanner looks for the longer match.

@item
A single pattern matches a prefix of the input and there is no possibility
that a longer prefix could match any pattern.   In that case, the scanner
executes the action associated with the pattern.

@item
Multiple patterns match a prefix of the input and there is no possibility
that a longer prefix could match any pattern.  In that case, the scanner
uses a disambiguating rule to choose a pattern and then executes the action
associated with the chosen pattern.

@item
No pattern matches a prefix of the input.  In that situation, the scanner
executes a predefined action.

@end enumerate

@menu
* Pattern Conflicts::           When multiple patterns match.
* Scanner Backtracking::        Backtracking over input characters.
* Default Action::              When no pattern matches the input.    
@end menu

@node Pattern Conflicts, Scanner Backtracking, The Scanning Process, The Scanning Process
@section Pattern Conflicts

When multiple patterns match a prefix of the input, the scanner needs to
choose between these conflicting patterns.  These choices are governed
by the following rules:

@enumerate
@item
An intra-token pattern (@pxref{Intra-Token Patterns}) is preferred over all
other patterns and is matched as soon as it is recognized, even though it
may be a prefix of another pattern.

@item
A pattern which matches a longer prefix of the input is preferred over one
which matches a shorter prefix of the input.

@item
If two patterns match the same prefix of the input, then the pattern
which occurs earlier in the Zlex source file is preferred.

@end enumerate

Hence given the scanner specification:

@example
@group
%%
while                      @i{`Action for keyword @code{while}.'} 
[[:alpha:]_][[:alnum:]_]+  @i{`Action for an identifier.'}
@end group
@end example

@noindent
The first pattern simply matches the keyword @samp{while}.  The second
pattern matches an identifier which starts with an alphabetic character or
@samp{_} and is followed by one or more alphanumeric characters or
@samp{_}s.  If the input is @samp{while}, the identifier pattern would match
the prefixes @samp{w}, @samp{wh}, @samp{whi}, @samp{whil} and @samp{while};
the @code{while} keyword pattern would match the entire input.  By rules (2)
and (3), the @i{`Action for keyword @code{while}.'} will be that executed by
the generated scanner.

@node Scanner Backtracking, Default Action, Pattern Conflicts, The Scanning Process
@section Backtracking in Zlex Scanners

As a character is scanned by a Zlex scanner, it may tentatively be matched
with a pattern, but subsequently it may be discovered that the tentative
pattern match is incorrect and that the character needs to be rescanned
for an alternate match.  @dfn{Backtracking} refers to the rescanning of
characters to identify alternate matches.

Most Zlex scanners will do some backtracking under normal operation.
Backtracking can also be forced by the Zlex programmer by using the special
@code{REJECT} action (@pxref{Rejecting to the Next Match}).

@cindex Backtracking during scanning
As a Zlex scanner scans its input, it usually looks ahead by a single
character to decide which pattern it is in, and whether it has reached the
end of a pattern.  That single character lookahead is not always sufficient:
the scanner may have to scan several extra characters before it can be sure
which action to take.

Consider the following scanner which ignores an alphabetic string if it is
followed by a digit, but outputs an alphabetic string in blank-separated
groups of upto 4 characters when it is not followed by a digit.


@example
@group
%%
[[:alpha:]]@{4@}                  printf("%s ", yytext);
[[:alpha:]+/[[:digit:]]         /* @r{No action.} */
.|\n                            ECHO;
@end group
@end example

@noindent
The first pattern matches a sequence of exactly four alphabetical
characters (indicated by the @samp{@{4@}}).  The second pattern matches
a sequence of one or more alphabetical characters only if it is followed
by a digit (indicated by the trailing context @samp{/[[:digit:]]}).  The
final pattern matches any single character.

Consider the input line

@example
abcdefg
@end example

@noindent
The scanner will scan all the characters in @samp{abcdefg} before it
realizes that the newline terminating this alphabetic string is not a digit
and hence the second pattern cannot match.  It will match the first pattern
using @samp{abcd} returning @samp{efg} to the input stream.  As part of the
action of matching the first pattern it will output @w{@samp{abcd }}, and
will then resume scanning.  It will then look at the @samp{efg} it pushed
back, scanning past all three characters before realizing that the input
does not match either of the first two patterns.  The only alternative is
the third pattern which it matches, @code{ECHO}ing @samp{e}, and pushing
back @samp{fg}.  The same sequence of overscan and pushback repeats for
@samp{fg} with output @samp{f} and pushback @samp{g}.  Finally the remaining
@samp{g} matches the last pattern.  The output is:

@example
abcd efg
@end example

@noindent
Note that the @samp{e} is scanned twice, the @samp{f} thrice, and the
@samp{g} four times.

This sort of backtracking in Zlex is not inordinately expensive, but should
be avoided if possible.  As illustrated by the above example, the
backtracking arises because of overlapping patterns: hence overlapping
patterns should be avoided as far as possible.

@node Default Action,  , Scanner Backtracking, The Scanning Process
@section Default Action
By default, characters which are not matched by any pattern are
@code{ECHO}ed to @code{yyout} (@pxref{Scanner Output}).  This default action
can be suppressed by specifying the @code{--suppress-default} option
(@pxref{Options List}).  

A scanner which marks all lines containing character sequences which look
like ANSI-C trigraphs (which start with a sequence of 2 @samp{?}s) can be
generated from the following:

@example
@group
%%
.*"??".+        printf("*** %s", yytext);
@end group
@end example

@noindent
The @samp{.} is a regular expression which matches any character except
newline; the @samp{*} is a postfix operator which specifies 0 or more
repetitions of the preceeding regular expression; the @samp{+} is a postfix
operator which specifies 1 or more repetitions of the preceeding regular
expression.  Hence the pattern will match only lines containing a sequence
of at least two @samp{?} followed by at least one other (non-newline)
character.  The action specified for that pattern prints out the contents of
the matching line (@code{yytext}) preceeded by a mark @samp{*** }. Lines
which do not match the specified pattern will be handled character by
character by the default action and echoed to @code{yyout}.

For all applications except very simple filters, usually it is not a good
idea to depend on this default behavior for the following reasons:

@itemize @bullet
@item
Since it can be confusing to a user to have an application suddenly echo
characters not recognized by its scanner, every possible character should be
handled explicitly by scanner patterns.  At minimum, the scanner should
specify a final pattern like @code{.|\n} (with an error action) to ensure
that every character will be matched.  Such patterns will also need to be
provided for every exclusive start state (@pxref{Start State Patterns}).

@item
Since the default action processes only a single character at a time, it is
somewhat inefficient (@pxref{Efficiency}).
@end itemize



@node Input File Structure, C Interface Conventions, The Scanning Process, top
@chapter The Structure of the Zlex Input File

A Zlex file consists of upto three sections, with each section used for
different purposes.  The delimiter sequence @code{%%} on a line by itself is
used to separate sections.

The text contained in these sections is of two types:

@enumerate
@item
Text which is absorbed by Zlex.

@item
Text which is treated as a block of code to be copied into the generated
scanner.  This text is delimited by being enclosed within braces, decorated
braces (@samp{%@{} and @samp{%@}}) or by being indented (@pxref{Code
Blocks}).
@end enumerate

@menu
* Comments::                    Comments in a Zlex source file. 
* Code Blocks::                 Different ways of indicating code to be
                                copied into the generated scanner.  
* Declarations Section::        Section for Zlex and C declarations.  
* Rules Section::               Section for pattern-action rules.  
* Code Section::                Section for C code.  
* Line Directives::             Directives for setting the current line 
                                number and source file name.
@end menu

@node Comments, Code Blocks, Input File Structure, Input File Structure
@section Comments
@cindex Comments
In a Zlex file, comments enclosed within @samp{/*} and @samp{*/} can
span multiple lines.  It is also possible to have comments within patterns
if the @samp{--whitespace} option is used (@pxref{Whitespace Within Patterns}).

@node Code Blocks, Declarations Section, Comments, Input File Structure
@section Code Blocks
Code blocks which are to be copied into the generated scanner can be
delimited in any one of the following ways:

@cindex Code block

@table @asis
@item C-Code
A C-code block starts with a left-brace @samp{@{}.  Text starting with the
@samp{@{}, upto and including the @emph{balancing} right-brace @samp{@}} is
copied into the generated scanner.  Note that braces enclosed within C-style
comments, strings or character-constants are not counted when finding the
balancing @samp{@}}.  Escaped newlines (@samp{\} followed by a newline
character) are recognized within C-strings, but not within other constructs.

The knowledge of C which is used to look for the balancing @samp{@}} is
incomplete and relatively easy to fool.  For example, Zlex would get
hopelessly confused if a Zlex programmer were to @code{#define} the macro
@code{END} to be @samp{@}}, and then used @code{END} instead of @samp{@}}:
Zlex does not know anything about C-preprocessing.

@item Decorated-Brace Code
This is signalled by a line which begins with a decorated left-brace
@code{%@{}.  The @emph{rest} of the line and all subsequent lines are copied
to the generated scanner until a line starting with a decorated right-brace
@code{%@}} is encountered. The delimiting @code{%@{} and @code{%@}} are not
copied.  The contents of the copied text are not analyzed at all.

@item Indented Code
The text is on a line which begins with a space or a tab and the first
non-blank characters are not @samp{@{} or @samp{/*}.  In that case, the rest
of the line is copied to the generated scanner without any further
processing, as are all immediately following indented lines.

@item Pattern Code
The text follows a pattern in section 2 of the Zlex file and does not start
with a @samp{@{}.  The entire line except for the pattern and immediately
following whitespace are copied to the generated scanner without any further
processing as though it was indented code.  Note that pattern code blocks
can only be used when the option @samp{--no-whitespace} has been specified
(the default), as with @samp{--whitespace} the pattern code block will be
regarded as part of the pattern.

@end table

Note that the text within decorated-brace, indented or pattern code blocks
is not analyzed in any way.  This has the advantage of language
independence: if Zlex were to be retargeted to generate a scanner in a
language other than C, there would be no change in the specifications for
these code blocks.  The disadvantage is that it is impossible for Zlex to
recognize the terminating delimiter for the code block when it occurs within
a target language construct like a comment or string.


@node Declarations Section, Rules Section, Code Blocks, Input File Structure
@section Declarations Section
@cindex Declarations
This section contains the declarations of Zlex and C entities.
It is the first section in the Zlex source file and must be present (even
though it may be empty).  Hence the simplest possible Zlex source is

@example
%%
@end example

@noindent
which merely copies its input to its output using the default rule
(@pxref{Default Action}).  

Besides comments, this declarations section can contain the following:

@table @asis
@item C Declarations
These are copied directly into the generated scanner.  They can be delimited
in any of the ways outlined (@pxref{Code Blocks}).  Traditionally, decorated
braces have been used to delimit these code blocks.

@item Macro Definitions
The definition of a Zlex macro consists of a line starting with the name of
the macro followed by whitespace, followed by a regular expression giving
the definition of the macro (@pxref{Regular Expression Macros}).

@item Directives
This consists of a line starting with a @code{%} character followed by an
alphabetic string specifying the directive.  The directives currently
accepted include:

@table @asis
@item @code{%option}
This can be followed by options as they would be specified on the command-line
(@pxref{Options List}).  The options actually specified on the command-line
override the options specified in the source file using this directive.
@code{%option} directives must precede all other directives.  

@item @code{%array}
Is equivalent to @code{%option --array}.

@item @code{%pointer}
Is equivalent to @code{%option --pointer}.

@item @code{%s} or @code{%S}
These directives are used to declare inclusive start states.  The directive
can be followed by one or more space-separated start state names
(@pxref{Start States}).

@item @code{%x} or @code{%X}
These directives are used to declare exclusive start states.  The directive
can be followed by one or more space-separated start state names
(@pxref{Start States}).

@item Obsolete lex Directives
These are allowed only for backward compatibility with lex.  They have no
effect on Zlex and are undocumented as far as Zlex is concerned.
@end table
@end table

@node Rules Section, Code Section, Declarations Section, Input File Structure
@section Rules Section
This is the second section in the Zlex file.  It consists of an optional
initial C-code section (@pxref{Code Blocks}) followed by pattern-action
rules.

If the optional initial C-code section is present, it is copied into the
beginning of the generated scanner function.  It can be used to declare and
initialize any local variables needed by the Zlex programmer.

A pattern-action rule consists of a pattern (@pxref{Patterns}) followed by a
action.  The possibilities for an action are:

@table @asis
@item Empty Action
No action is specified.  This means that when a token corresponding to the
pattern is recognized, it is simply discarded.

@item C Code Block
The action consists of the concatenation of all the following code blocks
which do not have any intervening pattern (@pxref{Code Blocks}).
Traditionally, the action is specified by a @emph{single} brace-enclosed C
code block which starts on the same line as the pattern.  When a token
specified by the pattern is recognized, the specified action is carried out.

@item Next Pattern Action @samp{|} 
This special action specifies that the action for this pattern is the same
as the action for the next pattern.
@end table

@node Code Section, Line Directives, Rules Section, Input File Structure
@section Code Section
The third section of the Zlex source file consists of C code typically
containing the definitions of some of the C objects declared in the first
section.  It is simply copied unchanged into the generated scanner file.

@node Line Directives,  , Code Section, Input File Structure
@section Line Directives

@cindex Line number
@cindex Source file name
@cindex File name
@cindex Line directive

At any point in a zlex source file, outside a code block or a comment a line
which looks like
@example
%line   @var{nnn}       @var{file-name}
@end example
will pretend that the following line is line number @var{nnn} from
@var{file-name}.  The @var{file-name} is any string not containing newlines
enclosed within double quotes @samp{"}: it may contain ANSI-C escape
sequences.  Both the line number @var{nnn} and @var{file-name} are optional.

A @code{%line} directive, like all other directives, is only recognized when
it occurs at the start of a line.  It is useful to track the origin of
source lines when a zlex file is generated automatically from another source
file by a preprocessor.  The @code{%line} directive is similar to the
@code{#line} directive accepted by C-preprocessors.

If a @code{%line} directive occurs in section 2 of the zlex source file,
then it may break old @code{lex} or @code{flex} programs which would regard
the character sequence @samp{%line} at the start of a line as a pattern.
Hence the @code{%line} directive is not recognized in section 2 of the Zlex
source file when the @samp{--lex-compat} option is specified
(@pxref{Options List}).

@node C Interface Conventions, Patterns, Input File Structure, top
@chapter C Interface Conventions

The Zlex programmer is provided with C objects for accessing information
about and controlling the operation of the generated scanner.  The C
entities used for this interface are functions, variables and macros.  For
example, Zlex provides a main scanner function with default name
@code{yylex}; the text of the last matched token can be accessed using
variables with default names @code{yytext} and @code{yyleng}; Zlex provides
the C macro @code{REJECT} to find an alternate way to tokenize the current
input.

Certain conventions are used in naming these entities.  Many of these names
can be changed by the Zlex programmer.  Many entities also have alternate
names.  When we refer to an entity in this manual we usually refer to it by
its @dfn{common name}, which is the way it was referred to in historical
implementations.

@menu
* Naming Conventions::          Conventions used in naming Zlex entities.
* Scope of Names::              Whether Zlex names have function, file
                                or program scope.
* Scanner State::               Passing the internal scanner state to
                                library routines.
@end menu

@node Naming Conventions, Scope of Names, C Interface Conventions, C Interface Conventions
@section Naming Conventions

Certain conventions are used by Zlex in choosing the names for
programmer-visible C entities.

@menu
* Macros Names::                Conventions used for macro names.
* Variable Names::              Conventions used for variable names.
* Function Names::              Conventions used for function names.
* Private Names::               Conventions used for private names.
@end menu

@node Macros Names, Variable Names, Naming Conventions, Naming Conventions
@subsection Macros Names
@cindex Macro name conventions
There is a canonical form for all macro names defined by Zlex in the
generated scanner.  A @dfn{canonical macro name} starts with the prefix
@samp{YY_}, has all letters capitalized, and words are separated by
underscores.  Examples of canonical macro names are @code{YY_REJECT} and
@code{YY_NEW_FILE}.  

In order to retain compatibility with @code{lex} and @code{flex},
alternate names are provided for some macros.  These alternate names do
not meet the above conventions for canonical names.  For example,
@code{REJECT} is an alternate name for @code{YY_REJECT}.

Unfortunately, there is no consistency whether the call of a macro @var{M}
which does not require any arguments is written as @code{@var{M}()} or
simply @code{@var{M}}.  This inconsistency arises because of the need to
maintain backward compatibility with @code{lex} and @code{flex}.

@node Variable Names, Function Names, Macros Names, Naming Conventions
@subsection Variable Names
@cindex Variable name conventions
By default, the names of all variables begin with the prefix @samp{yy},
though this prefix can be changed by using the @samp{--prefix} option
(@pxref{Options List}).  The default variable names usually contain only
lower-case letters, though in a few cases, they also contain underscores for
backward compatibility.  It is possible for the user to specify an arbitrary
name for any variable by defining an appropriate C-macro.

For example, the default name of the variable which holds the length of the
current lexeme is @samp{yyleng} (@pxref{Lexeme Length}).  If at scanner
generation time, the programmer specifies the option @samp{--prefix=lex_},
then the name of the variable will be @samp{lex_len}.  If the programmer
@code{#define}s the macro @code{YY_LENG} to be @code{tokLength}, then the
name will be @samp{tokLength}.

@node Function Names, Private Names, Variable Names, Naming Conventions
@subsection Function Names
@cindex Function name conventions
There is only one documented function in the generated scanner file: this is
the main scanner function with default name @code{yylex}.  Its name can be
changed in a manner similar to variable names (@pxref{Variable Names}), by
either specifying the @samp{--prefix} option during scanner generation or by
defining the macro @code{YY_LEX}.  For example, if during scanner generation
the programmer specifies the option @samp{--prefix=scan}, then the name of
the main scanning function will be @samp{scanlex}.  If the programmer
@code{#define}s the macro @code{YY_LEX} to be @code{scan}, then the name of
the function will be @samp{scan}.

The other documented functions are those in the Zlex library.  With one
exception, the names of all these library functions start with the prefix
@samp{yy}.  They do not contain any underscores, but the first letter of
each word is capitalized.  It is not possible to change these names as they
are precompiled into the Zlex library when it is built during installation.
Examples of these library function names are @code{yyCreateBuffer},
@code{yyTopState} and @code{yySwitchToBuffer}.

@findex main
The one exception to the rule for library function names is the function
@code{main} which is a default main program which simply invokes
@code{yylex()}.  

@node Private Names,  , Function Names, Naming Conventions
@subsection Private Names
@cindex Private names
Some names are used by Zlex for its own internal purposes.  All these
private names start with the prefix @samp{yy} or @samp{YY}, independent of
the @samp{--prefix} option.  The user is urged to avoid using names starting
with these prefixes to prevent possible name clashes.

@node Scope of Names, Scanner State, Naming Conventions, C Interface Conventions
@section Scope of Names
@cindex Scope
The names provided by Zlex have three kinds of scope:

@table @asis
@item Scanner Function Scope
@cindex Function scope
If a name has scanner function scope, its use is meaningful only within the
main scanner function.  In practice, this means that the programmer can use
these names only within the actions associated with patterns and not in any
other functions.  Examples of names with scanner function scope are
@code{YY_REJECT} and @code{yy_act}.

@item File Scope
@cindex File scope
Names with file scope are meaningful only within the generated scanner
file.  All macro names which do not have scanner function scope have file
scope.  

@item Program Scope
@cindex Program scope
Names with program scope can be used through-out the program.  All public
function names and variable names have program scope.  No macro name has
program scope.

@end table

The effect of using a name outside its intended scope is undefined.  In
practice, it will usually result in a compiler error when compiling the
generated scanner.

@node Scanner State,  , Scope of Names, C Interface Conventions
@section Passing the Scanner State to Zlex Library Routines
@cindex Scanner state
@vindex yydataP
@tindex YYDataHandle
Many of the Zlex library routines need to know the current state of
private scanner variables to perform their tasks.  This need is met by
passing the state via an opaque pointer to @code{void}, @code{typedef}'d
as a @code{YYDataHandle}.  This pointer can be found in a variable with
default name @code{yydataP} having @code{extern} linkage.  Like all
other variable names, the name of this variable can be changed to an
arbitrary name by defining the macro @code{YY_DATA_P} to the new name.
Alternatively, the prefix used for the name can be changed by using the
@samp{--prefix} option (@pxref{Variable Names}).

Since this variable has external linkage, it can be accessed from files
other than the generated scanner file and passed as a handle to Zlex library
routines.

@node Patterns, The Current Lexeme, C Interface Conventions, top
@chapter Patterns

@cindex Patterns

The pattern language used for expressing the syntax of tokens is essentially
the language of regular expressions, extended with constructs which allow
context-dependent matching.

Note that we distinguish between @emph{patterns} and @emph{regular
expressions}.  Patterns are regular expressions augmented with
context-sensitive operators.  All regular expressions are patterns but not
all patterns are regular expressions.


@menu
* Meta-Characters::             Special Zlex patterns characters. 
* Regular Expressions::         Expressions describing lexical syntax. 
* Context Operators::           Making matching sensitive to context. 
* End of File Patterns::        Patterns which match end-of-file.
* Intra-Token Patterns::        Patterns which can be triggered
                                @emph{within} a token.        
* Whitespace Within Patterns::  Rules for whitespace within patterns.
@end menu

@node Meta-Characters, Regular Expressions, Patterns, Patterns
@section Meta-Characters

@cindex Meta-characters

In patterns, most characters usually stand for themselves: i.e. the
occurrence of a particular character in a pattern specifies that that
particular character should be matched.  However some characters do not
stand for themselves but are special meta-characters which tell Zlex how to
combine patterns.  The meta-characters used by Zlex are the following:

@example
        \ " ( ) @{ @} < > . ? | + * / ^ $ , -
@end example

If a pattern is required to match any of the above characters, then the
character can be quoted by preceeding it by a backslash @samp{\}.  If a
pattern is required to match a backslash, then the backslash itself can be
quoted by using @code{\\}.  Any character other than a @samp{\} or @samp{"}
can also be quoted by simply enclosing it within @samp{"} delimiters.

There are some contexts within which the above set of meta-characters is
reduced.  Since it can be difficult to remember exactly which characters are
special within which contexts, it is advisable for the Zlex programmer to
quote all non-alphanumeric characters which are to be matched literally.

@node Regular Expressions, Context Operators, Meta-Characters, Patterns
@section Regular Expressions
@cindex Regular expressions
Regular expressions are a concise notation for specifying the syntax of
tokens.  Regular expression syntax uses the following constructs and
operators.

@menu
* Single Characters::           Characters which stand for themselves.
* Escape Sequences::            How to escape Zlex's meta-characters and
                                specify non-printing characters.
* Character Classes::           Specify a set of characters.
* Named Character Classes::     Specify a set of characters in a
                                portable way.
* Any Character Except Newline::  A meta-character which matches any 
                                character except a newline.  
* String Quoting::              How to quote characters using @samp{"}.
* Regular Expression Macros::   Using macros for regular expressions.
* Optional Regular Expression::  Specifying that a match of a regular
                                expression is optional. 
* Zero or More Repetitions::    Specifying that a regular expression may
                                be matched 0 or more times.
* One or More Repetitions::     Specifying that a regular expression may
                                be matched 1 or more times.
* Counted Repetition::          Specifying that a regular expression may
                                be a certain number of times.
* Concatenation::               Using juxtaposition to specify the 
                                concatenation of the matches of multiple
                                regular expressions.
* Union ::                      An operator which specifies the union of
                                two regular expressions.
* Operator Precedence::         The precedence of the different regular
                                expression operators.
* Grouping Regular Expression::  Using parentheses to override the
                                default precedence.                         
* Operator Independence::       Some operators can be defined in terms
                                of others.
* Regular Expression Examples::  Examples of regular expressions to
                                describe the syntax of comments in
                                various programming languages.
@end menu

@node Single Characters, Escape Sequences, Regular Expressions, Regular Expressions
@subsection Single Characters
Any character which is not a meta-character is a regular expression which
matches itself.

@subsubheading Examples

@itemize @minus

The regular expression @code{A} matches the character @samp{A}.

The regular expression @code{#} matches the character @samp{#}.  However,
since @samp{#} is a non-alphanumeric character it is advisable to quote it
by escaping it using a @samp{\} as @code{\#} or by enclosing it within
@samp{"} delimiters as @code{"#"}.

@code{+} is @emph{not} a regular expression since @samp{+} is a
meta-character.

@end itemize

@node Escape Sequences, Character Classes, Single Characters, Regular Expressions
@subsection Escape Sequences
@cindex Quoting characters
@cindex Escape sequences
The backslash character can be used to quote characters and specify
character escapes in a manner similar to C.  Specifically:

@itemize @bullet
@item
@code{\a}, @code{\b}, @code{\f},
@code{\n}, @code{\r}, @code{\t}, @code{\v} are regular expressions which
match the characters @key{BEL} (bell), @key{BS} (backspace), @key{FF}
(form-feed), @key{NL} (newline), @key{CR} (carriage-return), @key{TAB}
(tab) and @key{VT} (vertical-tab) respectively.  

@cindex Octal codes
@item
@samp{\} followed by upto 3 octal digits is a regular expression which
matches the character with character code equal to the octal number.

@cindex Hexadecimal codes
@item
@samp{\x} followed by a hexadecimal number is a regular expression which
matches the character with character code equal to the hexadecimal number.

@item
@samp{\} followed by any other character (except newline) is a regular
expression which matches that character.

@end itemize
@subsubheading Examples

@itemize @minus

@samp{\x81} matches the character whose decimal character code is 129.

@samp{\400} should match the character whose decimal character code is 256.
However, this is invalid since Zlex currently only supports character codes
in the range 0--255.

@end itemize

@cindex Character classes
@node Character Classes, Named Character Classes, Escape Sequences, Regular Expressions
@subsection  Character Classes
A character class is a regular expression denoting a set of characters which
will match any single character in the set.  Character classes are specified
by listing the members of the set enclosed within @samp{[} and @samp{]}. It
is possible to denote ranges of characters in a character class by using
@code{@var{lo}-@var{hi}}, where @var{lo} and @var{hi} are the first and last
characters in the range.  A negated character class is a character class
whose first character is @samp{^} and denotes the complement of the
character class.  Escape sequences (@pxref{Escape Sequences}) are recognized within a
character-class.  The rules for recognizing special characters within
character-classes are different from those for other patterns and are given
below:

@table @samp

@item \
This is the only character which is special through-out a character class.
It is used to specify escape sequences.  It can be included by quoting it
with itself as @samp{\\}.

@item ^ 
@cindex @code{^} character class operator
This is special only at the beginning of a character class (immediately
after the @samp{[} signalling the start of the character class).  It signals
the start of a negated character class.

@item -
@cindex @code{-} character class operator
This is special and used to denote character ranges when used @emph{within}
a character class; it is not special and stands for itself when used at the
beginning of the class (immediately after the @samp{[} signalling the start
of the character class or immediately after the negated-class operator
@samp{^}) or at the end (just before the terminating @samp{]}). 

@item ] 
This is special when used after the beginning of the character class and
terminates the character class; it is not special and stands for itself when
used right at the beginning of the class (immediately after the @samp{[}
signalling the start of the character class or immediately after the
negated-class operator @samp{^}).

@end table

Any whitespace character (except newline) is significant within a character
class and specifies a character within the class.  Comments are never
recognized within a character class.  Hence the character class
@w{@code{[/*a */ a]}} would contain the four characters @samp{ }, @samp{/},
@samp{*} and @samp{a}.  Newlines are not allowed directly within a character
class and must be specified using the escape sequence @samp{\n}.

@subsubheading Examples

@itemize @minus

@code{[lL]} matches any one of the characters @samp{l} or @samp{L}.

@code{[0-9a-fA-F]} matches any hexadecimal digit.

@code{[^0-9a-zA-Z]} matches any non-alphanumeric character.

@code{[-+]} or @code{[+-]} matches any one of the characters @code{+} or
@samp{-}.

@w{@code{[\t \n]}} matches a tab, space or newline character.

@end itemize

@node Named Character Classes, Any Character Except Newline, Character Classes, Regular Expressions
@subsection Named Character Classes
@cindex @code{<ctype.h>} character class element

Specifying lowercase alphabetic characters using a pattern like @code{[a-z]}
may not work with character sets other than ASCII as the character codes for
lower-case letters may not always be contiguous in the underlying character
set.  To remedy this problem, POSIX introduced named character classes of
the form @code{[:@var{Name}:]}.  The class represented by
@code{[:@var{Name}:]} is precisely the set of characters @var{c} for which
the standard C-library function @code{is@var{Name}(@var{c})} returns
non-zero.

@table @code
@item [:alnum:]
An upper or lower-case alphabetic character or a decimal digit.

@item [:alpha:]
An upper or lower-case alphabetic character.

@item [:blank:]
A space @samp{@ } or tab @samp{\t} character.

@item [:cntrl:]
A control character.

@item [:digit:]
A digit.

@item [:graph:]
Any printing character (not a control character) other than a space character.

@item [:lower:]
A lower-case letter.

@item [:print:]
Any printing character (not a control character), including a space character.

@item [:punct:]
A punctuation character which is a printing character but not a space 
character or alphanumeric character.

@item [:space:]
A space @samp{@ }, tab @samp{\t}, carriage return @samp{\r}, newline
@samp{\n}, vertical tab @samp{\v} or form-feed @samp{\f} character.

@item [:upper:]
An upper-case letter.

@item [:xdigit:]
A hexadecimal digit.
@end table

These named classes cannot occur directly in a pattern but only as members
of a character class.  Hence @code{[:alpha:]} is not a valid pattern but
@code{[[:alpha:]]} is.

@cindex @code{.} regular expression
@node Any Character Except Newline, String Quoting, Named Character Classes, Regular Expressions
@subsection Any Character Except Newline
@samp{.} is a regular expression which matches any character except newline.

@subsubheading Example

@itemize @minus
@code{.|\n} is a pattern which matches any character (@samp{|} is a
regular expression operator specifying the union of two regular
expressions). 
@end itemize


@cindex String quoting
@node String Quoting, Regular Expression Macros, Any Character Except Newline, Regular Expressions
@subsection String Quoting
A string of characters enclosed within double-quotes @samp{"} is a regular
expression which matches that string of characters.  Escape
sequences are recognized within the string.  The
characters which are special within the string are @samp{\} (used for
escaping characters) and @samp{"} (used for terminating the string) and must
be escaped with a preceeding @samp{\} if they are to be included within the
string.  A newline cannot be contained directly within a string regular
expression, but must be specified using a escape sequence as @samp{\n}.

@subsubheading Examples

@itemize @minus

@code{"[]"} matches the string consisting of the two characters @samp{[]}.

@code{"\x30\0\"\\\n"} matches the string containing five characters: the
first character has the hexadecimal character code @code{30}, the second
character has the character code 0, the third and fourth characters are
@samp{"} and @samp{\} respectively, and the last character is the newline
character.
@end itemize

@node Regular Expression Macros, Optional Regular Expression, String Quoting, Regular Expressions
@subsection Regular Expression Macros
@cindex Macros
A macro can be defined in section 1 of the Zlex file by specifying a macro
name @var{M} followed by a regular expression @var{R}.  Any use of
@code{@{@var{M}@}} within a regular expression is expanded to
@code{(@var{R})}.  Note that the definition is restricted to be a
@emph{regular expression}; it cannot be a @emph{pattern} containing any
context operators (@pxref{Patterns}).

A macro name can contain alphanumeric characters or @samp{_} or @samp{-},
but must start with a alphabetical character or @samp{_}.  When the macro is
defined in section 1 of the Zlex file, the name must occur at the beginning
of a line.  This must be followed by whitespace followed by the macro
definition on the same line.  The regular expression comprising the macro
definition can contain calls to other macros, including those which have not
yet been defined.  It is an error for a macro to contain a call to itself,
either directly or indirectly via calls to other macros.  A macro is not
expanded until a call to the macro is encountered in section 2 of the Zlex
file.

Whitespace is allowed within the defining regular expression
(@pxref{Whitespace Within Patterns}).  When a macro name is used within
braces, no whitespace or comments are allowed within the braces.  This makes
it easier for Zlex to disambiguate a macro use, from the start of a block of
C-code.

Macros can be used to make patterns more readable if the Zlex programmer
chooses suitable mnemonic macro names.  They do not add anything to the
expressive power of the pattern language since every use of a macro name is
fully equivalent to its defining regular expression enclosed in parentheses.

@subsubheading Examples

@itemize @minus

In old @code{lex} and @code{flex} programs one often encounters macros
like the following:

@example
alpha             [a-zA-Z]
@end example

@noindent
This is not portable across all character set and is no longer necessary
since named character classes (@pxref{Named Character Classes}) can be used
instead.
@end itemize


@node Optional Regular Expression, Zero or More Repetitions, Regular Expression Macros, Regular Expressions
@subsection Optional Regular Expression
@cindex @code{?} operator
@cindex Optional regular expression
If @var{R} is a regular expression which matches @var{r'}, then
@code{@var{R}?} is a regular expression which matches zero or one
occurrences of @var{r'}.  

@subsubheading Examples

@itemize @minus

@code{[-+]?} denotes an optional sign.

@code{\.?} can be used to denote an optional decimal point.

@end itemize

@node Zero or More Repetitions, One or More Repetitions, Optional Regular Expression, Regular Expressions
@subsection Zero or More Repetitions
@cindex @code{*} operator
@cindex Kleene closure 
@cindex Closure
@cindex Zero or more repetitions
If @var{R} is a regular expression which matches @var{r'}, then
@code{@var{R}*} is a regular expression which matches zero or more
repetitions of @var{r'}.  @samp{*} is often referred to as the
@dfn{Kleene-closure} or simply @dfn{closure} operator.

@subsubheading Examples

@itemize @minus
@code{[[:alnum:]]*} will match a sequence of zero or more alphanumeric
characters.

@code{[*]*} will match a sequence of 0 or more @samp{*}s.
@end itemize

@node One or More Repetitions, Counted Repetition, Zero or More Repetitions, Regular Expressions
@subsection One or More Repetitions
@cindex @code{+} operator
@cindex One or more repetition
If @var{R} is a regular expression which matches @var{r'}, then
@code{@var{R}+} is a regular expression which matches one or more
repetitions of @var{r'}.  

@subsubheading Examples

@itemize @minus

@code{[[:xdigit:]]+} will match a sequence of one or more hexadecimal
characters.

@code{.+} will match the rest of the current line provided it is nonempty
(recall that @samp{.}  matches any character except a newline).

@end itemize

@node Counted Repetition, Concatenation, One or More Repetitions, Regular Expressions
@subsection Counted Repetition
@cindex Counted repetition
If @var{R} is a regular expression which matches @var{r'}, then
@code{@var{R}@{@var{lo},@var{hi}@}} where @var{lo} and @var{hi} are
positive integers matches @var{lo} through @var{hi} occurrences of @var{r'};
@code{@var{R}@{@var{num}@}} where @var{num} is a positive integer
matches exactly @var{num} occurrences of @var{r'}.  
@code{@var{R}@{@var{lo},@}} matches at least @var{lo}
occurrences of @var{r'}.  

No whitespace or comments are ever allowed between the starting @samp{@{}
and the first digit of the repetition count.  This restriction makes it
easier for Zlex to disambiguate counted repetition from a C-code block.

@subsubheading Examples

@itemize @minus

@code{[[:alpha:]]@{1,6@}} matches any
nonempty string of alphabetic characters upto 6 letters long.

@code{[[:digit:]]@{3@}} matches exactly three digits.

@code{[[:alnum:]]@{5,@}} matches a sequence of at least 5 alpha-numeric
characters.

@end itemize

@node Concatenation, Union , Counted Repetition, Regular Expressions
@subsection Concatenation
@cindex Concatenation 
@cindex And regular expression
If @var{R} and @var{S} are regular expressions which match @var{r'} and
@var{s'} respectively, then their juxtaposition @code{@var{R}@var{S}} is a
regular expression which matches the concatenation of @var{r'} and @var{s'}.

@subsubheading Examples

@itemize @minus

The regular expression @code{[a-zA-Z_][-0-9a-zA-Z_]*} can be
used to denote a Zlex macro name.

The regular expression @code{0[0-7]*} can be used to denote a octal number
in ANSI-C.

@end itemize

@node Union , Operator Precedence, Concatenation, Regular Expressions
@subsection Union 
@cindex @code{|} operator
@cindex Union 
@cindex Or regular expression
If @var{R} and @var{S} are regular expressions which match @var{r'} and
@var{s'} respectively, then @code{@var{R}|@var{S}} is a regular expression
which matches either @var{r'} or @var{s'}.  

@subsubheading Examples

@itemize @minus

The regular expression @code{[0-9]+[lL]?[uU]?|[0-9]+[uU]?[lL]?} 
denotes a ANSI-C integer which consists of a sequence of digits 
followed optionally by @samp{l} or @samp{L} (denoting @emph{long}), 
or by @samp{u} or @samp{U} (denoting @emph{unsigned}) in either order.  

The above can be expressed slightly more succinctly by using 
parentheses to factor out the @code{[0-9]+}, as 
@code{[0-9]+([lL]?[uU]? | [uU]?[lL]?)}.

@end itemize

@node Operator Precedence, Grouping Regular Expression, Union , Regular Expressions
@subsection Operator Precedence
@cindex Precedence
The precedence of the operators defined above is shown below.  Operators
which are grouped together have the same precedence.  The groups are in
order of decreasing precedence.

@itemize @minus

Postfix operators: Closure operator @samp{*}, one or more operator @samp{+},
optional operator
@samp{?}, counted repetition @samp{@{@var{lo},@var{hi}@}}.

Concatenation by juxtaposition.

Union operator @samp{|}.

@end itemize

@node Grouping Regular Expression, Operator Independence, Operator Precedence, Regular Expressions
@subsection Grouping Regular Expression
@cindex Precedence, overriding
If @var{R} is a regular expression, then @code{(@var{R})} is also a regular
expression equivalent to @var{R}.  The parentheses are used for grouping
regular expressions to override the default precedence of the regular
expression operators.

@subsubheading Example

@itemize @minus
@code{(a|b)c} matches either the string @samp{ab} or @samp{ac}.  If the
parentheses were omitted and the pattern was written as @code{a|bc}, then
the pattern would match the string @samp{a} or the string @samp{bc}.
@end itemize

@node Operator Independence, Regular Expression Examples, Grouping Regular Expression, Regular Expressions
@subsection Operator Independence

Some of the operators are merely syntactic sugar and can be
expressed in terms of the other operators.  For example:

@example
@group
@var{R}+ @result{} @var{R}@var{R}*
@var{R}@{2,4@} @result{} @var{R}@var{R}|@var{R}@var{R}@var{R}|@var{R}@var{R}@var{R}@var{R}
@var{R}@{2,@} @result{} @var{R}@var{R}@var{R}*
[/*-] @result{} "/"|"*"|"-"
@end group
@end example

@node Regular Expression Examples,  , Operator Independence, Regular Expressions
@subsection Regular Expression Examples

The following examples use Zlex regular expressions to specify the syntax of
comments in various programming languages.

@menu
* Ada Comments::                Regular expression for Ada comments. 
* Pascal Comments::             Regular expression for Pascal comments. 
* C Comments::                  Regular expression for C comments. 
@end menu

@node Ada Comments, Pascal Comments, Regular Expression Examples, Regular Expression Examples
@subsubsection Ada Comments
@cindex Ada comments

An Ada comment starts with the characters @samp{--} and continues to
end-of-line.  A suitable pattern is

@example
"--".*
@end example

@node Pascal Comments, C Comments, Ada Comments, Regular Expression Examples
@subsubsection Pascal Comments
@cindex Pascal comments

Pascal has two commenting conventions.  One of them is to enclose
the body of a possibly multi-line comment within braces @samp{@{} and
@samp{@}}.  The body of the comment should not contain any @samp{@}}
characters.  An incorrect attempt to write a regular expression for such a
comment is:

@example
"@{"(.|\n)*"@}"         /* @r{Wrong.} */
@end example

@noindent
The problem is that the regular expression does not enforce the restriction
that the body of the comment should not contain any @samp{@}} characters.
In fact, with Zlex's rule for preferring the longest match, the above
regular expression will interpret all the text between the first @samp{@{}
and the last @samp{@}} in a Pascal file as a comment!

A correct regular expression is:

@example
"@{"[^@}]*"@}"
@end example

@noindent
Though this is correct, it has the disadvantage that it forces Zlex to save
the text of a long comment.  For more efficient ways of processing long
comments, see @ref{Start States Example}.

@node C Comments,  , Pascal Comments, Regular Expression Examples
@subsubsection C Comments
@cindex C comment, regular expression for
A comment in C consists of any character sequence not containing the
subsequence @samp{*/} surrounded by @samp{/*} and @samp{*/}.  The following
is an incorrect attempt (which was published in a book) at writing a regular
expression for a C comment (the spaces in the regular expression have been
added for readability and can be ignored by Zlex):

@example
("/*" "/"* ([^*/] | [^*]"/" | "*"[^/])* "*"* "*/") /* @r{Wrong.} */
@end example

@noindent
Analyzing the above expression we realize that the expression within the
inner parentheses corresponds to the body of the comment except for a
possibly empty prefix containing only @samp{/}s and a possibly empty suffix
containing only @samp{*}s.  Analyzing the inner expression further, it
specifies 0 or more repetitions of

@itemize @bullet
@item 
Any character except a @samp{/} or @samp{*}.

@item
Any character except a @samp{*} followed by a @samp{/}.

@item 
A @samp{*} followed by any character except a @samp{/}.
@end itemize

Though the above seems correct, it is not.  A counterexample is the valid
comment @samp{/**1/*/} which does not match the above regular expression.
The problem is caused by ignoring the possible overlap between the
subpatterns @samp{[^*]"/"} and @samp{"*"[^/]} where the negated character
classes in both patterns may need to match the same character (@samp{1} in
the counterexample).

A solution which is claimed to be correct is the following:

@example
("/*" [^*]* "*"+ ([^/*][^*]*"*"+)* "/")
@end example

@noindent
The @code{[^*]*} deals with that prefix of the comment body which does not
contain any @samp{*}s.  When a @samp{*} occurs, we need to have a sequence
of one or more of them (@code{"*"+}).  The inner closure
@code{([^/*][^*]*"*"+)*} specifies that the sequence of @samp{*}s be
followed by 0 or more repetitions of text not starting with @samp{/} or
@samp{*} and terminating in a sequence of @samp{*}s.  So irrespective of the
number of iterations of the inner closure, the input character at the end of
the closure must be a @samp{*}. Hence a further @samp{/} in the input
terminates the comment.

Once again, this is not the recommended way to specify C comments in Zlex
because of the possibly excessive growth of the text saved by Zlex.  For the
recommended method, see @ref{Start States Example}.  As the preceeding
remark makes clear, these complicated regular expressions are mainly useful
as exercises with which to plague students.  What is more interesting is the
non-eureka process by which these expressions may be constructed, but that
is beyond the scope of this manual.


@node Context Operators, End of File Patterns, Regular Expressions, Patterns
@section Context Operators
@cindex Context
Sometimes it is necessary to match regular expressions only in certain
contexts.  This can be achieved by patterns which use additional syntax to
specify the context in which a regular expression should be matched.

@menu
* Right Context::               Right-context-sensitive matching.
* Left Context::                Left-context-sensitive matching.
@end menu

@node Right Context, Left Context, Context Operators, Context Operators
@subsection Right Context
@cindex Right context
Right context allows an input sequence to match a regular expression only if
the input which immediately follows the matching sequence satisfies certain
restrictions.  Generalized right context allows the restrictions to be
expressed via an arbitrary regular expression.  End-of-line right context is
a special case of generalized right context.

@menu
* Generalized Right Context::   Using an arbitrary regular expression to
                                specify a right context.
* End of Line::                 Matching only at end-of-line.
* Right Context Restrictions::  No multiple right context in a pattern. 
@end menu

@node Generalized Right Context, End of Line, Right Context, Right Context
@subsubsection Generalized Right Context
One can define a real number in Modula-2 by means of the following macro
definitions: 

@example
@group
digit           [0-9]
sign            [-+]
exp             E@{sign@}?@{digit@}+
real            @{digit@}+\.@{digit@}*@{exp@}?
@end group
@end example

@noindent
The above definition allows numbers like @samp{22.} with an empty fraction
and exponent.  Unfortunately, constructs like @samp{1..10} are commonly used
in Modula-2 to indicate subranges, and should be scanned as three tokens
@samp{1}, @samp{..} and @samp{10}.  However since Zlex always prefers the
longest match, the effect of the pattern @code{@{real@}} on the input
@samp{1..10} will be to scan the first token as @code{1.}, which is wrong
for Modula-2.  One solution is to scan a number as a real only if it is not
followed by a @samp{.}  character.  This can be achieved by suffixing the
above pattern with a special right-context construct which imposes this
restriction:

@example
@code{@{real@}/[^.]}
@end example

@noindent
@samp{/} is the right-context operator.  If @var{R} and @var{C} are
arbitrary regular expressions, then @code{@var{R}/@var{C}} is a pattern
which matches input @var{R'} iff @var{R} matches @var{R'} and the input
after @var{R'} matches @var{C}.  Note that the input which matched @var{C}
is available to be rescanned.

Returning to the Modula-2 example, @code{@{real@}/[^.]} will not match the
input @code{1..10}.  Instead the @code{1} can be matched by a pattern for an
integer, the @code{..} can be matched by an appropriate pattern, and the
@code{10} can be matched by the pattern for an integer.  On the other hand
if the input is @code{1.+2}, then @code{@{real@}/[^.]} will match the
@samp{1.}, since @samp{+} matches @code{[^.]}.  The @samp{+} will then be
rescanned and can be matched by a suitable pattern.

There are no restrictions on the regular expressions on either side of the
@samp{/}.  Unfortunately, this freedom allows ambiguous patterns like
@code{[a-zA-Z0-9]+/[0-9]+"#"}, for which there are multiple ways to match an
input like @samp{aA12b123#}.  Specifically, the prefixes @samp{aA12b},
@samp{aA12b1} and @samp{aA12b12} all match the specified pattern.  It is
necessary for Zlex to use a disambiguating rule to resolve the ambiguity: it
always matches the longest prefix.  For the above example, Zlex would match
@samp{aA12b12}.  Note that other scanner generators may get confused by
similar patterns.

@node End of Line, Right Context Restrictions, Generalized Right Context, Right Context
@subsubsection End of Line Right Context
@cindex End of line context
@cindex @code{$} End of line anchor

It is sometimes necessary to match a regular expression @var{R} only at the
end of a line.  This can be achieved by using the pattern @code{@var{R}/\n}.
The @code{$} end-of-line anchor is available to abbreviate this pattern to
@code{@var{R}$}.  The @samp{$} character is special only at the end of a
pattern.

@node Right Context Restrictions,  , End of Line, Right Context
@subsubsection Right Context Restrictions
A single pattern can contain only a single instance of a right-context
operator.  Hence a pattern like @w{@code{[A-Za-z0-9]+/[\t ]+$}} which
attempts to recognize an alphanumeric word only when it occurs at the end of
a line is illegal, since @samp{$} provides an additional right-context
operator. Instead, the pattern can be written as @w{@code{[A-Za-z0-9]+/[\t
]+\n}} which is legal.


@node Left Context,  , Right Context, Context Operators
@subsection Left Context
@cindex Left context

In a Zlex scanner, it is possible to use two methods for allowing
left-context to influence a match.  The first is useful when the
interpretation of a token is affected by whether or not it is at the start
of a line.  The second is more general, and allows encapsulating the
left-context into a state which selects a subset of the patterns which are
allowed to match.

@menu
* Start of Line::               Matching only at start of a line.
* Start State Patterns::        Generalized left context matching.
@end menu

@node Start of Line, Start State Patterns, Left Context, Left Context
@subsubsection Start of Line Pattern
@cindex Start of line
@cindex @code{^} Start of line anchor

In a C preprocessor, @samp{#} signals a preprocessor directive only
if it occurs at the beginning of a line (preceeded optionally by
whitespace).  A pattern which recognizes a @samp{#} only when it signals a
preprocessor directive is the following:

@example
^[\t \v\f]*\#
@end example

The @samp{^} is the @dfn{start-of-line} anchor: the following pattern is
matched only if the previous character was a newline character.

When a scanner uses one or more patterns containing the start-of-line anchor
@samp{^}, it is possible to query and set the current start-of-line
condition during scanning.  See @xref{Querying Beginning of Line} and
@xref{Setting Beginning of Line}.

@node Start State Patterns,  , Start of Line, Left Context
@subsubsection Start State Patterns
@cindex Start state patterns
The generated scanner can be in one of several different states before it
starts scanning the input for the next token: these states are known as
@dfn{start states}.  The Zlex programmer is required to name and declare all
start states and can control the transitions between start states by using
special actions. In a particular start state, only a subset of the patterns
is used to recognize tokens; exactly which subset is to be selected is
indicated by qualifying each pattern with the set of start states in which
that pattern should be active.  More information on start states can be
found in @ref{Start States}.

@node End of File Patterns, Intra-Token Patterns, Context Operators, Patterns
@section End of File Patterns
@cindex End of file patterns
The special pattern @code{<<EOF>>} (which cannot contain any internal
whitespace or comments) is used to match the end of the input file.  It may
be qualified with a set of start conditions using a syntax identical to that
used for qualifying regular expressions.  The end-of-file pattern is useful
for doing special processing at end-of-file.  The following example shows
how it can be used to signal that a construct like a comment was not
terminated before end-of-file was encountered:

@example
<COMMENT><<EOF>>   fprintf(stderr, "EOF detected within comment.");
@end example

@noindent
It is assumed that the scanner entered a @code{COMMENT} start state when a
comment was encountered.

For special Zlex actions which can be used in @code{<<EOF>>} patterns,
see @ref{End-of-File and Termination}.

@node Intra-Token Patterns, Whitespace Within Patterns, End of File Patterns, Patterns
@section Intra-Token Patterns
@cindex Intra-token patterns
Intra-token patterns are useful to do pre-lexical processing during the
scanning process.  More information on intra-token patterns can be found in
@ref{Using Intra-Token Patterns}.
@node Whitespace Within Patterns,  , Intra-Token Patterns, Patterns
@section Whitespace Within Patterns
@cindex Whitespace
Whitespace is allowed in Zlex patterns when the option
@samp{--whitespace} is specified (@pxref{Options List}).  Unfortunately, it
is not possible to allow totally free-format input in order to retain as
much backward-compatibility as possible with @code{flex} and @code{lex}.
The rules for how whitespace within different constructs are as follows:

@table @asis
@item What is whitespace?
Blanks, tabs and comments are regarded as equivalent whitespace.
Newlines are treated somewhat differently.

@item Character classes and strings
Whitespace (except newlines) is always significant and is included in the
pattern.  Newlines are not allowed directly in strings or character classes,
but must be escaped.  The effect of whitespace within these constructs is
independent of the @samp{--whitespace} option.  This behavior is identical
to the behavior of other common text processing utilities.

@item End-of-file Pattern
Whitespace is never allowed in the end-of-file token @code{<<EOF>>} which is
regarded as an indivisible token.  This behavior is independent of the
@samp{--whitespace} option.

@item Macro Calls
Whitespace is never allowed in macro calls of the form
@code{@{@var{macro}@}} which are regarded as indivisible tokens.  This
behavior is independent of the @samp{--whitespace} option.

@item Regular Expressions in Macro Definitions
Spaces and tabs are always allowed and ignored within the regular
expressions used for macro definitions in section 1 of the Zlex file.  When
the option @samp{--whitespace} is not specified, the pattern is terminated
by the first newline; when the option @samp{--whitespace} is specified,
newlines are allowed and ignored @emph{provided they occur within
parentheses}.

@item Patterns in Section 2
When the @samp{--whitespace} option is not specified, a pattern in section 2
is terminated by the first non-quoted whitespace which is not within a
string or character class. When the @samp{--whitespace} option is specified,
whitespace which is not within a character class or string in a section 2
pattern is allowed and ignored; the pattern is terminated by the start of a
brace-enclosed action or by the first newline which is not within parentheses.
@end table

@noindent
One consequence of these rules is that when the @samp{--whitespace} option
is used, it is not possible to include a action for a pattern in section 2
of the Zlex file without enclosing the action within braces.


@node The Current Lexeme, Start States, Patterns, top
@chapter Accessing the Current Lexeme

Two variables with external linkage allow accessing the characters
constituting the last matched token, as well as its length.

@menu
* Lexeme Text::                 Accessing the text of a lexeme.
* Lexeme Length::               Accessing the length of a lexeme.
* Catenating Tokens::           Concatenation of successive tokens. 
@end menu

@node Lexeme Text, Lexeme Length, The Current Lexeme, The Current Lexeme
@section Current Lexeme Text: @code{yytext}
@cindex Text of token
@cindex Token text
@vindex yytext
@findex YY_TEXT
This is a variable which enables access to the sequence of characters
which constitute the lexeme of the current token.  This sequence of
characters is always terminated by a @key{NUL} @samp{\0} character.
Like all other variable names, the name of this variable can be changed
to an arbitrary name by defining the macro @code{YY_TEXT} to the new
name.  Alternatively, the prefix used for the name can be changed by
using the @samp{--prefix} option (@pxref{Variable Names}).  Its default
declaration depends on whether the option @samp{--pointer} or
@samp{--array} is used (@pxref{Options List}).  When @samp{--pointer} is
used, its default declaration is @code{char *yytext}; when
@samp{--array} is used, its default definition is equivalent to
@vindex YYLMAX

@example
char *yytext[YYLMAX];
@end example

@noindent
where @code{YYLMAX} is a macro which gives the size of the array.
@code{YYLMAX} can be defined by the user in section 1 of the Zlex file if a
value different from the default value (@code{8192}) is desired.  

When @code{yytext} is declared to be an array and the length of a matched
lexeme is greater than the value of @code{YYLMAX}, then the @code{yytext}
array will silently overflow with unpredictable results.  When @code{yytext}
is declared to be a pointer, there is no possibility of overflow as the
lexeme text is maintained within the scanner's buffer (which is grown
dynamically as needed).

A scanner in which @code{yytext} is declared to be a pointer is usually
faster than one in which it is declared to be an array.  This fact, coupled
with the overflow problem mentioned previously, make a @code{%array}
declaration fairly useless except for backward compatibility with
lex.

The Zlex programmer should always treat @code{yytext} as a read-only
variable.

The following program fragment shows a pattern-action pair which matches the
occurrence of an identifier at the beginning of a line and saves it in
dynamic memory pointed to by the variable @code{text}.

@example
@group
%%

[[:alpha:]_][[:alnum:]_]*       
  @{  text= malloc(yyleng + 1); /* @r{@code{+1} for terminating @code{NUL}.} */
     if (!text) @{ @i{`Call an error routine.'} @}
     strcpy(text, yytext);
  @}
@end group
@end example

@node Lexeme Length, Catenating Tokens, Lexeme Text, The Current Lexeme
@section Current Lexeme Length: @code{yyleng}
@cindex Length of token
@cindex Token length
@vindex yyleng
@findex YY_LENG
This variable with declaration @code{int yyleng} holds the length of the
current token.  The @dfn{length of a token} is the number of characters
in the lexeme of the token (not counting any terminating @code{'\0'}).
Like all other variable names, the name of this variable can be changed
to an arbitrary name by defining the macro @code{YY_LENG} to the new
name.  Alternatively, the prefix used for the name can be changed by
using the @samp{--prefix} option (@pxref{Variable Names}).

The Zlex programmer should always treat @code{yyleng} as a read-only
variable.

The following program produces a histogram of word-lengths, where a word
is defined to be a maximal sequence of characters not containing a
space, tab or newline.

@example
@group
%@{
enum @{ MAX_WORD_LEN= 10 @};
static unsigned freq[MAX_WORD_LEN];
%@}
%%
[^\t \n]+       @{ if (yyleng > MAX_WORD_LEN) @{
                     @i{`Signal error;'}
                  @} 
                  else @{
                    freq[yyleng]++; 
                  @}
                @}
[\t \n]+        /* @r{No action.} */
<<EOF>>         @{ unsigned i;
                  for (i= 0; i < MAX_WORD_LEN; i++) @{
                    printf("%d: %d\n", i, freq[i]);
                  @}
                @}
@end group
@end example

@node Catenating Tokens,  , Lexeme Length, The Current Lexeme
@section Concatenating Tokens: @code{yymore} 

If an action contains a call to the @code{yymore()} macro, then the lexeme
for that token is prefixed to the lexeme of the next token recognized.
Effectively, this allows the programmer to recognize subtokens within a
larger token.  The canonical form @code{YY_MORE()} can also be used instead.
The library function @code{yyMore(YYDataHandle)} can also be used from files
other than the generated scanner file.

For example, let us suppose that an application requires printing out the
input lines in reverse order, and printing the total number of words in the
input.  Whenever a token within a line is recognized the scanner executes
a @code{yymore} action: hence when the @samp{\n} terminating a line is
finally matched, @code{yytext} contains the text for the entire line.  This
is saved in a stack of lines using a function @code{pushLine()} shown below.
Finally at @code{<<EOF>>} this stack is traversed with the lines being
printed in reverse order.

@example
@group
%@{
#include <stdio.h>
#include <stddef.h>

typedef struct LineStruct @{
  struct LineStruct *last;
  char *text;
@} LineStruct;

static LineStruct *pushLine(LineStruct *lines, 
                            const char *text, int textLen);

%@}
%%
  /* @r{Declare local variables.} */
  int wc= 0;
  LineStruct *lines= NULL;
[\t ]+          yymore();
[^\t \n]+       wc++; yymore();
\n              lines= pushLine(lines, yytext, yyleng);
<<EOF>>         @{ LineStruct *p;
                  for (p= lines; p; p= p->last) fputs(p->text, stdout);
                  printf("# of words= %d\n", wc);
                @}
%%
static LineStruct *
pushLine(LineStruct *lines, const char *text, int textLen)
@{
  char *const savedText= malloc(textLen + 1);
  LineStruct *const lineP= malloc(sizeof(LineStruct));
  if (!savedText || !lineP) @{
    fprintf(stderr, "Out of memory.\n"); exit(1);
  @}
  strcpy(savedText, text);
  lineP->text= savedText; lineP->last= lines;
  return lineP;
@}
@end group
@end example

A log of running the scanner generated from the above follows:

@example
@group
"Beware the Jabberwock, my son!
  The jaws that bite, the claws that catch!
 Beware the Jubjub bird, and shun
    The frumious Bandersnatch!"
^D
@result{}
    The frumious Bandersnatch!"
 Beware the Jubjub bird, and shun
  The jaws that bite, the claws that catch!
"Beware the Jabberwock, my son!
# of words= 22
@end group
@end example

@node Start States, Scanner Input, The Current Lexeme, top
@chapter Start States
@cindex Start states

Start states allow the behavior of the scanner to depend on the left context
within the input.  Several actions allow the scanner to control or access
its current start state.

@menu
* Start State Types::           Two flavors of start states.
* Start State Declarations::    How to declare start states.
* Entering a Start State::      Zlex action to change start state. 
* Current Start State::         Accessing the current start state.
* Start State Stacks::          Stacking start states.
* Start States Example::        Start states to process C comments. 
* Using Inclusive Start States::  Tips on where inclusive start states 
                                maybe useful.
@end menu

@node Start State Types, Start State Declarations, Start States, Start States
@section Start State Types
Start states are of two types: @emph{exclusive} and @emph{inclusive}. When a
@cindex Exclusive start state
@dfn{exclusive start state} is active, only those patterns whose qualifying
start states include the name of that start state are selected.  See
@ref{Start States Example} for an example where start states are used to
process C-style comments.  When a
@cindex Inclusive start state
@dfn{inclusive start state} is active, patterns which do not have any
qualifying start states at all are also selected in addition to the patterns
whose qualifying start states include the name of the active start state.
This implies that a pattern with no qualifying start states is equivalent to
the same pattern qualified by @strong{all} the @emph{inclusive} start
states.  Inclusive start states are useful to factor out the commonality
within different start states (@pxref{Using Inclusive Start States}).

Start state qualified patterns can occur only in section 2 of the Zlex
file.  The syntax for qualifying patterns is to prefix the pattern with the
names of the start states separated by commas @samp{,}, and enclosed within
angle brackets @samp{<} and @samp{>}.  The following patterns are 
examples of start state qualified patterns:

@example
@group
<INITIAL>"/*"
<COMMENT>"*/"
<INITIAL,COMMENT>\n
@end group
@end example

@noindent
where it is assumed that @code{INITIAL} and @code{COMMENT} are suitably
declared start states.

        
@node Start State Declarations, Entering a Start State, Start State Types, Start States
@section Start State Declarations

Before a start state name can be used in section 2 of the Zlex file, it must
be declared in section 1 of the Zlex file.  An exclusive (inclusive) start
state is declared in section 1 by a line starting with @code{%x} (@code{%s})
or @code{%X} (@code{%S}) followed by whitespace followed by the name of the
start state on the same line.  Multiple start states of the same type can be
declared by including multiple names on the same line separated by space.
The characters allowed within a start state name are identical to those
allowed in a macro name: a sequence of alphanumeric or @samp{_} or @samp{-}
characters starting with an alphabetic or @samp{_} character.  

The following are examples of start state declarations:

@example
@group
%x      COMMENT C_CODE          /* @r{Exclusive start states.} */
%s      RANGE SS_USE            /* @r{Inclusive start states.} */
@end group
@end example

In the generated scanner, the programmer declared start state names are
@code{#define}d to be small integers.  Hence the programmer should not use
these names in any other context.  
@cindex Initial start state
@cindex Start states, initial
@findex INITIAL
All Zlex generated scanners predefine an
inclusive start state called @code{INITIAL} which is the initial start
state for the scanner when it is first called.
@code{INITIAL} is @code{#define}d to be
@code{0}; The
user should not make any assumptions about the assignment of integers to
other start states, and should always refer to them using their symbolic
names.

@node Entering a Start State, Current Start State, Start State Declarations, Start States
@section Entering a Start State: @code{BEGIN}
@cindex Beginning a start state
@findex BEGIN
@findex YY_BEGIN
The macro @code{BEGIN} is used to set the current start state.  To set the
current start state to one with name @var{ss}, @code{BEGIN(@var{ss})} can be
used.  For backwards compatibility reasons, @code{BEGIN @var{ss}} without
the parentheses can also be used.

The canonical name @code{YY_BEGIN} can be used instead; unlike @code{BEGIN},
the parentheses are always required.  To begin start-state @var{ss} the form
@code{YY_BEGIN(@var{ss})} is used.  

Since the @code{INITIAL} start state (@pxref{Start State Declarations}) is
@code{#define}d to be @code{0}, @code{BEGIN 0} is synonymous with
@code{BEGIN INITIAL}.

The following example shows how inclusive start states can be used to
recognize numbers in different bases depending on a specific directive.  The
base is set by a @samp{%bin}, @samp{%oct} or @samp{%hex} directive which
must occur at the start of a line.

@example
@group
%s BIN OCT HEX
%%
^"%bin"                 BEGIN BIN;
^"%oct"                 BEGIN OCT;
^"%hex"                 BEGIN HEX;
<BIN>[01]+              @i{`Action for a binary number.'}
<OCT>[0-7]+             @i{`Action for a octal number.'}
<HEX>[a-fA-F0-9]+       @i{`Action for a hexadecimal number.'}
@i{`Other non-qualified patterns.'}
@end group
@end example

@node Current Start State, Start State Stacks, Entering a Start State, Start States
@section Accessing the Current Start State: @code{YY_START}
@cindex Start states, current
@cindex Current start state
@findex YY_START
@findex YYSTATE

The macro @code{YY_START} returns the current start state (an unsigned
integer).  @code{YYSTATE} is synonymous with @code{YY_START}.

Accessing the current start state using @code{YY_START} allows the Zlex
programmer to use start-state subroutines.  For example, in the scanner for
Zlex, C-style comments are allowed within several constructs.  These
comments are processed using an exclusive start state @code{COMMENT}
(@pxref{Start States Example}).  When we are in a construct and see the
start of a comment, we do a @code{BEGIN COMMENT} @emph{after} saving the
current start state in a global variable, say @code{commentRet}.  Then when
in the @code{COMMENT} state we see the end of the comment we do a
@code{BEGIN commentRet}, which puts us back in the start state in which we
originally saw the comment.

In the above situation, we could predict exactly how many start states
we need to save at any time (exactly one).  That may not be possible in
general.  Start state stacks may be used in such situations
(@pxref{Start State Stacks}).

@node Start State Stacks, Start States Example, Current Start State, Start States
@section Start State Stacks

In a Zlex scanner, start state stacks can be created and manipulated using
three routines.

@menu
* Pushing a Start State::       
* Popping the Start State Stack::  
* Top of the Start State Stack::  
@end menu

@node Pushing a Start State, Popping the Start State Stack, Start State Stacks, Start State Stacks
@subsection Pushing a Start State: @code{yy_push_state}
@cindex Pushing a start state
@cindex Start state, pushing
@findex yy_push_state
@findex YY_PUSH_STATE

The macro @code{yy_push_state(@var{ss})} pushes the current start-state on
top of the start state stack and does a @code{BEGIN @var{ss}} action.  The
canonical name @code{YY_PUSH_STATE} may be used synonymously.  From files
other than the generated scanner, the programmer can call the Zlex library
function @code{yyPushState} with prototype:

@example
@group
void 
yyPushState(YYDataHandle d, YYState ss);
@end group
@end example

@noindent
to push the current start state on the start state stack of the scanner
specified by @code{d} and enter start state @code{ss}.

@node Popping the Start State Stack, Top of the Start State Stack, Pushing a Start State, Start State Stacks
@subsection Popping the Start State Stack: @code{yy_pop_state}
@cindex Popping a start state
@cindex Start state, popping
@findex yy_pop_state
@findex YY_POP_STATE

The macro @code{yy_pop_state()} sets the current start state to the state on
top of the start state stack and pops the start state stack.  The canonical
name @code{YY_POP_STATE} may be used synonymously.  From files other than
the generated scanner, the programmer can call the Zlex library function
@code{yyPopState} with prototype:

@example
@group
void 
yyPopState(YYDataHandle d);
@end group
@end example

@noindent
to set the current start state to the state on top of the start state stack
of the scanner specified by @code{d} and pop its start state stack.

@node Top of the Start State Stack,  , Popping the Start State Stack, Start State Stacks
@subsection The Top of the Start State Stack: @code{yy_top_state}
@cindex Top of the start state stack
@cindex Start state stack, top
@findex yy_top_state
@findex YY_TOP_STATE

The macro @code{yy_top_state()} return the start state on top of the start
state stack.  The start state stack is not changed.  The canonical name
@code{YY_TOP_STATE} may be used synonymously.  From files other than the
generated scanner, the programmer can call the Zlex library function
@code{yyTopState} with prototype:

@example
@group
YYState 
yyTopState(YYDataHandle d);
@end group
@end example

@noindent
to return the start state on top of the start state stack of the scanner
specified by @code{d}.

@node Start States Example, Using Inclusive Start States, Start State Stacks, Start States
@section Start States Example: C comments
@cindex C comments using start states

The following example is the recommended way to process C-style comments
using Zlex.  It illustrates the use of exclusive start states to allow the
scanner to process the comments in reasonable line-sized chunks.

When the generated scanner sees a @samp{/*} it enters a exclusive start
state named @code{COMMENT} where it is looking for the terminating
@samp{*/}.  Because @code{COMMENT} is an exclusive start state, Zlex will
ignore all patterns not qualified by @code{COMMENT} when in the
@code{COMMENT} state.

@example
@group
001     %x                      COMMENT         /* @r{Declare start-state.} */
002     %%
003     "/*"                    BEGIN COMMENT;
004     <COMMENT>"*/"           BEGIN INITIAL;
005     <COMMENT>[^*\n]+
006     <COMMENT>\n
007     <COMMENT>"*"+/[^/]              
@end group
@end example

Line 1 declares the identifier @code{COMMENT} to be an exclusive
start-state.  Line 3 has a pattern for recognizing the @samp{/*} which
begins a comment.  Since the pattern is not qualified by any start states,
it will be active in all inclusive start states: namely @code{INITIAL}.  Its
action uses the special Zlex macro @code{BEGIN} (@pxref{Entering a Start
State}) to enter the special @code{COMMENT} state.

Line 4 recognizes the terminating @samp{*/} only when the scanner is in the
@code{COMMENT} state.  Its action is to change the scanner state back to
@code{INITIAL}.  Once the scanner is back in the @code{INITIAL} state, the
patterns prefixed by @code{COMMENT} are ignored, and other patterns (not
shown) become active.

Line 5 recognizes any prefix of a comment line which does not contain
@samp{*}.  Note the use of @code{\n} in the negated character class; if we
had simply used the regular expression @code{[^*]+}, then it could
conceivably match several lines of text --- something which is undesirable
as the @code{yytext} saved by the scanner may become excessively large.

Lines 6 and 7 recognize those portions of a comment not recognized by line
5.  Line 6 recognizes a newline occurring within a comment.  The
given code does not have any action but if the scanner is keeping track of
line numbers, an appropriate action would be to increment a line number
counter.  Line 7 recognizes @samp{*}s occurring within a comment which are
not followed by a @samp{/}.  We use @code{"*"+/[^/]} rather than simply
@code{"*"/[^/]}, as it is always desirable to scan as large a token as
possible to reduce scanner overhead.

@node Using Inclusive Start States,  , Start States Example, Start States
@section Using Inclusive Start States
@cindex Inclusive start states, use of
Inclusive start states are not strictly necessary, but are useful to capture
the semantics of a state which is very similar to other inclusive states, in
that all except a few tokens are processed identically.  The implementation
of Zlex itself provides a practical example of such uses of inclusive start
states.  In Zlex, the @samp{,} character is usually an ordinary character:
within a pattern it usually stands for itself specifying that a comma should
be matched.  The exceptions to this rule are:

@itemize @bullet
@item
A comma is used to separate start state names within the qualifying start
state list for a pattern,

@item
A comma is used within the counted repetition operator 
@code{@{@var{lo},@var{hi}@}} to separate @var{lo} from @var{hi}.
@end itemize

@noindent
The Zlex scanner defines two inclusive start states @code{RANGE} and
@code{SS_USE} which return a comma as a special token.  A highly simplified
version of the code is shown below.

@example
@group
%s      RANGE           /* @r{Start state for counted repetition.} */
%s      SS_USE          /* @r{Start state for start state list.} */

%%

"@{"                     BEGIN RANGE; 

"<"                     BEGIN SS_USE;

<RANGE,SS_USE>","       return ',';

.                       return CHAR_TOK;
@end group
@end example

@noindent
If a comma is encountered when the scanner is in either one of the states
@code{RANGE} or @code{SS_USE} it is returned as the special token @code{','}.
Otherwise it is simply returned as a @samp{CHAR_TOK}.  Note that any other
characters will be matched using the patterns without any start-state
qualifications: in the currently popular object-oriented parlance,
@code{RANGE} and @code{SS_USE} @emph{inherit} behavior from the patterns
without start-state qualifications.

@node Scanner Input, Scanner Output, Start States, top
@chapter  Input in a Zlex Scanner

A Zlex scanner reads its input from a @code{stdio} @code{FILE} pointer
with default name @code{yyin}.  For performance reasons, it buffers its
input.  Normally, it is the main scanner function which reads its input
directly from the buffer, but it is also possible for the Zlex
programmer to read directly from the buffer using the @code{input}
macro.  It is possible for the programmer to specify the method by which
the scanner fills its buffer by defining the @code{YY_INPUT()} macro.
The programmer is allowed to modify the characters in the scanner buffer
and backtrack to alternate matches with the prefix of the input.  It is
also possible for the Zlex programmer to query the position in the
current input stream, or the current line or column number.  When
patterns involving the start-of-line anchor @samp{^} have been used,
Zlex makes it possible to query and set the current start-of-line
condition.

@menu
* Input File Pointer::          @code{FILE} pointer to input stream. 
* Direct Input::                Reading directly from the input.
* Redefining the Input Macro::  Controlling how buffers are filled. 
* The Null Value::              
* Modifying Input::             Putting characters into the input. 
* Rejecting to the Next Match::  Rescanning via alternate patterns. 
* Character Count::             Character count in input stream.
* Current Line Number::         Line number in input stream.
* Current Column Number::       Column number in input stream.
* Querying Beginning of Line::  Check if at beginning of a line.
* Setting Beginning of Line::   Ensure at beginning of a line.
@end menu

@node Input File Pointer, Direct Input, Scanner Input, Scanner Input
@section Input File Pointer: @code{yyin}
@cindex Input @code{FILE}
@vindex yyin
@findex YY_IN
@code{yyin} is the default name of the variable with declaration
@code{FILE *yyin} which Zlex uses to read its input.  Like all other
variable names, the name of this variable can be changed to an arbitrary
name by defining the macro @code{YY_IN} to the new name.  Alternatively,
the prefix used for the name can be changed by using the @samp{--prefix}
option (@pxref{Variable Names}).

When the scanner function is first entered it initializes @code{yyin} to
@code{stdin}, unless the user has already initialized it to a
non-@code{NULL} @code{FILE} pointer.  So if the generated scanner should
read from a file other than the standard input, the programmer need only
initialize @code{yyin} to a suitable @code{FILE} pointer.  For example, the
following main program illustrates how to setup the scanner to read from the
file specified by the first command-line argument.

@example
@group
%@{
#define YY_IN inFile    /* @r{Use @code{inFile} instead of @code{yyin}}. */
%@}
%%
@i{`Patterns go here.'}
%%
int 
main(int argc, const char *argv[])
@{
  if (argc < 2) @{
    @i{`Usage error.'}
  @}
  if (!(inFile= fopen(argv[1], "r"))) @{
    @i{`File open error.'}
  @}
  return yylex();       /* @r{Call generated scanner function.} */
@}
@end group
@end example

@node Direct Input, Redefining the Input Macro, Input File Pointer, Scanner Input
@section Direct Input: @code{input}
@cindex Input
@findex input
@findex YY_GET

The @code{input()} macro returns the next character from the input buffer,
returning -1 if end-of-file is encountered.  If C++ is being used, then the
alternate name @code{yy_input()} is used instead.  The canonical name
@code{YY_GET()} is also recognized.  The Zlex library function
@code{int yyGet(YYDataHandle)} can also be used to read the next character from
the input.  It returns -1 on EOF.  Use @code{YY_GET()} to read the input
when the call is within the scanner file.  Outside the scanner file it is
necessary to call @code{yyGet()} passing it the data handle of the relevant
scanner.

The following excerpt illustrates a common use of @code{input()} to ignore
C-style comments: 

@example
@group
"/*"            @{ int ch0, ch1= ' ';
                  do @{
                    ch0= ch1; ch1= input();
                  @} while (ch1 != EOF && (ch0 != '*' || ch1 != '/'));
                  if (ch1 == EOF) error("EOF within comment.");
                @}
@end group
@end example

@noindent
Note that this is not the recommended way to process comments in Zlex.  For
the recommended method, see @ref{Start States Example}.

@node Redefining the Input Macro, The Null Value, Direct Input, Scanner Input
@section Redefining the Input Macro @code{YY_INPUT}
@cindex Input, redefining
@findex YY_INPUT
@findex YY_EOF_IN

@code{YY_INPUT(buf, result, maxSize)} provides input to Zlex buffers.  It
should fill the @code{char *buf} with upto @code{int maxSize} characters and
return in @code{int result} either the number of characters read or
@code{YY_EOF_IN} to indicate end-of-file.  Its default definition uses the
system @code{read} routine, but if the @code{--stdio} option is specified
(@pxref{Options List}), then its default definition uses the @code{fread} routine
from the @code{stdio} library.

The definition of the macro @code{YY_EOF_IN} to be returned by
@code{YY_INPUT} defaults to @code{YY_NULL} (@pxref{The Null Value}), but
it can be redefined by the programmer in section 1 of the Zlex source file
to some other value.

This macro can be redefined in section 1 of the Zlex file to get input some
other way.  For example, Zlex currently supports processing of only 7-bit or
8-bit characters.  However, it is possible to use Zlex to process words of
size larger than that of a @code{char}, if those words can be mapped into
characters without loss of information.  This can be done as follows:

@example
@group
#define YY_INPUT(buf, result, n)   result= wordInput(buf, n)

int
wordInput(char *buf, unsigned n)
@{
  Word *wordBuf= (Word *)malloc(n * sizeof(Word));
  unsigned nWords;
  int result;
  if (!wordBuf) @{ @i{`Signal memory allocation error.'} @}
  nWords= readWords(wordBuf, n); /* @r{Read words from source.} */
  if (nWords == 0) @{
    result= YY_EOF_IN;
  @}
  else @{
    unsigned i;
    for (i= 0; i < nWords; i++) buf[i]= mapWordToChar(wordBuf[i]);
    result= nWords;
  @}
  free(wordBuf);
  return result;
@}
@end group
@end example

@noindent
where @code{mapWordToChar()} maps a word into a character.  Note that the
scanner will maintain the current lexeme in @code{yytext} using characters;
it will be the programmer's responsibility to map these characters back into
@code{Word}s.

@node The Null Value, Modifying Input, Redefining the Input Macro, Scanner Input
@section The Null Value: @code{YY_NULL}

@findex YY_NULL
The macro @code{YY_NULL} is used for two purposes:

@enumerate
@item
It is the value to be returned by @code{YY_INPUT} (@pxref{Redefining the
Input Macro}) on end-of-file.

@item
It is the value returned by the scanner when end-of-file is encountered.
@end enumerate

The default definition for @code{YY_NULL} is @code{0}, but the programmer
can redefine this macro in a C-code section in section 1 of the Zlex file.

Zlex uses @code{YY_NULL} only for compatibility with undocumented behavior
of @code{flex}.  Its use is discouraged, as it is has two distinct
purposes.  Instead, the programmer should use @code{YY_EOF_IN}
(@pxref{Redefining the Input Macro}) or @code{YY_EOF_OUT}
(@pxref{Termination Return Value}) for each respective purpose.

@node Modifying Input, Rejecting to the Next Match, The Null Value, Scanner Input
@section Modifying Characters in the Input Stream

@cindex Input, modifying the
Two methods can be used by a Zlex programmer to force the generated
scanner to insert characters into the input stream.  The first of these is
@code{YY_LESS} which returns characters from the current lexeme to the input
stream; the other is @code{YY_UNPUT} which can be used to insert arbitrary
characters (not necessarily from the current lexeme) into the input stream.

@menu
* Rescanning Lexeme Text::      Pushing back scanned characters.
* Unput::                       Pushing back arbitrary characters.
@end menu

@node Rescanning Lexeme Text, Unput, Modifying Input, Modifying Input
@subsection Rescanning Lexeme Text: @code{yyless}
@findex yyless
@findex YY_LESS
@code{yyless(n)} returns all but the first n characters of the current lexeme
back to the input stream.  @code{yytext} and @code{yyleng} are suitably
adjusted.  The canonical form @code{YY_LESS(n)} can also be used.  The library
function @code{yyLess(YYDataHandle d, int n)} can also be used from files
other than the generated scanner file.

Note that if it is necessary to look ahead in the input stream in order to
recognize a token, it is preferable to use right context patterns
(@pxref{Right Context}).  Note also that @code{yyless(0)} will cause the
scanner to enter an infinite loop unless its state is changed in some way.

The following excerpt illustrates the use of @code{yyless} to generate
multiple tokens from the same subsequence of the input stream.  This may be
useful in a situation where a single input subsequence signals both the end
of a syntactic construct and the start of the next syntactic construct.  If
we assume that @code{xxx} is a Zlex macro defining the subsequence of
interest then the following code should achieve our goal:

@example
@group
@{xxx@}         @{ if (flag == 0) @{
                    flag= 1; yyless(0); return TOK0;
                  @}
                  else @{
                    flag= 0; return TOK1;
                  @}
              @}
@end group
@end example

@noindent
We assume that @code{flag} is a suitably declared C variable, and
@code{TOK0} and @code{TOK1} are the token values.

@node Unput,  , Rescanning Lexeme Text, Modifying Input
@subsection Unputting Characters: @code{unput}
@cindex unput
@findex unput
@findex YY_UNPUT
@code{unput(c)} puts the character @code{c} onto the input stream to be the
next character read.  The Zlex programmer should ensure that 0 <= @code{c} <
@var{character set size}; @code{unput} cannot be used to unput an @code{EOF}
character.  The contents of @code{yytext} are unaffected.  Note that it is
more efficient to use @code{yyless} if all that is desired is to unput a
suffix of @code{yytext}.

The canonical form @code{YY_UNPUT(c)} may also be used. The Zlex library
function @code{yyUnput(YYDataHandle d, int c)} may also be used from files
other than the generated scanner file.

The following excerpt illustrates the use of @code{unput} to translate
character sequences.  If an application dictates that the input sequences
@samp{%%(} and @samp{%%)} be translated to the sequences @samp{[} and
@samp{]} respectively before any tokenizing occurs, and it is known that the
sequences cannot occur within other tokens, then we can use the following
pattern-action pairs:

@example
@group
"%%("   unput('[');
"%%)"   unput(']');
@end group
@end example

@noindent
Note that this suffices only because it is specified that the sequences
cannot occur within other tokens.  If that is not the case, then the above
code would not be correct and we would either need to redefine
@code{YY_INPUT} (@pxref{Redefining the Input Macro}) appropriately, or use
intra-token patterns (@pxref{Using Intra-Token Patterns}).

@node Rejecting to the Next Match, Character Count, Modifying Input, Scanner Input
@section Forced Backtracking: @code{REJECT}
@cindex Forced backtracking
@cindex Backtracking, forcing
Backtracking can be forced to occur in a Zlex scanner to try alternate
choices for a pattern by using the @code{REJECT} action.  The initial choice
of pattern is governed by the rules built into the generated scanner.  When
multiple patterns match the input to a Zlex generated scanner, the choice of
pattern is governed by rules which first prefer the longest match and then
the pattern which occurs earlier in the Zlex source file (@pxref{Pattern
Conflicts}).


@cindex Rejecting to next match
@findex REJECT
@findex YY_REJECT
@code{REJECT} transfers control to the action of the next pattern which
matches the current lexeme or a prefix of the current lexeme.  This action
can also be referred to using the canonical name @code{YY_REJECT}.

@code{REJECT} performs a transfer of control --- it is equivalent to an
unconditional @code{goto} and the code immediately following the
@code{REJECT} will never be executed.  Also @code{REJECT} has function scope
and hence it cannot be used outside the actions.

@code{REJECT} is useful when overlapping subsequences of the input are to be
recognized as tokens.  This is illustrated by the following scanner which
outputs all the prefixes of the words in its input, where a word is a
maximal sequence not containing tab, blank or newline.

@example
@group
%%
[^\t \n]+       printf("%s\n", yytext); REJECT;
.|\n
@end group
@end example

@code{yytext} is a @code{NUL}-terminated C-string giving the text of the
current lexeme (@pxref{Lexeme Text}).  Given the word @samp{abc} the first
pattern will match; its action will first output @samp{abc} on a separate
line.  When the @code{REJECT} action is executed, there is no other pattern
to match @samp{abc}. Hence it will try to match a prefix of @samp{abc}:
@samp{ab} matches the first pattern.  So it will again output @samp{ab} and
execute a @code{REJECT} action.  This @code{REJECT} results again in a match
with the first pattern and an output of @samp{a}.  The subsequent
@code{REJECT} matches the second pattern with @samp{a} but no action is
taken.  Hence the output will be:

@example
@group
abc
ab
a
@end group
@end example

@noindent
The @code{REJECT} action is not inordinately expensive.


@node Character Count, Current Line Number, Rejecting to the Next Match, Scanner Input
@section Current Character Count: @code{YY_CHAR_NUM} 
@cindex Character count
@cindex File position
@findex YY_CHAR_NUM
The macro @code{YY_CHAR_NUM} returns the number of characters read by the
scanner from the current file or memory buffer upto the start of the current
@code{yytext}.  The position does not include any of the characters of
@code{yytext}.  The returned position is zero-origin: hence the character
just after @code{yytext} will be at absolute position @code{YY_CHAR_NUM +
yyleng} in the file or in-memory buffer.

The value returned by @code{YY_CHAR_NUM} will not be correct if the
@code{unput} (@pxref{Unput}) action is used.

Many scanning applications require tracking the current line and column
number. If newlines can occur within other tokens, then the
@samp{--yylineno} option provides suitable facilities (@pxref{Current Line
Number}).  If newlines cannot occur within other tokens, then the
recommended method is illustrated by the following code fragment which shows
how YY_CHAR_NUM can be used to compute the current column number within a
line.

@example
@group
%@{
  int lineStartPos= 0;  /* Starting YY_CHAR_NUM for a line. */
  int lineNum= 1;       /* 1 + # of '\n's seen so far. */
#define COL_NUM         (YY_CHAR_NUM - lineStartPos)
%@}
%%
\n                 @{ lineStartPos= YY_CHAR_NUM + 1;  lineNum++;
                     @i{`Other actions for a newline.'}
                   @}
@end group
@end example

The macro @code{COL_NUM} can now be used within other actions to access the
column number.  

@node Current Line Number, Current Column Number, Character Count, Scanner Input
@section Current Line Number: @code{yylineno}

If the @samp{--yylineno} option is specified, when the scanner is
generated, then the current line number (1-origin) is maintained in the
variable whose default name is @code{yylineno} and declaration @code{int
yylineno}.  Like all other variable names, the name of this variable can
be changed to an arbitrary name by defining the macro @code{YY_LINENO}
to the new name.  Alternatively, the prefix used for the name can be
changed by using the @samp{--prefix} option (@pxref{Variable Names}).

Unlike the implementation of @code{yylineno} by other scanner
generators, a Zlex generated scanner does not test every character to
see if it is a newline.  It does these tests only when it is known that a
lexeme contains or is followed by a newline character: this information
is obtained using a hidden intra-token pattern (@pxref{Using Intra-Token
Patterns}).  Hence scanning of lexemes which do not contain newlines is
not slowed down except for a simple test of a flag which is performed on
once per action rather than once per character.

Since a hidden intra-token pattern @code{+\n} (@pxref{Using Intra-Token
Patterns} is used to implement the @code{yylineno} feature, this feature
will not work if the user specifies a intra-token pattern which overlaps
with the hidden pattern.  It will also not work correctly if the
programmer uses @code{unput} to put newline characters into the buffer.

This feature was added to Zlex for backward compatibility with an
undocumented feature of @code{lex} (documented in @code{flex}).  When
newlines cannot occur within other tokens it is usually not necessary to
use this feature as it is easy enough for the programmer to update a
line number counter whenever a pattern containing a newline character is
matched (@pxref{Character Count}).

@node Current Column Number, Querying Beginning of Line, Current Line Number, Scanner Input
@section Current Column Number

If the @samp{--yylineno} option is specified, then the macro
@code{YY_COL_NUM} returns the 0-origin column number within the current
line.  If newlines cannot occur within other tokens, see the example in
@ref{Character Count}, for the recommended way to track this
information.

The current column number is computed only when the Zlex programmer uses
the @code{YY_COL_NUM} macro.  The implementation uses a hidden
intra-token pattern @code{+\n} (@pxref{Using Intra-Token Patterns} to
implement the @code{YY_COL_NUM} macro.  Hence this feature will not work
if the user specifies a intra-token pattern which overlaps with the
hidden pattern.  It will also not work correctly if the programmer uses
@code{unput} to put newline characters into the buffer.

@node Querying Beginning of Line, Setting Beginning of Line, Current Column Number, Scanner Input
@section Querying Beginning of Line: @code{YY_AT_BOL}
@cindex Beginning of line, querying
@findex YY_AT_BOL
The macro call @code{YY_AT_BOL()} returns non-zero if the next token to be
matched can match beginning-of-line patterns having a @samp{^} anchor.

Note that this macro is provided only when there is at least one pattern
which uses the beginning-of-line @samp{^} anchor.


@node Setting Beginning of Line,  , Querying Beginning of Line, Scanner Input
@section Setting Beginning of Line: @code{yy_set_bol}
@cindex Beginning of line, controlling
@findex yy_set_bol
@findex YY_SET_BOL
The macro @code{yy_set_bol(@var{v})} sets the beginning-of-line condition
for the next pattern to true if @var{v} is non-zero; false if @var{v} is
zero.  When the beginning-of-line condition is set true, the next pattern
can match beginning-of-line patterns having a @samp{^} anchor; when it is
set false, the next pattern cannot match beginning-of-line patterns having a
@samp{^} anchor.

The canonical macro name @code{YY_SET_BOL} can be used synonymously with
@code{yy_set_bol}.  

Note that these macros are provided only when there is at least one pattern
which uses the beginning-of-line @samp{^} anchor.

@node Scanner Output, Buffer Management, Scanner Input, top
@chapter Output in a Zlex Scanner

Limited facilities are provided in a Zlex scanner for echoing the current
lexeme to a @code{FILE} pointer with default name @code{yyout}

@menu
* Output File Pointer::         @code{FILE} pointer to output stream. 
* Echoing the Current Lexeme::  Echoing current token text.
@end menu

@node Output File Pointer, Echoing the Current Lexeme, Scanner Output, Scanner Output
@section Output File Pointer: @code{yyout}
@cindex Output @code{FILE}
@vindex yyout
@findex YY_OUT
@code{yyout} is the default name of the variable with declaration
@code{FILE *yyout} which Zlex uses to echo the current lexeme
(@pxref{Echoing the Current Lexeme}).  Like all other variable names,
the name of this variable can be changed to an arbitrary name by
defining the macro @code{YY_OUT} to the new name.  Alternatively, the
prefix used for the name can be changed by using the @samp{--prefix}
option (@pxref{Variable Names}).

When the scanner function is first entered it initializes @code{yyout} to
@code{stdout}, unless the user has already initialized it to a non-@code{NULL}
@code{FILE} pointer.  So if the generated scanner should echo to a file
other than the standard output, the programmer need only initialize
@code{yyout} to a suitable @code{FILE} pointer.

@node Echoing the Current Lexeme,  , Output File Pointer, Scanner Output
@section Echoing Lexeme Text: @code{ECHO}
@cindex Echoing yytext
@findex ECHO
@findex YY_ECHO
The @code{ECHO} macro echoes the current lexeme to @code{yyout}.  The
canonical name @code{YY_ECHO} can also be used.

The following example removes all lines starting with @key{#}.

@example
@group
%%
^#.*\n          |
^#.*            /* @r{No action: don't echo.} */
.*\n            |
.*              ECHO;
@end group
@end example

The patterns @code{^#.*} and @code{.*} take care of processing the
last line in the file when it does not end with a newline.

@node Buffer Management, Using Intra-Token Patterns, Scanner Output, top
@chapter Buffer Management
@cindex Buffers
For efficiency reasons, a Zlex scanner buffers its input.  Hence if the Zlex
programmer wishes to switch input to a new file, it is not sufficient to
merely change @code{yyin} (@pxref{Input File Pointer}), as the scanner will
continue reading from its previously buffered input.  It is necessary to
switch to a buffer for the new file.  Buffer management actions provide
facilities for doing this.

Buffers need not necessarily be associated with files.  It is possible to
create buffers whose contents are taken from a string or some other
in-memory structure.  When the scanner reaches the end of an in-memory
buffer, it does normal end-of-file processing.

Tokens are not allowed to span buffer boundaries.

@menu
* Buffer Type::                 Opaque pointer for buffers.
* Current Buffer::              Accessing the current buffer.
* Creating a Buffer::           Creating a buffer for a file.
* Deleting a Buffer::           Deleting a previously created buffer. 
* Flushing a Buffer::           Flushing contents of a buffer.
* In Memory Buffer::            Create buffer using memory area.
* Bytes Buffer::                Create buffer from arbitrary bytes.
* String Buffer::               Create buffer from a C-style string. 
* Switching Buffers::           Switching between buffers.
* Buffer Management Example::   File inclusion using buffers.
@end menu

@node Buffer Type, Current Buffer, Buffer Management, Buffer Management
@section The Buffer Type: @code{YY_BUFFER_STATE}
@cindex Buffer handle
@tindex YY_BUFFER_STATE
@tindex YYBufHandle
The handle used to refer to a buffer has the declaration:
@example
typedef void *YYBufHandle;
@end example
For compatibility with @code{flex}, the programmer can also refer to this
type using the macro @code{YY_BUFFER_STATE}.  This opaque type can be passed
to and returned from the buffer management actions.

@node Current Buffer, Creating a Buffer, Buffer Type, Buffer Management
@section The Current Buffer: @code{yy_current_buffer}
@cindex Buffer, current
@cindex Current buffer
@findex YY_CURRENT_BUFFER
@vindex yy_current_buffer
@code{yy_current_buffer} is the default name of a variable which
contains a @code{YY_BUFFER_STATE} handle to the current buffer.  Like
all other variable names, the name of this variable can be changed to an
arbitrary name by defining the macro @code{YY_CURRENT_BUFFER} to the new
name.  Alternatively, the prefix used for the name can be changed by
using the @samp{--prefix} option (@pxref{Variable Names}).

The user should never explicitly assign a value to this variable, but do so
only implicitly by calling the appropriate buffer management routine
(@pxref{Switching Buffers}).

@node Creating a Buffer, Deleting a Buffer, Current Buffer, Buffer Management
@section Creating a Buffer: @code{yy_create_buffer}
@cindex Buffer, creating from a file
@cindex Creating a buffer from a file
@findex yy_create_buffer
@findex YY_CREATE_BUFFER
The macro call @code{yy_create_buffer(f, s)} creates a buffer for
@code{FILE} pointer @code{f}, having space for at least @code{s} characters.
(The macro @code{YY_BUF_SIZE} contains a recommended value for @code{s}.)
The value returned is a @code{YY_BUFFER_STATE} (@pxref{Buffer Type}).

The canonical name @code{YY_CREATE_BUFFER} can also be used for this macro.
From files other than the Zlex source file, the library function with
prototype 

@example
@group
YY_BUFFER_STATE 
yyCreateBuffer(YYDataHandle d, FILE *f, yy_size_t s);
@end group
@end example
@noindent
can be used to create and initialize a buffer for the file with @code{FILE}
pointer f, having space for at least @code{s} characters.  It returns the
handle of the newly created buffer, aborting execution on error.

@node Deleting a Buffer, Flushing a Buffer, Creating a Buffer, Buffer Management
@section Deleting a Buffer: @code{yy_delete_buffer}
@cindex Buffer, deleting a
@cindex Deleting a buffer
@findex yy_delete_buffer
@findex YY_DELETE_BUFFER
The macro call @code{yy_delete_buffer(b)} deletes the buffer with
@code{YY_BUFFER_STATE b}.  @code{b} must have been previously returned by
one of the buffer creation actions.

The canonical name @code{YY_DELETE_BUFFER} can also be used for this macro.
From files other than the Zlex source file, the library function with
prototype 

@example
@group
void
yyDeleteBuffer(YYDataHandle d, YYBufHandle b);
@end group
@end example

@noindent
can be used to delete buffer with handle @code{b} for the scanner with
handle @code{d}.

@node Flushing a Buffer, In Memory Buffer, Deleting a Buffer, Buffer Management
@section Flushing a Buffer: @code{yy_flush_buffer}
@cindex Buffer, flushing a 
@cindex Flushing a buffer
@findex yy_flush_buffer
@findex YY_FLUSH_BUFFER
The macro call @code{yy_flush_buffer(b)} flushes the buffer with
@code{YY_BUFFER_STATE b}.  When the scanner subsequently tries to read a
character from the buffer, the buffer will be refreshed.  There is no
canonical name for the @code{yy_flush_buffer} macro as, for backwards
compatibility with @code{flex}, the name @code{YY_FLUSH_BUFFER} does something
somewhat different: specifically, it is used without any arguments to
specify an action to flush the @emph{current} buffer (equivalent to
@code{yy_flush_buffer(YY_CURRENT_BUFFER)}).

From files other than the Zlex source file, the library function with
prototype 

@example
@group
void 
yyFlushBuffer(YYDataHandle d, YY_BUFFER_STATE b);
@end group
@end example

@noindent
can be used to flush buffer @code{b} for the scanner whose internal state is
encapsulated in @code{d}.

@node In Memory Buffer, Bytes Buffer, Flushing a Buffer, Buffer Management
@section Creating a In-Memory Buffer: @code{yy_scan_buffer}
@cindex Buffer, Creating from memory data
@cindex Creating a buffer from memory data
@findex yy_scan_buffer
@findex YY_MEM_BUFFER
The macro @code{yy_scan_buffer(memBuf, len)} creates and returns a
@code{YY_BUFFER_STATE} which contains the contents of @code{char *memBuf}
having a total of @code{yy_size_t len} bytes.  @code{memBuf} is not copied:
hence the programmer should ensure that @code{memBuf} is retained until the
processing of the @code{YY_BUFFER_STATE} returned by @code{yy_scan_buffer}
is completed.  @code{memBuf} will be used when the newly created buffer is
scanned: in fact, @code{memBuf} may even be temporarily modified during the
course of scanning.

The last two bytes of @code{memBuf} must be @emph{sentinel} characters (the
sentinel character defaults to @code{'\0'} unless changed by the
@samp{--sentinel} option (@pxref{Options List})).  If this is not true, then a
@code{NULL} @code{YY_BUFFER_STATE} is returned.  These two sentinel
characters will not be scanned when the scanner switches to this buffer:
hence the characters which will be scanned will be @code{memBuf[0]} @dots{}
@code{memBuf[len - 3]} inclusive.

The canonical name @code{YY_MEM_BUFFER} can also be used for this macro.  

From files other than the Zlex source file, the library function with
prototype 

@example
@group
YY_BUFFER_STATE 
yyMemBuffer(YYDataHandle d, char *memBuf, yy_size_t len);
@end group
@end example

@noindent
can be used to create a memory buffer for the scanner whose state is
encapsulated in @code{d}, with the other arguments being as defined for the
macro.  It returns the @code{YY_BUFFER_STATE} handle for the created buffer;
@code{NULL} if @code{memBuf} does not have the two sentinel characters at
its end; it aborts with an error message if it cannot create the buffer
because it is out of memory.

It is important to realize that if the same memory area is used to create
multiple Zlex buffers, then each Zlex buffer must be deleted before a new
Zlex buffer is created from the same memory area.

The following function illustrates the use of in-memory buffers to paste
tokens together as is required by the @code{##} operator in a C
preprocessor.  We assume that a @code{Token} is a @code{struct} with two
fields: a small integer @code{tok} giving the token number, and another
small integer @code{id} which gives the text associated with the token.  We
also assume the existence of the following routines:

@table @code
@item getIDString(id)
Returns
the text associated with a @code{id}.

@item getIDLen(id)
Returns the
length of the text associated with a @code{id}.

@item MALLOC()
@itemx FREE() 
These are merely error-checking versions of the standard-library
@code{malloc()} and @code{free()} respectively.

@item error() 
Prints out error messages.

@item yylex()
The generated scanner function.  We assume that it is setup to return a
@code{Token} instead of simply a @code{int} (@pxref{Termination Return
Value}).

@end table
@example
Token
tokenPaste(Token token1, Token token2)
/* Paste tokens token1 and token2 together, returning resulting token.
 * Signal an error if the pasted token is not proper.
 */
@{
  const unsigned id1= token1.id;
  const unsigned id2= token2.id;
  const unsigned len1= getIDLen(id1);
  const unsigned len2= getIDLen(id2);
  const unsigned bufSize= len1 + len2 + 1 + 2; 	/* 1 '\n' + 2 sentinel chars. */
  enum @{ AUTO_BUF_SIZE= 100 @};
  char autoBuffer[AUTO_BUF_SIZE];
  char *const autoBuf= autoBuffer;
  char *const dynamicBuf= (bufSize <= AUTO_BUF_SIZE) ? NULL : MALLOC(bufSize);
  char *const *bufP= (dynamicBuf) ? &dynamicBuf : &autoBuf;
  Token tokenZ, eolToken;
  YY_BUFFER_STATE oldBuf= YY_CURRENT_BUFFER;
  YY_BUFFER_STATE pasteBuf;
  strncpy(*bufP, getIDString(id1), len1);
  strncpy(*bufP + len1, getIDString(id2), len2);
  *(*bufP + bufSize - 3)= '\n';
  *(*bufP + bufSize - 2)= *(*bufP + bufSize - 1)= '\0';
  pasteBuf= yy_scan_buffer(*bufP, bufSize);
  yy_switch_to_buffer(pasteBuf);
  tokenZ= yylex(); eolToken= yylex();
  if (eolToken.tok != '\n') @{
    error("Invalid token produced by ## pasting of `%s' and `%s'.",
	  getIDString(id1), getIDString(id2));
  @}
  yy_delete_buffer(pasteBuf);
  yy_switch_to_buffer(oldBuf);
  if (dynamicBuf) FREE(dynamicBuf);
  return tokenZ;  
@}
@end example
The function creates the in-memory buffer on the runtime stack if the
required amount of memory is smaller than a predetermined amount; otherwise
it creates the in-memory buffer on the heap.  It uses @code{bufP} to point
to the chosen buffer.  It remembers the original Zlex buffer in the
@code{YY_BUFFER_STATE} variable @code{oldBuf}.  It then uses the standard
library function @code{strncpy()} to copy the text of the tokens to be
catenated into the chosen buffer.  It terminates the copied text by a
@code{'\n'} followed by the two required @code{'\0'} sentinel characters.
It then creates a Zlex buffer using @code{yy_scan_buffer()}.  It switches to
the newly created buffer (@pxref{Switching Buffers}) and then reads two
tokens from it: it expects the first token to be the catenated token which
is desired, and the second token to be a @code{'\n'}.  It then deletes the
created Zlex buffer and switches back to the original Zlex buffer
@code{oldBuf}.  Finally, if the in-memory buffer was allocated on the heap
it frees it.

@node Bytes Buffer, String Buffer, In Memory Buffer, Buffer Management
@section Creating a Buffer from In-Memory Bytes: @code{yy_scan_bytes}
@cindex Buffer, Creating from bytes
@cindex Creating a buffer from bytes
@findex yy_scan_bytes
@findex YY_BYTES_BUFFER
The macro @code{yy_scan_bytes(bytes, len)} creates and returns a
@code{YY_BUFFER_STATE} which contains the contents of @code{char *bytes}
having a total of @code{yy_size_t len} bytes.  The contents of @code{bytes}
is copied into the newly created buffer.  @code{bytes} itself will not be
used at all when the newly created buffer is scanned and can be destroyed
once the buffer has been created.

The canonical name @code{YY_BYTES_BUFFER} can also be used for this macro.  

From files other than the Zlex source file, the library function with
prototype 

@example
@group
YY_BUFFER_STATE 
yyBytesBuffer(YYDataHandle d, char *bytes, yy_size_t len);
@end group
@end example

@noindent
can be used to create a memory buffer for the scanner whose state is
encapsulated in @code{d}, with the other arguments being as defined for the
macro.  It returns the @code{YY_BUFFER_STATE} handle for the created buffer,
aborting with an error message if it cannot create the buffer because it is
out of memory.

@node String Buffer, Switching Buffers, Bytes Buffer, Buffer Management
@section Creating a Buffer from a In-Memory String: @code{yy_scan_string}
@cindex Buffer, Creating from string
@cindex Creating a buffer from a string
@findex yy_scan_string
@findex YY_STRING_BUFFER
The macro @code{yy_scan_string(str)} creates and returns a
@code{YY_BUFFER_STATE} which contains the contents of the
@key{NUL}-terminated C-string @code{char *str} having a total of
@code{yy_size_t len} bytes (not counting the terminating @key{NUL}).  The
contents of @code{str} is copied into the newly created buffer.  @code{str}
itself will not be used at all when the newly created buffer is scanned
and can be destroyed once the buffer has been created.

The canonical name @code{YY_STRING_BUFFER} can also be used for this macro.  

From files other than the Zlex source file, the library function with
prototype 

@example
@group
YY_BUFFER_STATE 
yyStringBuffer(YYDataHandle d, char *str);
@end group
@end example

@noindent
can be used to create a memory buffer for the scanner whose state is
encapsulated in @code{d}, with the @code{str} argument as for the
macro.  It returns the @code{YY_BUFFER_STATE} handle for the created buffer,
aborting with an error message if it cannot create the buffer because it is
out of memory.

@node Switching Buffers, Buffer Management Example, String Buffer, Buffer Management
@section Switching Buffers: @code{yy_switch_to_buffer}
@cindex Buffer switching
@cindex Switching buffers
@findex yy_switch_to_buffer
@findex YY_SWITCH_TO_BUFFER
The macro @code{yy_switch_to_buffer(b)} sets up the scanner to scan from
the previously created buffer identied by the @code{YY_BUFFER_STATE
b}. The contents of either buffer are not affected.

The canonical name @code{YY_SWITCH_TO_BUFFER} can also be used for this macro.  

From files other than the Zlex source file, the library function with
prototype 

@example
@group
void
yyStringBuffer(YYDataHandle d, YY_BUFFER_STATE b);
@end group
@end example

@noindent
can be used to create a memory buffer for the scanner whose state is
encapsulated in @code{d}, with the @code{b} argument as for the
macro.

@code{yy_switch_to_buffer} should be the only way the Zlex programmer
changes the current buffer.

@node Buffer Management Example,  , Switching Buffers, Buffer Management
@section Buffer Management Example
@cindex Include file example
@cindex Buffers example
The following example illustrates the use of the buffer management routines
to implement a nested file inclusion facility similar to that of C.  A line
starting with the @key{#} character followed by the word @samp{include} and
a @var{file-name} is replaced by the contents of @var{file-name}.

@example
@group
%@{
enum @{ MAX_INCL_DEPTH= 3 @};

static YY_BUFFER_STATE inclStk[MAX_INCL_DEPTH];
static unsigned inclSP= 0;

static void includeFile(char *fName);

%@}

fileName        [0-9a-zA-Z./]+

%x INCLUDE
%%
^[\t ]*#[\t ]*include   BEGIN INCLUDE;
<INCLUDE>@{fileName@}     includeFile(yytext); BEGIN INITIAL;
<INCLUDE>[\t ]+         /* @r{No action.} */
<INCLUDE>\n             BEGIN INITIAL;
<<EOF>>                 @{ if (inclSP == 0) 
                            yyterminate();
                          else @{
                            yy_switch_to_buffer(inclStk[--inclSP]);
                            BEGIN INCLUDE;
                          @}
                        @}
%%

static void includeFile(char *fName) 
@{
  if (inclSP == MAX_INCL_DEPTH) @{
    fprintf(stderr, "Includes nested too deeply.\n");
    return;
  @}
  inclStk[inclSP++]= YY_CURRENT_BUFFER;
  yyin= fopen(fName, "r");
  if (!yyin) @{
    fprintf(stderr, "Could not open %s.\n", fName); exit(1);
  @}
  yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
@}
@end group
@end example

@node Using Intra-Token Patterns, End-of-File and Termination, Buffer Management, top
@chapter Using Intra-Token Patterns

Sometimes it is necessary to do pre-lexical processing on the characters
scanned by the generated scanner before they are tokenized by the scanner.
An example of pre-lexical processing would be mapping certain sequences of
characters into others.  The easiest way to do so is to intercept the input
to the scanner: Zlex provides a way for the Zlex programmer to do just that
by redefining the @code{YY_INPUT()} macro. @xref{Redefining the Input
Macro}. Though this is adequate for most situations, it is not appropriate
for all situations since Zlex buffers its input.  The following example
illustrates the problem.

ANSI-C requires that all occurrences of escaped newlines (a @samp{\}
followed by a newline) in the input be deleted.  It is required that this be
done before tokens be recognized: for example a @samp{/} followed by an
escaped newline followed immediately by a @samp{*} should be recognized as
the start of a comment.  This can be done relatively easily by defining
@code{YY_INPUT()} to read the C source file into a buffer which is then
processed to delete escaped newlines.  Unfortunately this does not allow the
scanner to keep track of the source line number of the current token for
proper reporting of error messages.  What is needed is to perform the
pre-lexical processing incrementally as each token is scanned.

Intra-token patterns allow this type of incremental pre-lexical processing.
When a @dfn{intra-token pattern} is recognized @emph{within} a token, the
scanning of the token is suspended and the action associated with
the intra-token pattern is executed.  Then the suspended scanning of
the token is resumed. Thus, the only effects of recognizing the intra-token
pattern are the possible side-effects (if any) of the intra-token action.

@menu
* Intra-Token Pattern Syntax::  How to specify intra-token patterns.
* Actions for Intra-Token Patterns::  Restrictions on actions within 
                                intra-token actions.
* Backing Up::                  A special intra-token action.
@end menu

@node Intra-Token Pattern Syntax, Actions for Intra-Token Patterns, Using Intra-Token Patterns, Using Intra-Token Patterns
@section Intra-Token Pattern Syntax

Syntactically, an intra-token pattern consist of the @samp{+} character
followed by a regular expression subject to the following restrictions:

@itemize @bullet

@item
The regular expression is restricted to
match only fixed length regular expressions (thus precluding the use of the
@samp{?} (optional), @samp{+} (one-or-more) or @samp{*} (closure) operators
among others). 

@item
Qualifying an intra-token pattern by start states is not
allowed.

@end itemize

For example, @code{+\\\n} is an intra-token pattern which matches an
escaped newline.

@node Actions for Intra-Token Patterns, Backing Up, Intra-Token Pattern Syntax, Using Intra-Token Patterns
@section Actions for Intra-Token Patterns

@code{yytext} and @code{yyleng} (@pxref{The Current Lexeme}) are
available as usual within intra-token pattern actions.  The special 
@code{YY_BACKUP} action (@pxref{Backing Up}) is also available within
intra-token pattern actions.  Since an intra-token pattern represents
a interrupted scan of a token, the action for an intra-token pattern are
subject to the following rather severe restrictions:

@itemize @bullet

@item
The effect of any other of Zlex's action facilities except those
explicitly mentioned above is undefined within an intra-token pattern
action.

@item
An intra-token pattern is not allowed to share its action with that of any
other pattern.  Hence the action associated with an intra-token pattern or
the pattern immediately before an intra-token pattern cannot be @samp{|}.

@item
An intra-token pattern action should not terminate by performing a
control transfer like a @code{return}.

@end itemize

@node Backing Up,  , Actions for Intra-Token Patterns, Using Intra-Token Patterns
@section Backing Up Within a Intra-Token Pattern: @code{YY_BACKUP}
@cindex Intra-token pattern actions
@findex YY_BACKUP

Intra-token patterns are intended for doing pre-lexical processing which
needs to be done incrementally during scanning.  It is expected that this
processing will usually involve translating the token matching the
intra-token pattern to another token and then continue scanning.  The
@code{YY_BACKUP} action is tailored for such processing.

The macro @code{YY_BACKUP(@var{len}, @var{string})} specifies an action to
be used only within actions for intra-pattern tokens.  The length @var{len}
must be no greater than the length of the intra-token pattern and
@var{string} should be a @key{NUL}-terminated C-string.  The effect of
@code{YY_BACKUP(@var{len}, @var{string})} is to backup the scanner automaton
over the last @var{len} characters of the intra-token pattern, replacing
those @var{len} characters by @var{string}. @code{YY_BACKUP} may perform 
a control transfer: hence it should not be followed by any code to which
control is expected to fall through after @code{YY_BACKUP}.

For example, to delete escaped newlines in a C-scanner, we could use
the following pattern-action pair.

@example
+\\\n           YY_BACKUP(2, "");
@end example

@node End-of-File and Termination, The Main Scanner Function, Using Intra-Token Patterns, top
@chapter End-of-File and Termination

The generated scanner normally terminates when an @code{EOF} is received on
the input stream.  This default action can be changed in two ways:

@enumerate
@item
An @code{EOF} on the input stream need not terminate the scanner provided
the Zlex programmer sets up the input to come from another source.
@item
A scanner can terminate before an @code{EOF} is received from the input
stream.
@end enumerate

@menu
* Wrapping Up::                 Wrapping up a scanner run.
* End-of-file Actions::         Actions for @code{<<EOF>>} patterns. 
* Terminating a Scanner::       Terminating before end-of-file.
* Restarting a Scanner::        Restarting a scanner after termination. 
@end menu

@node Wrapping Up, End-of-file Actions, End-of-File and Termination, End-of-File and Termination
@section Wrapping Up: @code{yywrap}
@findex yywrap
@findex YY_WRAP
A function whose default prototype is @code{int yywrap(void)} is called by
the scanner when it detects end-of-file on its current input stream
@code{yyin}.  If the function returns non-zero then the
scanner proceeds to wrap-up its processing; it processes its
@code{<<EOF>>} actions if any (@pxref{End of File Patterns}) and if these
actions do not change its flow of control, it returns @code{YY_EOF_OUT}
(which defaults to @code{0}) indicating an end-of-file token.

If the call to @code{yywrap} returns @code{0}, then the scanner assumes that
the function has set up @code{yyin} to continue scanning.  It does not
execute the actions associated with any @code{<<EOF>>} patterns but merely
continues scanning.

Like Zlex variable names, the name of this function can be changed to an
arbitrary name by defining the macro @code{YY_WRAP} to the new name.
Alternatively, the prefix used for the name can be changed by using the
@samp{--prefix} option (@pxref{Function Names}).

The Zlex library provides a @code{yywrap()} function which simply returns 
@code{1}.  

@node End-of-file Actions, Terminating a Scanner, Wrapping Up, End-of-File and Termination
@section @code{<<EOF>>} Pattern Actions
@cindex End of file actions
If the @code{yywrap} function (@pxref{Wrapping Up}) returns non-zero, then
the scanner executes the actions associated with its @code{<<EOF>>} actions
if any.  These actions provide another opportunity for the programmer to
reset the scanner so as to continue scanning.  The following points need to
be noted:

@itemize @bullet
@item 
@code{yytext} and @code{yyleng} are not defined for @code{<<EOF>>} patterns.
Hence the actions for @code{<<EOF>>} patterns should not refer to these
variables.

@item
If @code{yyin} is pointed to a new @code{FILE} pointer within an
@code{<<EOF>>} action, then scanning will continue.  For compatibility
with old versions of @code{flex}, the @code{YY_NEW_FILE} and
@code{YY_RESTART} actions (@pxref{Restarting a Scanner}) may be used
after resetting @code{yyin} but is not necessary.

@item
The scanner can switch to a new buffer by using a @code{yy_switch_to_buffer}
action (@pxref{Switching Buffers}).

@item
The scanner can execute a return statement.

@item
It can execute a @code{yyterminate()} action (@pxref{Terminating a
Scanner}).

@item
Control can simply fall off the end of the @code{<<EOF>>} action.  In that
case, the scanner will return to its caller with a @code{YY_EOF_OUT} (which
defaults to @code{YY_NULL}).
@end itemize

@node Terminating a Scanner, Restarting a Scanner, End-of-file Actions, End-of-File and Termination
@section Terminating a Scanner: @code{yyterminate}
@cindex Terminating the scanner
@cindex Scanner termination
@findex yyterminate
@findex YY_TERMINATE
@code{yyterminate()} terminates the scanner and returns a @code{YY_EOF_OUT}
(which defaults to 0) to the caller.  Subsequent calls to the scanner will
continue to return with @code{YY_EOF_OUT}, until a @code{yyrestart},
@code{YY_NEW_FILE} or @code{yy_switch_to_buffer} action is executed.

The canonical form @code{YY_TERMINATE()} can also be used instead.


@node Restarting a Scanner,  , Terminating a Scanner, End-of-File and Termination
@section Restarting a Scanner: @code{yyrestart}
@cindex Restarting the scanner
@cindex Scanner restart
@findex yyrestart
@findex YY_RESTART
The action @code{yyrestart(fileP)} restarts scanning, taking input from  the
file with the @code{stdio} @code{FILE} pointer @code{fileP}.  The current
contents of the Zlex buffer are discarded.  The canonical name
@code{YY_RESTART} can also be used instead.

@findex YY_NEW_FILE
If @code{yyin} has been pointed to a new file, then the action
@code{YY_NEW_FILE} (without any arguments) tells the scanner that a new file
has been setup in @code{yyin}.  @code{YY_NEW_FILE} is equivalent to
@code{yyrestart(yyin)}.

@node The Main Scanner Function, Debugging, End-of-File and Termination, top
@chapter The Main Scanner Function

The top-level scanner function in a Zlex scanner has default name
@code{yylex}.  The user can customize the name and declaration of the
function, as well as define macros to cause certain actions to be taken.

@menu
* Main Scanner Function::       Naming the main scanner function.
* Declaring the Scanner Function::  Declaring the main scanner
                                function. 
* Initialization::              Initialization within function.
* An Action for Every Pattern::  A pre-action for every pattern. 
* Separator Between Actions::   Controlling @code{break} within actions.
* Termination Return Value::    Value returned on termination.
* Pattern Numbers::             Accessing number of matched pattern.
@end menu

@node Main Scanner Function, Declaring the Scanner Function, The Main Scanner Function, The Main Scanner Function
@section The Main Scanner Function: @code{yylex}
@cindex Scanning function
@cindex @code{yylex}
@findex yylex
@findex yylex

The name of the main scanning function defaults to @code{yylex}, but
like other names, the name of this function can be changed to an
arbitrary name by defining the macro @code{YY_LEX} to the new name.
Alternatively, the prefix used for the name can be changed by using the
@samp{--prefix} option (@pxref{Function Names}).  Hence to change the
name of the main scanning function to @code{scan}, the programmer merely
need have the line

@example
#define YY_LEX scan
@end example
@noindent
in the C-code section of section 1 of the Zlex file.

@node Declaring the Scanner Function, Initialization, Main Scanner Function, The Main Scanner Function
@section Declaring the Scanner Function: @code{YY_DECL}
@cindex Scanner function declaration
@cindex Declaration of scanner function
@findex YY_DECL
The macro @code{YY_DECL} gives the default declaration of the scanner
function.  Its definition is equivalent to:

@example
@group
#ifndef YY_DECL
#define YY_DECL int YY_LEX(void)
#endif
@end group
@end example

@noindent
The programmer can change this declaration by suitably @samp{#define}ing
@code{YY_DECL} in the C-code section of section 1 of the Zlex file.  See
@ref{Termination Return Value} for how to use @code{YY_DECL} to declare a
scanner function which returns a @code{struct} rather than a @code{int}.

@node Initialization, An Action for Every Pattern, Declaring the Scanner Function, The Main Scanner Function
@section Initialization: @code{YY_USER_INIT} 
@cindex Initialization
@findex YY_USER_INIT
The macro @code{YY_USER_INIT} can be defined by the programmer to be code
which will be executed when the scanner first starts up, before the first
scan.  Its definition defaults to empty code.  It is useful for initializing
variables used by the programmer.  Before the first call to the main scanner
function, the only Zlex actions guaranteed to work are the buffer creation
and switching routines (@pxref{Buffer Management}).

The scanner's buffer is statically initialized to a special initialization
state.  If there is no buffer switching action before the first call to the
scanner function, then the scanner buffer will still be in this special
initialization state at the first call.  The first call to the scanner
checks whether the buffer is in this special initialization state: if it is,
it creates a new buffer corresponding to the current @code{yyin}; if it not,
then it assumes that the programmer has created and switched to a valid
buffer and uses that buffer without modification.  Note that the effect of
using such a special initialization buffer in subsequent scanner calls is
undefined.

@node An Action for Every Pattern, Separator Between Actions, Initialization, The Main Scanner Function
@section Specifying a Pre-Action for every Pattern: @code{YY_USER_ACTION} 
@cindex User action
@findex YY_USER_ACTION 
The macro @code{YY_USER_ACTION} can be defined by the programmer to be code
which will always be executed before any matched rule action.  Its
definition defaults to empty code.

@node Separator Between Actions, Termination Return Value, An Action for Every Pattern, The Main Scanner Function
@section Specifying the Separator Between Actions: @code{YY_BREAK}
@findex YY_BREAK
The user actions specified in the Zlex file are copied into the main scanner
function as part of a switch statement.  The macro @code{YY_BREAK} is used
to separate the actions within the @code{switch} statement.  Its definition
defaults to @code{break}.

Redefining this macro appears to be of limited utility.  This feature is
included for compatibility with @code{flex}.  The rationale for
including this feature in @code{flex} was to prevent unreachable
statement warnings when a user action naturally terminates with a
control transfer like a @code{return}.  With this feature, the user can
define @code{YY_BREAK} to be empty while ensuring that every action
terminates with a transfer of control (inserting explicit breaks, if
necessary), thus avoiding the warnings.

@node Termination Return Value, Pattern Numbers, Separator Between Actions, The Main Scanner Function
@section Return Value on Termination: @code{YY_EOF_OUT} 
@cindex End of file return value
@findex YY_EOF_OUT

The macro YY_EOF_OUT specifies the value to be returned by the scanner on
end-of-file after @code{yywrap} returns 1 and the @code{<<EOF>>} actions (if
any) do not reset the input @code{yyin}.  Its definition defaults to
@code{YY_NULL} (@pxref{The Null Value}) but it can be redefined by the
programmer in section 1 of the Zlex file.

For example, by using @code{YY_DECL} (@pxref{Declaring the Scanner
Function}) macro, it is possible for the Zlex programmer to make the scanner
return a @code{struct} rather than a @code{int}.  If this is done, then the
value returned on end-of-file must also be a suitable @code{struct}: this
can be achieved by defining @code{YY_EOF_OUT} to a call of a suitable
function returning the suitable @code{struct}.  Appropriate definitions and
declarations are shown below:

@example
%@{

/* Define the type returned by the scanner. */
typedef struct @{
  @dots{}
@} Token;

/* Declare a function returning a special EOF Token struct. */
Token eofToken(void);       

/* Scanner declaration. */
#define YY_DECL Token YY_LEX(void)

/* EOF return value definition. */
#define YY_EOF_OUT eofToken()
  
%@}
@end example


@node Pattern Numbers,  , Termination Return Value, The Main Scanner Function
@section Pattern Numbers: @code{yy_act} and @code{YY_NUM_RULES}

@vindex yy_act
@vindex YY_NUM_RULES

Within the actions, the macro @code{yy_act} refers to the pattern number
which is currently being matched where the patterns from the Zlex source
file are numbered starting at 1.  The macro @code{YY_NUM_RULES} refers to
the total number of patterns for which actions exist in the generated
scanner; this will usually be greater than the number of patterns explicitly
specified by the programmer in the Zlex source file, since Zlex uses several
pseudo-actions for its own purposes.

@node Debugging, Multiple Scanners, The Main Scanner Function, top
@chapter Debugging and Errors
@cindex Debugging
Limited facilities are provided for debugging Zlex programs.  A C macro and
a variable control whether debugging messages are output as a pattern is
recognized.  In addition, it is also possible to obtain a more detailed
trace detailing the action of the scanner as each individual character is
scanned.

@menu
* Debugging Control::           A variable and macro which controls
                                debugging.
* Debugging Example::           Debugging example using @code{REJECT}. 
* Scanner Tracing::             Detailed trace of scanner actions.
* Errors::                      Runtime error message control.
@end menu

@node Debugging Control, Debugging Example, Debugging, Debugging
@section Debugging Control
@findex YYDEBUG

Several equivalent macros and a single variable control whether debugging
messages are output to @code{stderr} as patterns are matched.  

If the @samp{--debug} option is specified when the scanner file is generated
(@pxref{Options List}), or if the macro @code{YYDEBUG} is defined when the
generated scanner file is compiled, and if at runtime, the variable with
default name @code{yy_Zlex_debug} has a non-zero value, then messages are
printed on @code{stderr} as patterns are matched.  Where applicable, the
printed messages include the source file name and line number of the matched
pattern, as well as the contents of @code{yytext}.  The format is similar to
that of compiler error messages of popular compilers like @code{gcc}; this
makes it possible to use tools like @code{emacs} @code{compile-mode} to
point to the appropriate pattern in the source file. @xref{Compilation, ,
Compiling within emacs, emacs, The GNU Emacs Manual}.

@findex YY_ZL_DEBUG
The macro @code{YY_ZL_DEBUG} is equivalent to @code{YYDEBUG}.  This
alternate name is useful when a project uses both Zlex as well as a parser
generated by a member of the @code{yacc}-family of parser generators.  The
reason is that @code{YYDEBUG} is also used for similar purposes by such
parser-generators; if the option @code{-DYYDEBUG} is passed as a C-compiler
option to a @file{Makefile} for the project, both the generated Zlex scanner
as well as the parser will run in debug-mode, resulting in rather confusing
output. 

@vindex yy_zlex_debug
The @code{extern} variable with default name @code{yy_zlex_debug} allows
debugging messages to be turned on and off dynamically: messages are printed
only when the variable has a non-zero value.  When debugging is turned on
as described above, the variable is declared in the generated scanner and
initialized to @code{1}: hence message printing is initially enabled.

@findex YY_ZLEX_DEBUG
Like all other variable names, the name of this variable can be changed
to an arbitrary name by defining the macro @code{YY_ZLEX_DEBUG} to the
new name.  Alternatively, the prefix used for the name can be changed by
using the @samp{--prefix} option (@pxref{Variable Names}).

@node Debugging Example, Scanner Tracing, Debugging Control, Debugging
@section A Debugging Example

Assume that the following scanner is defined in file @file{debug.l}.

@example
@group
 01 /* @r{Scanner which illustrates debugging messages.} */
 02 
 03 %option debug
 04 
 05 %%
 06 
 07 [[:digit:]]+                |
 08 [[:alpha:]]+                REJECT;
 09 .|\n
@end group
@end example

If the generated scanner is compiled and run on the input consisting of the
single line

@example
ab12
@end example

@noindent
the following output is produced on @code{stderr}.

@example
@group
debug.l:8: yytext= `ab'.
debug.l:8: yytext= `a'.
debug.l:9: yytext= `a'.
debug.l:8: yytext= `b'.
debug.l:9: yytext= `b'.
debug.l:7: yytext= `12'.
debug.l:7: yytext= `1'.
debug.l:9: yytext= `1'.
debug.l:7: yytext= `2'.
debug.l:9: yytext= `2'.
debug.l:9: yytext= `
'.
--EOF.
@end group
@end example

@node Scanner Tracing, Errors, Debugging Example, Debugging
@section Scanner Tracing
@findex YYTRACE
If the scanner is compiled with the C macro @code{YYTRACE} @code{#define}d,
then when the scanner is run it provides a detailed trace showing the action
it takes at every character it scans.  The trace shows the transitions
of the underlying finite automaton.  To decipher this trace, it is
necessary to have compiled the scanner using the @samp{--trace} option
(@pxref{Options List}).  This is useful mainly for maintaining Zlex.

@node Errors,  , Scanner Tracing, Debugging
@section Runtime Errors: @code{yyerr}

It is possible for Zlex to encounter runtime errors under several
conditions: 

@itemize @bullet
@item
Dynamic memory allocation fails.

@item
An error occurs while reading an input file.

@item
The programmer attempts to access an empty start state stack.

@item
The programmer attempts to switch to a @code{NULL} buffer.

@item
The scanner encounters a character which is not matched by any pattern and
the @code{--suppress-default} option (@pxref{Options List}) has been specified. 
@end itemize

When a runtime error is encountered, the generated scanner writes a message
on the @code{FILE} pointer @code{yyerr} and terminates execution of the
program.  

@vindex yyerr
@findex YY_ERR
Like all other variable names, the name of this variable can be changed
to an arbitrary name by defining the macro @code{YY_ERR} to the
new name.  Alternatively, the prefix used for the name can be changed by
using the @samp{--prefix} option (@pxref{Variable Names}).

When the scanner function is first entered it initializes @code{yyerr} to
@code{stderr}, unless the programmer has already initialized it to a
non-@code{NULL} @code{FILE} pointer.  So if the generated scanner should
output error messages to a file other than the standard error, the
programmer need only initialize @code{yyerr} to a suitable @code{FILE}
pointer.

@findex YY_PROGRAM_NAME
All error messages are preceeded by the string which is the value of the
macro @code{YY_PROGRAM_NAME} which defaults to @code{"Zlex scanner"}.  This
macro can be redefined by the programmer in section 1 of the Zlex source file.


@node Multiple Scanners, Invoking Zlex, Debugging, top
@chapter Multiple Scanners

Sometimes it is necessary to include multiple scanners in a program.  For
example, an application may need one scanner to scan a data file and another
scanner to scan interactive user input.  

Most of the global objects used by a generated scanner are declared
@code{static}.  Hence their names are local to the generated C file.  Since
different scanners are generated in different C files, the semantics of C
preclude the possibility of a clash between the @code{static} names used in
different scanners.  However there will be a link-time clash between the
@code{extern} names used for global objects declared in different scanners.
To circumvent this problem, Zlex allows the programmer to choose the names
for the @code{extern} objects using one of the following schemes:

@enumerate
@item
Using the
@samp{--prefix} option (@pxref{Options List}).  This is the simpler alternative.

@item
Defining macros giving the name of each @code{extern} object.
@end enumerate

@menu
* Prefix Option::               Controlling prefix of names.
* Redefining Name Macros::      Giving an arbitrary name to a scanner 
                                object.
* Renaming Example::            Example which uses both methods.
@end menu

@node Prefix Option, Redefining Name Macros, Multiple Scanners, Multiple Scanners
@section Prefix Option
By default the name of each @code{extern} scanner object starts with the
prefix @samp{yy}.  This prefix can be changed by using the @samp{--prefix}
option (@pxref{Options List}).  The names which are affected are:

@table @code
@item yy_current_buffer 
@xref{Current Buffer}.
@item yy_Zlex_debug 
@xref{Debugging Control}.
@item yydataP 
@xref{Scanner State}.
@item yyerr 
@xref{Errors}.
@item yyin 
@xref{Input File Pointer}.
@item yyleng 
@xref{Lexeme Length}.
@item yylex 
@xref{Main Scanner Function}.
@item yylineno 
@xref{Current Line Number}.
@item yyout 
@xref{Output File Pointer}.
@item yytext 
@xref{Lexeme Text}.
@item yywrap 
@xref{Wrapping Up}.
@end table

@node Redefining Name Macros, Renaming Example, Prefix Option, Multiple Scanners
@section Redefining Name Macros
Another method to ensure that the names of @code{extern} objects do not
clash between multiple scanners is to redefine the macros which specify the
names of these objects.  This should be done in a C-code section in section
1 of the Zlex file.  The macros and the objects they name are:

@table @code
@item YY_CURRENT_BUFFER 
Names @code{yy_current_buffer} (@pxref{Current Buffer}).
@item YY_DATA_P 
Names @code{yydataP} (@pxref{Scanner State}).
@item YY_ERR
Names @code{yyerr} (@pxref{Errors}).
@item YY_IN 
Names @code{yyin} (@pxref{Input File Pointer}).
@item YY_LENG 
Names @code{yyleng} (@pxref{Lexeme Length}).
@item YY_LEX 
Names @code{yylex} (@pxref{Main Scanner Function}).
@item YY_LINENO 
Names @code{yylineno} (@pxref{Current Line Number}).
@item YY_OUT 
Names @code{yyout} (@pxref{Output File Pointer}).
@item YY_TEXT 
Names @code{yytext} (@pxref{Lexeme Text}).
@item YY_WRAP 
Names @code{yywrap} (@pxref{Wrapping Up}).
@item YY_ZLEX_DEBUG 
Names @code{yy_Zlex_debug} (@pxref{Debugging Control}).
@end table

The generated scanner sets these macros to their default values (the default
values factor in the @samp{--prefix} option if it has been specified) only
if they have not already been defined in section 1 of the Zlex file.  Hence
the Zlex programmer can easily make the scanner use different external
names, by simply defining these macros to suitable names in section 1 of the
Zlex file.

@node Renaming Example,  , Redefining Name Macros, Multiple Scanners
@section Renaming Example
For example, to build a scanner which uses the names @code{yylex1},
@code{yytext1}, @code{yyleng1}, @code{yyin1}, @code{yyout1} for some of the
@code{extern} objects, section 1 of the Zlex file would contain the
following @code{#define}'s:

@example
@group
%@{

#define YY_LEX  yylex1
#define YY_TEXT yytext1
#define YY_LENG yyleng1
#define YY_IN   yyin1
#define YY_OUT  yyout1

%@}
@end group
@end example

@noindent
The rest of the program would access this generated scanner as follows: The
main scanning function would be called as @code{yylex1()}.  The lexeme text
and length of the current token would be found in @code{yytext1} and
@code{yyleng1}.  The @code{FILE} pointers @code{yyin1} and @code{yyout1}
would be used for the input and output files of the generated scanner.  The
function @code{yywrap()} will be called on end-of-file; this will be the
@code{yywrap()} provided by the Zlex library, unless the Zlex programmer
defines one elsewhere in the program.

@node Invoking Zlex, Efficiency, Multiple Scanners, top
@chapter Invoking Zlex

The command line needed to invoke Zlex has the format:

@example
zlex [@var{Options List}] @var{lex-file} [@var{lex-file}...]
@end example

@noindent

@itemize @bullet

@item
If no @var{lex-file}s are specified on
the command line and the @samp{--lex-compat} option is not specified, then a
help message is printed on the standard output.  

@item
If no @var{lex-file}s are specified on the command line and the
@samp{--lex-compat} option is specified, then Zlex reads the source file
from its standard input.

@item
If multiple @var{lex-files}s are specified, then their concatenation is
treated as a single logical file.

@item
A @var{lex-file} specified by the single character @samp{-} stands for the
standard input.

@end itemize

@menu
* Option Conventions::          
* Option Sources::              
* Options::                     
* Data Search List::            
@end menu

@node Option Conventions, Option Sources, Invoking Zlex, Invoking Zlex
@section Option Conventions

A word which constitutes a command-line argument has two possible types: it
is a @dfn{option word} if it begin with a @samp{-} or @samp{--} (with
certain exceptions noted below), or if it follows an option word which
requires an argument.  Otherwise it is a @dfn{non-option word}.  An option
word specifies the value of a Zlex option; a non-option word specifies a
file name.

@itemize @bullet
@item
Options with short single character names must begin with a single @samp{-}.

@item
Options with long multiple-character names must begin with @samp{--}.  The
name can consists of any alphanumeric characters along with @samp{-} and
@samp{_} characters.

@item
When a option is specified using a long name, it is sufficient to specify an
unambiguous prefix of its name.

@item
If an option has a value which must be one of several prespecified values,
then it is sufficient to specify an unambiguous prefix of the value, in a
manner similar to long option names.

@item
It is possible to specify an option value in the same word as the option
name.  For short option names, there should not be any intervening
characters between the short name and the value.  For long option names, the
long name should be separated from the value using a single @samp{=}
character. 

@item
If an option has an @emph{optional} value, then the value must be provided
in the same word as the option name, as outlined above.

@item
If an option has a @emph{required} value, then the value may be provided in
the same word as the option name as outlined above, or it may be
provided in the next word.  In the latter case, the entire next word is
taken to be the value (even if it looks like an option starting with
@samp{-} or @samp{--}).

@item
Short names for multiple options which are not allowed to have any values
may be combined into a single word.  For example, if the options @samp{-l}
and @samp{-7} are not allowed to have any values, then instead of specifying
them using two words as @samp{-l -7}, they can be specified using a single
word @samp{-l7}.

@item
If an option is given two incompatible values, then the option which is
specified later dominates.

@item
If the option consisting simply of the two characters @samp{--} is
specified, then all the remaining words on the command line will not be
treated as options irrespective of whether they start with @samp{-} or
@samp{--}.  This makes it possible to specify file names starting with a
@samp{-}.

@item
Option words and non-option words may be arbitrarily interspersed.

@item
Command-line options always override the options specified elsewhere
(@pxref{Option Sources}).

@end itemize

@node Option Sources, Options, Option Conventions, Invoking Zlex
@section Option Sources

Besides the command-line, Zlex can read its options from several different
sources.  In order of increasing priority these sources are the following:

@itemize @bullet

@item
The file @file{zlex.opt}.  The file should contain only option names and
values separated by whitespace (newline counts as whitespace).  In addition
it may contain comments enclosed within @samp{/*} and @samp{*/}.  The file
is searched for using Zlex's search list (@pxref{Data Search List}).

The use of this file for setting defaults, makes it possible for a site to
setup default options for Zlex different from its builtin defaults.  It also
makes it easy to drop Zlex into a GUI toolset where options are set using a
graphical user interface.

@item
The environment variable @code{ZLEX_OPTIONS}.  If this variable is set, then
its value should contain only options and option values separated by
whitespace as on the command-line.  The procedure for setting environment
variables depends on the system you are using: under the UNIX shell
@code{csh} the @code{setenv} command can be used, under the MS-DOS
command-interpreter the @code{set} command can be used; under the UNIX shell
@code{sh} or @code{ksh} the @code{export} command can be used.

@item
It is also possible to specify options directly within the Zlex source file
using the @code{%option}, @code{%array} or @code{%pointer}
directives (@pxref{Declarations Section}).  

@end itemize

Options specified by the environment variable @code{ZLEX_OPTIONS} overrides
the options specified in the @file{zlex.opt} file.  Options specified in the
Zlex source file override options specified in the @file{zlex.opt} file or
@code{ZLEX_OPTIONS} environment variable.  Finally, command-line options
always override options specified by all other sources.

@node Options, Data Search List, Option Sources, Invoking Zlex
@section Options

Zlex provides a largely orthogonal set of options.  We can roughly classify
the options according to which aspect of Zlex's functionality they affect.

@menu
* Runtime Input Options::       
* Runtime Algorithm Options::   
* Code Scanner Options::        
* Table Scanner Options::       
* Miscellaneous Options::      
* Options List::                
@end menu

@node Runtime Input Options, Runtime Algorithm Options, Options, Options
@subsection Runtime Input Options

These options control how the generated Zlex scanner treats its input.

@table @code

@item --16-bit
Generate a 16-bit scanner which supports upto 65536 characters.  It is the
programmers responsibility to ensure that all input characters have a
character code between 0 and 65535 inclusive.  This option should be used if
the generated scanner is to support Unicode characters.

@item --7-bit
@itemx -7
Generate a 7-bit scanner which supports upto 128 characters.  It is the
programmers responsibility to ensure that all input characters have
a character code between 0 and 127 inclusive.  

@item --8-bit
@itemx -8
Generate a 8-bit scanner which supports upto 256 characters.  It is the
programmers responsibility to ensure that all input characters have
a character code between 0 and 255 inclusive.  

@item --ignore-case[=1|0] 
@itemx -i[1|0]
@itemx --caseless[=1|0] 
@itemx --case-insensitive[=1|0]
Controls the case sensitivity of the generated scanner.  If the value of the
option is specified as 1, then the generated scanner will not distinguish
between upper-case and lower-case characters.  Note however, that the
generated scanner will retain the case of the characters constituting the
current lexeme in @code{yytext}.  If this option is not specified, then the
generated scanner will be case-sensitive.

@item --sentinel=CHAR-CODE 
@itemx -S CHAR-CODE
Use the character with decimal code @code{CHAR-CODE} as the sentinel
character.  Scanning the sentinel character is likely to be slower than
scanning non-sentinel characters; this option allows the programmer to
change the sentinel character to a character which may not occur frequently
in the scanner input.  If this option is not specified, then the sentinel
character defaults to the character whose code is 0.

@item --stdio[=1|0]
By default, the generated scanner uses the underlying systems @code{read()}
function to read its input.  If this option is specified, it uses a the
@code{stdio} @code{fread()} function instead.  It may be necessary to
specify this option if your system does not take kindly to mixing
@code{stdio} @code{FILE} descriptors with @code{read()}.  The generated
scanner may be somewhat slower, and its interactive operation may suffer,
depending on the implementation of the @code{fread()} function provided by
the @code{stdio} library.  This option will not have any effect if the
programmer has redefined the @code{YY_INPUT} macro (@pxref{Redefining the
Input Macro}).

@end table

@node Runtime Algorithm Options, Code Scanner Options, Runtime Input Options, Options
@subsection Runtime Algorithm Options

The options described in this section affect aspects of the algorithm used
by the generated scanner.  Options which affect scanner tables are described
in @ref{Table Scanner Options}.  Options which affect generated scanners
which minimize their use of tables are described in @ref{Code Scanner
Options}. 

@table @code

@item --array[=1|0]
Implement @code{yytext} as an array instead of the default pointer.  This
will usually lead to a slower scanner.

@item --backup-optimize[=1|0]
If value of this option is specified as 1, then the generated scanner
optimized for backing up.  This may slow down the scanning of normal
patterns somewhat, but is likely to speedup the scanning of patterns which
require the scanner to backup.  This option should be used only if the
scanner's patterns require a lot of backing up, or if the scanner makes
heavy use of @code{REJECT}.  By default, backup-optimization is off.
@xref{Efficiency}. 

@item --default-action echo|error|fatal|ignore
This option controls the action of the generated scanner if it encounters a
input character which does not match any action.  The effects of the
different option values is described below:

@table @code

@item echo
The unmatched character is echoed to @code{yyout}.  This is the default.

@item error
An error message is output to @code{yyerr} and scanning continues.

@item fatal
An error message is output to @code{yyerr} and the program is terminated.

@item ignore
The unmatched character is simply ignored and scanning continues.

@end table

@item --equiv-classes[=1|0]
@itemx --ecs[=1|0] 
@itemx -E[1|0]    
It is often the case that the behavior of the generated scanner is identical
for certain classes of input characters.  When this option is specified,
Zlex partitions the input characters into equivalence classes such that the
behavior of the generated scanner is guaranteed to be identical for all the
characters in an equivalence class.  This option usually leads to large
space savings while paying only a small time cost and is on by default.

@item --prefix PREFIX
@itemx -P PREFIX
Use prefix as the prefix of certain global names in the generated scanner
(the default prefix is @samp{yy}).  @xref{Prefix Option}.

@item --reject[=1|0]            
Support REJECT actions in the generated scanner.  If @code{--reject=0} is
specified, then any @code{REJECT} action in the source file will result in a
compile-time errors when the generated scanner is compiled.  The default is
to support @code{REJECT} actions.

@item --yylineno[=1|0]
Maintain the current line number within the input in the global variable
@code{yylineno} (@pxref{Current Line Number}).  The default action is to not
support @code{yylineno}.  Using @code{yylineno} may lead to a somewhat
larger scanner but will not slow down the matching of patterns which do not
contain newlines.  It is the programmer's responsibility to suitably update
@code{yylineno} after scanner actions like @code{yyless} or @code{unput}
(@pxref{Modifying Input}).  yylineno is maintained on a per buffer basis and
is automatically saved and restored on a buffer switch.

@end table

@node Code Scanner Options, Table Scanner Options, Runtime Algorithm Options, Options
@subsection Code Scanner Options

Zlex supports the generation of code-scanners which do not use an explicit
scanner state or scan tables.  Instead these scanners use the program
counter to implicitly maintain the scanner state.  The current
implementation is disappointing: the generated scanners are fairly large but
are not appreciably faster.

Some limitatitions are imposed by the current implementation on code
scanners:

@itemize @bullet

@item
Code scanners cannot be built for any source file which contains a right
context pattern (@pxref{Right Context}) in which @emph{both} the regular
expression and the context match strings of indeterminate length.

@item
Code scanners cannot be built with backing up optimized using
@code{--backup-optimize=1}.  

@end itemize

When Zlex builds a code scanner it analyzes each state before deciding what
kind of code to build for a state.  The kinds of code built for a state are:

@table @asis
@item Linear Code
The code for the state is organized as a linear sequence of tests on the
current input character to find the next state.

@item Binary Code
The code for the state is organized as a binary search on the
current input character to find the next state.

@item Switch Code
The code for the state is organized as a switch on the current input
character to find the next state.

@end table

The options for generating code scanners allow the programmer to control the
parameters of the algorithm Zlex uses for choosing between the above code
alternatives:

@table @code

@item --code-scan[=1|0]   
This options generates a scanner with the DFA encoded in code instead of the
default encoding within scanner tables.

@item --bin-code-param N
A binary search is used for a state only when the number of input ranges (a
@dfn{range} is a sequence of consecutive input characters which have the
same successor state) is less than or equal to @code{N}.  Otherwise switch
code is used.  The default value of @code{N} is 16.

@item --lin-code-param N
A linear search is used for a state only when the number of successor states
is less than or equal to @code{N}.  Otherwise binary search or switch code
is used.  The default value of @code{N} is 4.

@item --transition-compress[=1|0]
This option compresses transitions from non-switch states in the scanner.
If the code for a successor state of a non-switch state has not already been
output, then the code for the successor is directly inserted within the code
for the predecessor state, rather than a transition to separate code for the
successor.

@end table

If both @code{--bin-code-param} and @code{--lin-code-param} are specified as
0, then only switch code is produced for all state transitions.  

In addition, if the compiler supports labels as first class objects and
provided a method to access the addresses of code labels, switches are
directly coded as a branch through a jump table.  For example, @code{gcc}
allows taking the address of a @var{label} using @code{&&@var{label}}.  
@xref{Labels as Values, ,Labels as Values, gcc, Using and Porting GNU cc}.
Specifically, the following macros can be used to support this:

@table @code

@item YY_LABEL_VARS
If this macro is defined, then the compiler allows access to the address of a
label. 


@item YY_LABEL_TYPEDEF(@var{type})
This macro should expand to a @code{typedef} used to define the @var{type}
used to represent the address of a code label.  For @code{gcc}, the default
definition is:

@example
#ifndef YY_LABEL_TYPEDEF /* How compiler declares vars containing labels. */
#define YY_LABEL_TYPEDEF(type)	typedef void *type
#endif
@end example

@item YY_LABEL_ADDR(@var{label})
This macro should expand to the address of @var{label}.  For @code{gcc}, the
default definition is:

@example
#ifndef YY_LABEL_ADDR	/* How compiler takes the address of a label. */
#define YY_LABEL_ADDR(label)	&&label
#endif
@end example


@end table


@node Table Scanner Options, Miscellaneous Options, Code Scanner Options, Options
@subsection Table Scanner Options

Zlex supports 3 options which control the details of the table compression
algorithm used and 3 options which control the type of table entries.  This
leads to a total of 9 different kinds of table accesses.

The options are the following:

@table @code

@item --compress @var{compression_algorithm}
This option controls the table compression algorithm used.  The permissible
values for @var{compression_algorithm} are shown below ordered from the
least compressed and fastest, to the most compressed and slowest:

@table @code 

@item none
No table compression is used. 

@item comb
A comb-compression algorithm is used to compress the tables.

@item iterative
A iterative comb-compression algorithm is used to compress the tables. 

@end table

@item --table @var{entry_type}
This option controls the type of table entries.  The permissible values for
@var{entry_type} are shown below ordered from the most memory intensive but
fastest, to the least memory intensive and slowest:

@table @code 

@item address
Each Table entry contain pre-computed addresses.  This avoids computing the
addresses at runtime.

@item difference
Each table entry contain the difference between the first entry
for the current state in the table and the first entry of the successor
state in the table.

@item state
Each table entry directly contains the number of the successor state.

@end table

@item --col-waste-percent @var{percent}
When @code{--compress=no} and @code{--table=state}, use a 2-dimensional
table with the # of columns a power of 2 if the percentage of wasted columns
is <= @var{percent}. The default value is 50%.

@item --align[=1|0] 
@itemx -a[1|0]   
By default, Zlex generated scanners do not explicitly specify the types for
various integral quantities.  Instead, Zlex sets up the generated scanner so
that when it is compiled, the compiler automatically chooses the smallest
integral type which can accomodate all possible values in the range of the
quantity.  This approach has the advantage that generated scanners are
conservative in their use of memory, as well as allowing a Zlex scanner to
be generated on one machine, while being compiled and executed on another
machine.  Unfortunately, such an approach can cause performance problems on
some architectures which may perform suboptimally on smaller integral types.
This option allows the programmer to force the types for all integral
quantities to be @code{int}.

@end table


@node Miscellaneous Options, Options List, Table Scanner Options, Options
@subsection Miscellaneous Options

This section describes miscellaneous Zlex options including options to print
out generated scanner statistics and options to turn on runtime tracing in
the generated scanner.

@table @code

@item --debug[=1|0]
@itemx -d[1|0]
Turn on debugging in the generated scanner.  A similar effect can be
obtained by defining @code{YYDEBUG} or @code{YY_ZL_DEBUG} when compiling the
scanner (@pxref{Debugging}).

@item --help
@itemx -h
Print out a help message giving a brief description of all the options, as
well as a description of Zlex's current environment.

@item --lex-compat
@itemx -l
Maximize lex compatibility (equivalent to @code{--array} @code{--yylineno}
@code{--reject}).  Also if no @var{lex-file}s are specified on the
command-line, then read the zlex source file from the standard input.

@item --line-dir
Output @code{#line} directives to the generated scanner (default).

@item  --output @var{filename}
@itemx -o @var{filename}
The generated scaner is written to @var{filename}.  By default, the name of
the generated scanner is @file{lex.yy.c}.

@item --to-stdout[=1|0] 
@itemx  -t[1|0]
Write the generated scanner to stdout, as opposed to the default action of
writing it to a file @file{lex.yy.c}.

@item --trace[=@var{trace_file}]
Run Zlex in trace mode, generating extensive output. This option is used
mainly for maintaining Zlex.  To use this option it is necessary that the C
preprocessor symbol @code{DO_TRACE} is defined when Zlex is built.  If
@var{trace_file} is omitted, then the trace is produced in a file whose name
is the basename of the first source file with its extension @samp{.l} (if any)
removed and extension @samp{.trc} added.

@item --verbose[=1|0] 
@itemx  -v[1|0]
Generate somewhat verbose statistics describing DFA on stdout. No statistics
are generated by default.

@item --version 
@itemx -V
Print the currrent version number of Zlex and exit.

@item --whitespace 
@itemx -w
Allow whitespace within lex patterns (@pxref{Whitespace Within Patterns}).


@end table


@node Options List,  , Miscellaneous Options, Options
@subsection Alphabetical Listing of all Options 

This section contains a short description of all options, sorted by long option
name.  Each option contains a reference to the section where it is discussed
in more detail.

@table @code

@include options.texi

@end table


@node Data Search List,  , Options, Invoking Zlex
@section Data Search List

When Zlex is run, it looks for certain data files (a skeleton file
@file{zlexskl.c} and an options file @file{zlex.opt} (@pxref{Option
Sources})) in certain standard directories (the skeleton file @emph{must}
exist, but the option file need not exist).  The search list specifying
these standard directories is fixed when Zlex is installed; it can be
printed out using Zlex's the @samp{--help} option (@pxref{Options List}).

The search list consists of a list of colon-separated directory names (the
directory names may or may not have terminating slashes) or environment
variables (starting with a @samp{$}).  If a directory name starts with a
@samp{$}, then the first (only the first) @samp{$} must be repeated.  An
empty component in the search list specifies the current directory.
Typically the search list contains the current directory.  
Also typically, the environment variable @code{ZLEX_SEARCH_PATH} is present
in the search list --- this causes Zlex to check if the variable is set in
the environment.  If it is, then Zlex expects it to specify a search list
which it recursively searches.

Typically, the search list compiled into Zlex looks something like the
following:

@example
$ZLEX_SEARCH_PATH:.:$HOME:/usr/local/share/zlex-@var{Version}
@end example

Since the search list will typically contain an environment variable like
@code{ZLEX_SEARCH_PATH} it is possible to change the set of standard
directories searched by Zlex even after installation by specifying a 
value for the variable.  For example, if with the above search list,
@code{ZLEX_SEARCH_PATH} is set to @code{/usr/lib:/usr/opt/lib}, then 
the effective search list becomes:

@example
/usr/lib:/usr/opt/lib:.:$HOME:/usr/local/share/zlex-@var{Version}
@end example

@node Efficiency, Distributing Zlex Scanners, Invoking Zlex, top
@chapter Efficiency

To produce a high performance scanner, the Zlex programmer needs to
understand the performance tradeoffs between different Zlex features.

@menu
* Patterns versus Actions::     Patterns preferred.
* Maximizing Token Length::     Match as much as possible at a time. 
* Backtracking::                Avoid backtracking.
* Generalized Right Context Efficiency::  Avoid possible quadratic
                                complexity. 
@end menu

@node Patterns versus Actions, Maximizing Token Length, Efficiency, Efficiency
@section Patterns versus Actions

The primary consideration used when designing Zlex was to maximize the
performance in the basic task of a scanner: recognizing tokens.  The
performance of special actions was a secondary consideration, except that
the presence of such actions was not allowed to impact the
performance of those parts of the scanner which did not depend on them.

These design decisions make it desirable for the Zlex programmer to use
patterns rather than actions whenever possible.  Many of the actions involve
a function call with its consequent overhead.  For example, it is
preferable to process comments using start states (@pxref{Start States
Example}), rather than processing them using @code{input} (@pxref{Direct
Input}). 

@node Maximizing Token Length, Backtracking, Patterns versus Actions, Efficiency
@section Maximizing Token Length

There is some overhead involved in setting up for scanning a token and
completing a token.  To minimize this overhead, it is preferable to maximize
the token length.  For example, when scanning through a comment
(@pxref{Start States Example}), it is preferable to process the comment a
line at a time, rather than a single character at a time.

@node Backtracking, Generalized Right Context Efficiency, Maximizing Token Length, Efficiency
@section Backtracking

Backtracking (both that caused during scanning due to overlapping patterns,
and that forced by explicit @code{REJECT}s) will naturally lead to somewhat
lower performance because characters will be scanned multiple times.  The
backtracking performance of Zlex is reasonably good and backtracking can be
used moderately within a scanner without impacting the overall performance
terribly.

@node Generalized Right Context Efficiency,  , Backtracking, Efficiency
@section Generalized Right Context Efficiency

In a generalized right context pattern of the form
@code{@var{RE}/@var{context}} the efficiency of the pattern matching depends
on the form of @var{RE} and @var{context}.  If the length of the string
which matches @var{RE} is @var{m}, and the length of the string matching
@var{context} is @var{n} then:

@itemize @bullet
@item
If either @var{RE} or @var{context} match only tokens of a fixed length,
then the total number of characters scanned will be @code{@var{m} +
@var{n}}.

@item
It neither @var{RE} or @var{context} match only tokens of a fixed length,
and there is no overlap between the end of tokens which match @var{RE} and
the beginning of tokens which match @var{context}, then the total number of
characters scanned will be @code{2 * (@var{m} + @var{n})}.

@item
It neither @var{RE} or @var{context} match only tokens of a fixed length,
and there is overlap between the end of tokens which match @var{RE} and the
beginning of tokens which match @var{context}, then in the worst-case, the
total number of characters scanned can be quadratic in the length of the
strings.  
@end itemize

@noindent
Hence generalized right context with the context overlapping the regular
expression should be avoided if possible.

@node Distributing Zlex Scanners, Bugs and Deficiencies, Efficiency, top
@chapter Distributing Zlex Scanners

When a program is completed and is ready for distribution, there are two
common distribution models used:

@table @asis
@item Binary Distribution
This is the model usually used for commercial software.  In that case, the
compiled Zlex generated scanner along with some of the compiled code from
the Zlex library will form part of the distributed executable.

@item Source Distribution
This is the usual model used for non-commercial software and is the
preferred model.  In that case, the distribution will need to include the
generated scanner file as well as some of the sources from the Zlex library.
@end table

@menu
* Distributing Library Sources::  How to package Zlex library sources. 
@end menu

@node Distributing Library Sources,  , Distributing Zlex Scanners, Distributing Zlex Scanners
@section Distributing Zlex Library Sources

@cindex Library Distribution
@cindex Distributing the library

There are two possibilities for distributing the Zlex library sources:

@enumerate
@item
Distribute the complete Zlex library.  In that case, the main
@file{Makefile} will need to be setup to compile the entire Zlex library and
link it into the final executable.

@item
Distribute only that part of the library which is really required by the
generated scanner.
@end enumerate

(1) is conceptually straightforward.  (2) is also straightforward, except
for figuring out which parts of the Zlex library are required by the
generated scanner.  Fortunately, the Zlex distribution comes with a shell
script which automates that task.

@vindex libZlexP.h
The script understands the interdependencies of the modules which constitute
the Zlex library.  When it is run, it analyzes the object file for the
generated scanner and produces a C file which contains all the source code
which will be required by the generated scanner.  The distribution should
include this C file as well as the file @file{libZlexp.h} which will be
found in the Zlex library source directory.

@findex mkLibSrc
The script is called @code{mklibsrc}; it usually resides in the Zlex library
source directory.  It can be invoked as:

@example
@var{SCRIPT_PATH}/mklibsrc @var{OFILE} [@var{LIB_SRC_DIR}] [@var{DEST_FILE}]
@end example

@noindent
where the parameters are defined as follows:
@table @var

@item SCRIPT_PATH
The path to the @code{mklibsrc} script. 

@item OFILE
The name of the object file for the generated scanner. 

@item LIB_SRC_DIR
The directory where the Zlex library sources reside --- it defaults to
@var{SCRIPT_PATH}.  

@item DEST_FILE
The name of the C file which should contain the generated sources --- it
defaults to @file{libsrc.c}.

@end table

For example, if we assume that the environmental variable @code{ZLEX_LIB_SRC}
contains the path to the Zlex library source directory, then the invocation:

@example
$ZLEX_LIB_SRC/mklibsrc scan.o
@end example

@noindent
will produce a file @file{libsrc.c} which contains all the source code
required from the Zlex library for the scanner object file @file{scan.o}.

It is unlikely but possible that the generated scanner can be compiled with
different options which affect which routines will be required from the Zlex
library.  In that case, it is necessary to repeat the above procedure for
each scanner object file produced using the different options.  The script
will accumulate the code in the specified C file.

The @code{mklibsrc} script is automatically generated by @code{m4} using a
skeletal script.  The interdependencies among the library modules are
automatically extracted using a @code{Perl} script.  The main portability
problem within the @code{mklibsrc} script is likely to be the command
@samp{nm -u} which is used to analyze the scanner object file.

@node Bugs and Deficiencies, Syntax of Zlex Programs, Distributing Zlex Scanners, top
@chapter Bugs and Deficiencies

Internal versions of the Zlex scanner generator have been used by me since
late 1993.  In 1996, it was used by about 20 students in a compiler course:
they uncoverd 2 bugs.  There has been a major rewrite since then.

@menu
* Suspicions::                  Possible problem areas in Zlex.
* Bug Reports::                 How to report bugs.        
@end menu

@node Suspicions, Bug Reports, Bugs and Deficiencies, Bugs and Deficiencies
@section Suspicions
Normally, when a program has been completed, one has a reasonable idea where
bugs might still lurk.  On that basis, for what they are worth, I present my
current suspicions:

@table @asis
@item The Scanner Generator
I feel fairly good about the code which actually generates scanners.  Under
normal error-free operation, the weakest area may be the code which
compresses the scanner tables.  However, the bugs most likely to manifest
themselves will probably be @code{assert}ion failures caused by an erroneous
Zlex source file.  In that case, the Zlex programmer can simply correct the
error in the Zlex source file and continue on with reasonable confidence
(after submitting a bug report of course).

@item The Runtime System
Unfortunately the runtime system (the generated scanner along with the Zlex
library) is rather complex.  Because of the need for backward compatibility,
it has many poorly integrated features.  Bugs probably lurk within the
complexity and in the interactions among the features.

@end table

@node Bug Reports,  , Suspicions, Bugs and Deficiencies
@section Bug Reports

First you will need to be sure that you have found a Zlex bug:

@itemize @bullet

@item
If when running the Zlex scanner generator, it bombs with a assertion
failure or a core dump, you can be sure that you have uncovered a bug.

@item
If when running a Zlex generated scanner, it bombs or does not do what you
intended it to do, it is much more difficult to be sure whether the problem
is within the Zlex runtime system or in your code.  If it bombs within a
Zlex library routine, make sure that you called it with the proper
parameters.  If it bombs within the main scanner function, make sure that it
is not within your actions.

@end itemize

If you are sure that you have uncovered a bug, try to distil it down to a
test program which is as short as possible while still exhibiting the bug.
Record a log which exhibits the bug.  Make sure that you mention the version
of Zlex you are using in your bug report.

Bug reports can be mailed to:

@example
zdu@@acm.org
@end example


@node Syntax of Zlex Programs, Copying, Bugs and Deficiencies, top
@appendix Syntax of Zlex Programs

An informal description of the lexical and grammatical syntax of
Zlex programs follows:

@menu
* Tokens::                      Lexical syntax of Zlex tokens.
* Grammar::                     YACC grammar for Zlex.
@end menu

@node Tokens, Grammar, Syntax of Zlex Programs, Syntax of Zlex Programs
@section Tokens

This is an informal description of the lexical syntax of non-trivial
Zlex tokens.

@table @code
@item ACT_TOK 
A sequence of actions including C-brace actions, decorated brace actions,
indented actions, or a newline after a section 2 pattern.

@item CHAR_TOK
A character which is not a lex meta-character within its current context.

@item COLON_BEGIN_TOK
@code{"[:"}.

@item COLON_END_TOK
@code{":]"}.

@item EOF_PAT_TOK
@code{"<<EOF>>"}.

@item ID_TOK
An identifier.

@item LEX_DIR_TOK
A lex directive at the start of a line in section 1.

@item MACRO_TOK
A macro call within braces.

@item NEXT_ACT_TOK
@samp{|} action (which is not part of a pattern).

@item NL_TOK
A newline which terminates an option line.

@item NUM_TOK
A number which occurs within braces as a repetition count.

@item OPTION_LINE_TOK
The rest of the line after a @code{%option}.

@item OPTION_TOK
@code{^"%option"}.

@item SEC_TOK
@code{^"%%"}.

@item SS_ID_TOK
An identifier which is used as a start-state name.

@item STARTX_TOK
@code{^"%"[xX]} signalling the start of an exclusive start state declaration.

@item START_TOK
@code{^"%"[sS]} signalling the start of an inclusive start state declaration.

@item X_OPTION_TOK
@code{^("%array" | "%pointer")}.
@end table


@node Grammar,  , Tokens, Syntax of Zlex Programs
@section Grammar
This is a grammar for Zlex programs using a yacc-like notation.  This
grammar is a slightly massaged version of one extracted automatically from
the current implementation of Zlex.

@example
lexProgram
  : section1 SEC_TOK section2 
  ;
section1
  : options restSection1 
  | options 
  ;
options
  : nonEmptyOptions 
  | /* EMPTY */
  ;
nonEmptyOptions
  : optionLine 
  | nonEmptyOptions optionLine 
  ;
optionLine
  : OPTION_TOK OPTION_LINE_TOK NL_TOK 
  | X_OPTION_TOK NL_TOK 
  ;
restSection1
  : section1Line 
  | restSection1 section1Line 
  ;
section1Line
  : startDec 
  | def 
  | LEX_DIR_TOK OPTION_LINE_TOK NL_TOK 
  ;
startDec
  : START_TOK ssDefList 
  | STARTX_TOK ssDefList 
  ;
ssDefList
  : ssDefList SS_ID_TOK 
  | /* EMPTY */
  ;
def
  : ID_TOK regExp 
  | ID_TOK 
  ;
section2
  : ACT_TOK sec2Patterns 
  ;
sec2Patterns
  : sec2Patterns actPatterns 
  | /* EMPTY */
  ;
actPatterns
  : patternActions
  | '+' regExp ACT_TOK 
  ;
patternActions
  : pattern ACT_TOK
  | pattern NEXT_ACT_TOK patternActions
  ;
pattern
  : optSSList regExp optRightContext
  | optSSList '^' regExp optRightContext
  | optSSList rightContext
  | optSSList '^' rightContext
  | optSSList EOF_PAT_TOK
  ;
optRightContext
  : rightContext 
  | /* EMPTY */
  ;
rightContext
  : '$' 
  | '/' regExp 
  ;
optSSList
  : /* EMPTY */
  | '<' ssUseList '>' 
  ;
ssUseList
  : ssUseList ',' SS_ID_TOK 
  | SS_ID_TOK 
  ;
regExp
  : regExp '|' catRegExp 
  | catRegExp 
  ;
catRegExp
  : catRegExp postRegExp 
  | postRegExp 
  ;
postRegExp
  : postRegExp '*' 
  | postRegExp '?' 
  | postRegExp '+' 
  | postRegExp numRange 
  | baseRegExp 
  ;
baseRegExp
  : '(' regExp ')' 
  | '.' 
  | CHAR_TOK 
  | MACRO_TOK 
  | '[' classElements ']' 
  | '[' '^' classElements ']' 
  ;
classElements
  : classElement 
  | classElements classElement 
  ;
classElement
  : CHAR_TOK 
  | CHAR_TOK '-' CHAR_TOK 
  | COLON_BEGIN_TOK ID_TOK COLON_END_TOK 
  ;
numRange
  : '@{' NUM_TOK '@}' 
  | '@{' NUM_TOK ',' '@}' 
  | '@{' NUM_TOK ',' NUM_TOK '@}' 
  ;
@end example

@node Copying, Concept Index, Syntax of Zlex Programs, top
@appendix Copying Conditions

Zlex: A @code{lex}/@code{flex} compatible scanner generator.

Copyright @copyright{} 1995 Zerksis D. Umrigar

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation with one ADDENDUM mentioned below; either
version 2 of the License, or (at your option) any later version.
     
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.
     
You should have received a copy of the GNU General Public License along
with this program in the file GPL included in the Zlex distribution; if
not, write to the Free Software Foundation, Inc., 675 Mass Ave,
Cambridge, MA 02139, USA.

The addendum to the GNU General Public License is as follows: Permission
is hereby given to use the output of Zlex in non-free programs.

The reason for the addendum is that the output of Zlex --- the generated
scanner file --- contains code chunks which are verbatim copies of
sizable sections of Zlex sources.  These chunks include the code for
parts of the `yylex' function, as well as code for Zlex library
functions.  If only the terms of the GPL were to be applied to the code
within the generated scanner file, the effect would be to restrict the
use of Zlex output to free software.  Hence this document amends the
terms of the GNU General Public License to explicitly allow the use of
the output of Zlex in non-free programs.

The addendum has not been added because of sympathy for people who want
to make software proprietary.  @emph{Software should be free.}
Unfortunately, it appears that limiting Zlex's use to free software does
little to encourage people to make other software free.  So the addendum
makes the practical conditions for using Zlex match the practical
conditions for using other free tools.

Questions and comments regarding Zlex can be directed to me at
zdu@@acm.org

The above conditions were derived from the copying conditions published
for @code{bison} by the Free Software Foundation, Inc.


@node Concept Index, Name Index, Copying, top
@unnumbered Concept Index
@printindex cp

@node Name Index,  , Concept Index, top
@unnumbered Index of Names Used in the Generated Scanner
@printindex fn

@shortcontents
@contents
@bye
