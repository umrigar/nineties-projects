/* This scanner was automatically generated by zlex Version 1.02
 * using the command:
 * ./zlex -o scan.c scan.l 
 */
/* Skeleton file automatically produced by gm4 -P from zlexskl.cm4. */

#define ZLEX_SCANNER 1

#if 0
#ifndef NDEBUG	
#define NDEBUG
#endif
#endif

#ifdef DEBUG_ZLEX 	/* Define to check run-time assertions. */
#undef NDEBUG
#endif

#include <assert.h>

/*			    C LIBRARY ROUTINES.				*/

#if __STDC__
#include <limits.h>
#include <stdlib.h>
#else
#if 0 
/* It is safest to not declare these here.  Most compilers should do the
 * right thing after producing warnings about missing declarations.
 */
extern exit();
extern int read();
#endif /* if 0 */
#endif /* #if __STDC__ */


/* Define max. value YY_CHAR_BIT if YY_CHAR_BIT undef. */
#ifndef YY_CHAR_BIT
#ifdef CHAR_BIT	
#define YY_CHAR_BIT CHAR_BIT		/* From <limits.h> */
#else
#define YY_CHAR_BIT 8		/* A "reasonable" value. */
#endif
#endif



/* Define max. value YY_UCHAR_MAX if YY_UCHAR_MAX undef. */
#ifndef YY_UCHAR_MAX
#ifdef UCHAR_MAX	
#define YY_UCHAR_MAX UCHAR_MAX		/* From <limits.h> */
#else
#define YY_UCHAR_MAX 255		/* A "reasonable" value. */
#endif
#endif



/* Define max. value YY_USHRT_MAX if YY_USHRT_MAX undef. */
#ifndef YY_USHRT_MAX
#ifdef USHRT_MAX	
#define YY_USHRT_MAX USHRT_MAX		/* From <limits.h> */
#else
#define YY_USHRT_MAX 65535		/* A "reasonable" value. */
#endif
#endif



/* Define max. value YY_UINT_MAX if YY_UINT_MAX undef. */
#ifndef YY_UINT_MAX
#ifdef UINT_MAX	
#define YY_UINT_MAX UINT_MAX		/* From <limits.h> */
#else
#define YY_UINT_MAX 65535		/* A "reasonable" value. */
#endif
#endif



/* Define max. value YY_ULONG_MAX if YY_ULONG_MAX undef. */
#ifndef YY_ULONG_MAX
#ifdef ULONG_MAX	
#define YY_ULONG_MAX ULONG_MAX		/* From <limits.h> */
#else
#define YY_ULONG_MAX 4294967295		/* A "reasonable" value. */
#endif
#endif



#ifndef YY_SHRT_MAX
#ifdef SHRT_MAX
#define YY_SHRT_MAX	SHRT_MAX
#else
#define YY_SHRT_MAX	32767
#endif
#endif

typedef unsigned short YYUShrt;
typedef unsigned int YYUInt;
typedef unsigned long YYULong;
typedef short YYShrt;
typedef int YYInt;

/* 			SCANNER PARAMETERS.				*/

/* Possibilities for compression. */
#define YY_NO_COMPRESS		0
#define YY_COMB_COMPRESS	1
#define YY_ITERATIVE_COMPRESS	2

/* Possibilities for table entries. */
#define YY_ADDRESS_TABLE	0
#define YY_DIFF_TABLE		1
#define YY_STATE_TABLE		2

/*

#Define following parameters:

#Parameters set by outDFA module.
YY_MAX_BASE:		Max. entry in yyBase[] array.
YY_N_COLS:		# of columns in next[] when COMPRESS == NO_COMPRESS.
YY_N_NEXT:		# of entries in next[].

#Parameters set in dfa module.
YY_N_INITIAL_STATES:	# of initial states (2*YY_N_START_STATES if ^ patterns).
YY_N_INTRA_STATES:	# of states with intra-tok actions and alternate states.
YY_N_NON_FINAL_STATES:	# of non-accepting states in DFA.
YY_N_SIG_STATES:	# of states in DFA having non-jam transitions.
YY_N_STATES:		Total number of scanner states (includes sentinel
                        state, but not jam state if --backup-optimize; 
			does not include sentinel state or jam state or 
			pseudo sentinel	states or pseudo jam states if 
			!backup-optimize).
YY_SENTINEL_STATE:	# of sentinel state.

#Parameters set in chrclass module.
YY_16_BIT:		1 iff scanner for 16 bit characters.
YY_CLASS_SEG_BIT:	The bit # (0-origin, little endian) defining a char seg.
YY_N_EQ_CLASSES:	eq. classes. (==  YY_CHAR_SET_SIZE if no eq. classes).
YY_MAX_EQ_BASE:		Max base value if eq-compression; 0 if not.
YY_MAX_EQ_CHECK:	Max check value if eq-compression; 0 if not.

#Parameters set in main module.
YY_ALIGN:		1 if tables should use natural int size.
YY_ARRAY:		1 if yytext is array.
YY_BACKUP_OPTIMIZE:	1 if scanner is being optimized for backup.
YY_CHAR_SET_SIZE:	Size of char-set (128 or 256).
YY_COMPRESS:		Value of YY_NO_COMPRESS, YY_COMB_COMPRESS or 
			YY_ITERATIVE_COMPRESS.
YY_DO_CODE		1 if directly executable scanner.
YY_DO_DEBUG:		1 if debugging requested via cmd-line; 0 if not.
YY_DO_REJECT:		1 if REJECT actions enabled.
YY_DO_STDIO:		1 if <stdio.h> fread() to be used for input.
YY_SENTINEL_CHAR:	Character used as sentinel.
YY_DEFAULT_ACTION:	0: echo; 1: error; 2: fatal; 3: ignore.
YY_TABLE_ENTRY:		Value of YY_ADDRESS_TABLE, YY_DIFF_TABLE or
			YY_STATE_TABLE.
YY_ZLEX_MAJOR_VERSION:	Major version # of zlex which generated scanner.
YY_ZLEX_MINOR_VERSION:	Minor version # of zlex which generated scanner.

#Parameters set in patterns module.
YY_DEFAULT_ACTN:	Default action number. 
YY_HAS_VAR_CONTEXTS:	True if there are variable-right-context patterns.
YY_HAS_INTRA_TOK_PAT:	True if there are intra-token patterns.
YY_LINENO_ACTN:		Number for yylineno action (0 if yylineno not used).
YY_N_START_STATES:	# of start-states (>= 1).
YY_NUM_RULES:		# of rules (== largest action # since 1-origin).
YY_START_OF_LINE:	1 if source file uses `^' pattern; 0 otherwise.

#Parameters set in scan module.
YY_SRC_NAME:		Name of source file.

*/

/* Scanner parameters. */
#define YY_MAX_BASE 908
#define YY_N_COLS 0
#define YY_N_NEXT 940
#define YY_N_INITIAL_STATES 38
#define YY_N_INTRA_STATES 0
#define YY_N_NON_FINAL_STATES 53
#define YY_N_SIG_STATES 127
#define YY_N_STATES 202
#define YY_SENTINEL_STATE 0
#define YY_16_BIT 0
#define YY_CLASS_SEG_BIT 8
#define YY_N_EQ_CLASSES 42
#define YY_MAX_EQ_BASE 0
#define YY_MAX_EQ_CHECK 0
#define YY_ALIGN 0
#define YY_ARRAY 0
#define YY_BACKUP_OPTIMIZE 0
#define YY_CHAR_SET_SIZE 256
#define YY_COMPRESS 1
#define YY_DO_CODE 0
#define YY_DO_DEBUG 0
#define YY_DO_REJECT 1
#define YY_DO_STDIO 0
#define YY_SENTINEL_CHAR 0
#define YY_DEFAULT_ACTION 0
#define YY_TABLE_ENTRY 2
#define YY_ZLEX_MAJOR_VERSION 1
#define YY_ZLEX_MINOR_VERSION 2
#define YY_DEFAULT_ACTN 109
#define YY_HAS_VAR_CONTEXTS 0
#define YY_HAS_INTRA_TOK_PAT 0
#define YY_LINENO_ACTN 0
#define YY_N_START_STATES 19
#define YY_NUM_RULES 111
#define YY_START_OF_LINE 1
#define YY_SRC_NAME "scan.l"
#line 216 "scan.c"


/*			    ZLEX LIBRARY INTERFACE			*/


/*

File:	 libzlex.h
Purpose: External interface to zlex library.

Copyright (C) 1995 Zerksis D. Umrigar

See the file LICENSE for copying and distribution conditions.
THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM.

*/

#ifndef _LIBZLEX_H
#define _LIBZLEX_H

#include <stdio.h>

/* These are definitions exported by the zlex library. */


#if __STDC__

#ifndef YY_CONST
#define YY_CONST		const
#endif

#ifndef YY_VOID
#define YY_VOID			void
#endif

#ifndef YY_VOIDP
#define YY_VOIDP		void *
#endif

#ifndef YY_VOID_ARGS
#define YY_VOID_ARGS		void
#endif

#ifndef YY_PROTO
#define YY_PROTO(p)		p
#endif

#else	/* !defined(__STDC__) || __STDC__ == 0. */

#ifndef YY_CONST
#define YY_CONST
#endif

#ifndef YY_VOID
#define YY_VOID
#endif

#ifndef YY_VOIDP
#define YY_VOIDP		char *
#endif

#ifndef YY_VOID_ARGS
#define YY_VOID_ARGS
#endif

#ifndef YY_PROTO
#define YY_PROTO(p)		()
#endif

#endif /* ifdef __STDC__ */

#if YY_16_BIT
typedef unsigned short YYChar;
#else
typedef char YYChar;
#endif
typedef unsigned YYCharX;	/* For parameter passing. */

typedef int YYState;	 	/* Type for state not stored in table. */

typedef unsigned char YYUChar;
typedef YYUChar YYBool;		/* 0 == FALSE; 1 == TRUE. */
typedef unsigned YYBoolX;	/* For parameter passing. */

typedef unsigned long yy_size_t;

#ifndef BUFSIZ
#define BUFSIZ	1024
#endif

#define YY_BUF_SIZE	(8 * BUFSIZ)

#define YY_NULL 0

typedef YY_VOIDP YYDataHandle;	/* Opaque handle to scanner state. */
typedef YY_VOIDP YYBufHandle;	/* Opaque handle to scanner buffer. */

/* 			LIBRARY FUNCTIONS				*/

#if YY_16_BIT
#define yyCreateBuffer		yyCreateBuffer16
#define yyDeleteBuffer		yyDeleteBuffer16
#define yyFlushBuffer		yyFlushBuffer16
#define yySwitchToBuffer	yySwitchToBuffer16
#define yyMemBuffer		yyMemBuffer16
#define yyBytesBuffer		yyBytesBuffer16
#define yyStringBuffer		yyStringBuffer16
#define yyGet			yyGet16
#define yyLess			yyLess16
#define yyMore			yyMore16
#define yyUnput			yyUnput16
#define yyRestart		yyRestart16
#define yyPopState		yyPopState16
#define yyPushState		yyPushState16
#define yyTopState		yyTopState16
#endif /* if YY_16_BIT */

/* Buffer routines. */
YYBufHandle yyCreateBuffer YY_PROTO ((YYDataHandle d, FILE *f, yy_size_t s));
YY_VOID yyDeleteBuffer YY_PROTO ((YYDataHandle d, YYBufHandle b));
YY_VOID yyFlushBuffer YY_PROTO ((YYDataHandle d, YYBufHandle bP));
YY_VOID yySwitchToBuffer YY_PROTO ((YYDataHandle d, YYBufHandle b));

/* Memory Buffer routines. */
YYBufHandle yyMemBuffer YY_PROTO ((YYDataHandle d, YYChar *buf, yy_size_t len));
YYBufHandle yyBytesBuffer YY_PROTO ((YYDataHandle d, 
				     YY_CONST YYChar *bytes, int len));
YYBufHandle yyStringBuffer YY_PROTO ((YYDataHandle d, YY_CONST YYChar *str));

/* Action routines. */
int yyGet YY_PROTO ((YYDataHandle d));
YY_VOID yyLess YY_PROTO ((YYDataHandle d, int n));
YY_VOID yyMore YY_PROTO ((YYDataHandle d));
YY_VOID yyUnput YY_PROTO ((YYDataHandle d, YYCharX ch));

/* Restart routine. */
YY_VOID yyRestart YY_PROTO ((YYDataHandle d, FILE *fp));

/* Start-state stack routines. */
YY_VOID yyPopState YY_PROTO ((YYDataHandle d));
YY_VOID yyPushState YY_PROTO ((YYDataHandle d, YYState newState));
YYState yyTopState YY_PROTO ((YYDataHandle d));

#endif /* ifndef _LIBZLEX_H */

/*

File:	 libzlexs.h
Purpose: Skeleton interface to zlex library.

Copyright (C) 1995 Zerksis D. Umrigar

See the file LICENSE for copying and distribution conditions.
THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM.

*/

#ifndef _LIBZLEXS_H
#define _LIBZLEXS_H

/* These are the definitions required in the parser from the skeleton,
 * but are not part of the external library interface.  Assumes external
 * library declarations have been made.
 */

typedef enum {				/* Record which options are set. */
  YY_LINENO_FLAG= 1,			/* yylineno to be computed. */
  YY_ARRAY_FLAG= YY_LINENO_FLAG * 2,	/* yytext is an array. */
  YY_BACKUP_OPTIMIZE_FLAG= 		/* Stack used for backing up. */
    YY_ARRAY_FLAG * 2
} YYFlags;

enum {
  YY_INIT_SENTINEL= 0x01	/* Sentinel for initialization. */
};

typedef struct {		/* Start-state stack. */
  YYState *base;		/* Points to base of stack. */
  yy_size_t size;		/* # of allocated entries. */
  unsigned index;		/* Index of next free location. */
} YYSSStack;

typedef yy_size_t (*YYReadFnP) YY_PROTO ((YYChar *buf, yy_size_t nRead));
typedef int (*YYWrapFnP) YY_PROTO ((YY_VOID_ARGS));

typedef struct {	/* Buffer structure. */	
  FILE *yyin;		/* Associated file. NULL if in-memory buffer. 	*/
  /* Buffer parameters. */
  YYChar *buf;		/* Allocated area. */
  YYChar *end;		/* Point 1 character beyond last char. in buffer. */
			/* end - buf == # of chars currently in buf.	*/
  yy_size_t size;	/* Total size of allocated area. 		*/

  yy_size_t nRead;	/* Total # of characters read from file, not 	*/
                        /* counting what is currently in buffer.	*/
  /* (end - buf + nRead) == total # of chars. read from file.		*/


  yy_size_t intraPos;	/* buf position just after last intra-token pattern. */

  YYChar *cp;		/* Point to next char. to be scanned. 		*/

  /* The following four fields are used only if --yylineno. */
  yy_size_t lastLinePos;/* File position AFTER last completely scanned '\n'. */
  yy_size_t firstNLPos;	/* Position AFTER 1st '\n' in current scan. */

  /* The following field is invalid when this buffer is active. 	*/
  /* When the buffer is active, its value can be found in yylineno. 	*/
  int lineno;		/* 1 + # of '\n's completely scanned. */

  YYChar lastCh;	/* Last character read from this buffer.	*/

  YYBool hasNL;		/* Non-zero if current scan hits a new '\n'. */

  YYUChar eofState;	/* 0= nonEOF; 1= seen EOF; 2= completed EOF. 	*/

} YYBuf;

typedef YYBuf *YYBufP;

/* Package up all static global data for convenient passing around. */
typedef struct {

  /* Pointers to extern variables available to user. */
  FILE **YY_CONST yyinP;	/* Points to yyin */
  FILE **YY_CONST yyoutP;	/* Points to yyout. */
  FILE **YY_CONST yyerrP;	/* Points to yyerr. */
  YYChar **YY_CONST yytextP;	/* Points to yytext or yytext0. */
  int *YY_CONST yylengP;	/* Points to yyleng. */
  int *YY_CONST yylinenoP;	/* Points to yylineno. */
  YYBufP *YY_CONST yyCurrentBufP;/* Points to YY_CURRENT_BUF. */

  YYChar *YY_CONST textArray;	/* Address of yytext array if YY_HAS_ARRAY. */

  YY_CONST YYBufP bufP;		/* Address of static buffer cache. */

  /* Pointers to user-defined call-back functions. */
  YY_CONST YYReadFnP read;	/* Routine to read into buf. */
  YY_CONST YYWrapFnP yywrap;	/* Wrap-up on end-of-file. */

  YYChar *saveCP;		/* Points to &yytext[yyleng]. */

  /* Sentinel information. */
  YYChar *sentinelP;		/* Points to sentinel char. */
  YYChar sentinelChar;	       	/* Character used as sentinel. */
  YYChar sentinelSave;		/* Char. originally at *sentinelP. */
  YYChar saveCh;		/* Character to be restored at next scan.*/

  YYUChar flags;		/* Or of reasons for sentinel. */
  
  /* Options: YY_LINENO_FLAG|YY_ARRAY_FLAG|YY_BACKUP_OPTIMIZE_FLAG  */
  YYUChar options;		/* Flags giving some scanner options. */

  /* yymore information. */
  YYUChar doMore;		/* Nonzero if outstanding yymore request. */
  YYChar *moreText;		/* Saved yytext. */
  yy_size_t moreLeng;		/* Saved yyleng. */


  /* Variables to save yytext. Used after a buffer is deleted. */
  YYChar *yyTextSave;		/* Point to save area. */
  yy_size_t yyTextSaveSize;	/* Current size of save area. */

  /* Stack of states used for backtracking. */
  YYState *stk;			/* Points to base of stack. */
  unsigned stkSize;		/* Max. # of entries in stk. */

  /* Start states. */
  YYState startState;		/* Current start-state. */
  YYSSStack *ssStkP;		/* Start-condition stack struct. */

} YYData; /* End typedef struct for scanner data. */

#if YY_16_BIT
#define yyTerminate		yyTerminate16
#define yyProcessSentinel	yyProcessSentinel16
#define yyReplace		yyReplace16
#define yyMakeAdjText		yyMakeAdjText16
#define yyDebugMsg		yyDebugMsg16
#define yyDefaultMsg		yyDefaultMsg16
#define yyEOFMsg		yyEOFMsg16
#endif /* if YY_16_BIT */

YY_VOID yyTerminate YY_PROTO ((YYData *dP));
YY_VOID yyProcessSentinel YY_PROTO ((YYData *dP, unsigned nStk));

YYChar *yyReplace YY_PROTO ((YYData *dP, yy_size_t len, 
			     YY_CONST YYChar *string, 
			     YYChar **intraTextP));

YYChar *yyMakeAdjText YY_PROTO ((YYData *dP));

YY_VOID yyDebugMsg YY_PROTO ((YY_CONST YYData *dP, char *srcFile, int n, 
			     YYChar *yyText, int debugFlag));
YY_VOID yyDefaultMsg YY_PROTO ((YY_CONST YYData *dP, 
				YYChar *yytext, int debugFlag));
YY_VOID yyEOFMsg YY_PROTO ((YY_CONST YYData *dP, int debugFlag));
YY_VOID yyZlexFatal YY_PROTO ((FILE *yyerr, YY_CONST char *msg));

/* Invariant macro used for assertions. */
#define YY_INV(dP)							\
  ( 									\
    /* cp within current buffer. */					\
    ( (dP)->bufP->buf <= (dP)->bufP->cp &&				\
      (dP)->bufP->cp <= (dP)->bufP->end + 1				\
    ) &&								\
    /* saveCP points to &yytext[yyleng]. */				\
    ( (dP)->saveCP == *(dP)->yytextP + *(dP)->yylengP )			\
  )

#endif /* ifndef _LIBZLEXS_H */



/* 	MACROS AND TYPEDEFS DEPENDING ON SCANNER PARAMETERS.		*/

/* We don't use #error, since some K&R compilers choke on it. */

#if YY_BACKUP_OPTIMIZE
/* State to go to when there is no legal transition from current state. */
#define YY_JAM_STATE (YY_N_STATES)	/* Largest state number. */
#else
/* This is only used as a place-holder to indicate a jam in addition to
 * YY_N_STATES pseudo-jam states.
 */
#define YY_JAM_STATE		(2*YY_N_STATES + YY_N_SIG_STATES)
#endif

/* Maximum state # which may be stored in tables. */
#define YY_MAX_STATE		YY_JAM_STATE

/* If not state table, will need two extra check values. */
#if YY_TABLE_ENTRY == YY_STATE_TABLE

#define YY_X_CHECK	0

#else

#define YY_X_CHECK	2

/* Index for default state in comb vector relative to start of state. */
#define YY_DEF_INDEX	YY_N_EQ_CLASSES

/* Index for state number in comb vector relative to start of state. */
#define YY_STATE_INDEX	(YY_N_EQ_CLASSES + 1)

#endif

#if YY_ALIGN

typedef YYUInt YYXState;
typedef YYUInt YYAct;
typedef YYUInt YYBase;
typedef YYUInt YYCheck;
typedef YYInt  YYDisp;
typedef YYInt  YYDef;
typedef YYUInt YYClass;
typedef YYUInt YYEqBase;
typedef YYUInt YYEqCheck;

#else

/* Let preprocessor figure out smallest type which can hold a state.
 * Used for holding states in tables.
 */

/* typedef YYXState to represent values in 0, ..., (YY_MAX_STATE). */
#if ((YY_MAX_STATE) <= YY_UCHAR_MAX)
typedef YYUChar YYXState;
#elif ((YY_MAX_STATE) <= YY_USHRT_MAX)
typedef YYUShrt YYXState;
#elif ((YY_MAX_STATE) <= YY_UINT_MAX)
typedef YYUInt YYXState;
#elif ((YY_MAX_STATE) <= YY_ULONG_MAX)
typedef YYULong YYXState;
#else
  #error Type YYXState cannot be represented.
#endif


/* Let preprocessor figure out type for YYAct. */

/* typedef YYAct to represent values in 0, ..., YY_NUM_RULES. */
#if (YY_NUM_RULES <= YY_UCHAR_MAX)
typedef YYUChar YYAct;
#elif (YY_NUM_RULES <= YY_USHRT_MAX)
typedef YYUShrt YYAct;
#elif (YY_NUM_RULES <= YY_UINT_MAX)
typedef YYUInt YYAct;
#elif (YY_NUM_RULES <= YY_ULONG_MAX)
typedef YYULong YYAct;
#else
  #error Type YYAct cannot be represented.
#endif


/* Let preprocessor figure out type for base[].	*/

/* typedef YYBase to represent values in 0, ..., YY_MAX_BASE. */
#if (YY_MAX_BASE <= YY_UCHAR_MAX)
typedef YYUChar YYBase;
#elif (YY_MAX_BASE <= YY_USHRT_MAX)
typedef YYUShrt YYBase;
#elif (YY_MAX_BASE <= YY_UINT_MAX)
typedef YYUInt YYBase;
#elif (YY_MAX_BASE <= YY_ULONG_MAX)
typedef YYULong YYBase;
#else
  #error Type YYBase cannot be represented.
#endif


/* Let preprocessor figure out type for check[]. */

/* typedef YYCheck to represent values in 0, ..., YY_N_EQ_CLASSES + YY_X_CHECK. */
#if (YY_N_EQ_CLASSES + YY_X_CHECK <= YY_UCHAR_MAX)
typedef YYUChar YYCheck;
#elif (YY_N_EQ_CLASSES + YY_X_CHECK <= YY_USHRT_MAX)
typedef YYUShrt YYCheck;
#elif (YY_N_EQ_CLASSES + YY_X_CHECK <= YY_UINT_MAX)
typedef YYUInt YYCheck;
#elif (YY_N_EQ_CLASSES + YY_X_CHECK <= YY_ULONG_MAX)
typedef YYULong YYCheck;
#else
  #error Type YYCheck cannot be represented.
#endif


/* Maximum value held in a defaults arrays. */
#if YY_COMPRESS == YY_ITERATIVE_COMPRESS
#define YY_MAX_DEF	(2 * YY_MAX_STATE)
#else
#define YY_MAX_DEF	(YY_MAX_STATE)
#endif
/* Let preprocessor figure out type for def[] array. */

/* typedef YYDef to represent values in 0, ..., YY_MAX_DEF. */
#if (YY_MAX_DEF <= YY_UCHAR_MAX)
typedef YYUChar YYDef;
#elif (YY_MAX_DEF <= YY_USHRT_MAX)
typedef YYUShrt YYDef;
#elif (YY_MAX_DEF <= YY_UINT_MAX)
typedef YYUInt YYDef;
#elif (YY_MAX_DEF <= YY_ULONG_MAX)
typedef YYULong YYDef;
#else
  #error Type YYDef cannot be represented.
#endif


/* Let preprocessor figure out type for next displacement used when
 * YY_TABLE_ENTRY is YY_DIFF_TABLE.  This is approximate as we 
 * assume that a short is 2 bytes.
 */
#if YY_TABLE_ENTRY == YY_DIFF_TABLE
#if YY_BACKUP_OPTIMIZE
#define YY_DUMMY_SIZE		(YY_N_STATES - YY_N_SIG_STATES)
#else 
#define YY_DUMMY_SIZE							\
  (YY_N_STATES - YY_N_SIG_STATES + YY_N_STATES + YY_N_SIG_STATES)
#endif
#ifndef YY_SHRT_SIZE
#define YY_SHRT_SIZE	2
#endif
#if YY_COMPRESS == YY_ITERATIVE_COMPRESS
#if (2*(YY_N_NEXT*YY_SHRT_SIZE + YY_DUMMY_SIZE) <= YY_SHRT_MAX)
typedef YYShrt YYDisp;
#else
typedef YYInt YYDisp;
#endif
#else /* YY_COMPRESS != YY_ITERATIVE_COMPRESS */
#if (YY_N_NEXT*YY_SHRT_SIZE + YY_DUMMY_SIZE <= YY_SHRT_MAX)
typedef YYShrt YYDisp;
#else
typedef YYInt YYDisp;
#endif
#endif /* else YY_COMPRESS != YY_ITERATIVE_COMPRESS */
#endif /* if YY_TABLE_ENTRY == YY_DIFF_TABLE */

/* Let preprocessor figure out type for eqClass[]. */

/* typedef YYClass to represent values in 0, ..., YY_N_EQ_CLASSES-1. */
#if (YY_N_EQ_CLASSES-1 <= YY_UCHAR_MAX)
typedef YYUChar YYClass;
#elif (YY_N_EQ_CLASSES-1 <= YY_USHRT_MAX)
typedef YYUShrt YYClass;
#elif (YY_N_EQ_CLASSES-1 <= YY_UINT_MAX)
typedef YYUInt YYClass;
#elif (YY_N_EQ_CLASSES-1 <= YY_ULONG_MAX)
typedef YYULong YYClass;
#else
  #error Type YYClass cannot be represented.
#endif


/* Let preprocessor figure out type for eqBase[]. */

/* typedef YYEqBase to represent values in 0, ..., YY_MAX_EQ_BASE. */
#if (YY_MAX_EQ_BASE <= YY_UCHAR_MAX)
typedef YYUChar YYEqBase;
#elif (YY_MAX_EQ_BASE <= YY_USHRT_MAX)
typedef YYUShrt YYEqBase;
#elif (YY_MAX_EQ_BASE <= YY_UINT_MAX)
typedef YYUInt YYEqBase;
#elif (YY_MAX_EQ_BASE <= YY_ULONG_MAX)
typedef YYULong YYEqBase;
#else
  #error Type YYEqBase cannot be represented.
#endif


/* Let preprocessor figure out type for eqCheck[]. */

/* typedef YYEqCheck to represent values in 0, ..., YY_MAX_EQ_CHECK. */
#if (YY_MAX_EQ_CHECK <= YY_UCHAR_MAX)
typedef YYUChar YYEqCheck;
#elif (YY_MAX_EQ_CHECK <= YY_USHRT_MAX)
typedef YYUShrt YYEqCheck;
#elif (YY_MAX_EQ_CHECK <= YY_UINT_MAX)
typedef YYUInt YYEqCheck;
#elif (YY_MAX_EQ_CHECK <= YY_ULONG_MAX)
typedef YYULong YYEqCheck;
#else
  #error Type YYEqCheck cannot be represented.
#endif


#endif /* else !YY_ALIGN */


/* 		PUBLIC MACROS NOT REDEFINABLE BY USER.			*/

/* Macro for entering a start-state. Yucky, but can't be helped because 
 * of lex. 
 */
#define BEGIN 	yyData.startState= 
#define YY_BEGIN(s)  yyData.startState= (s) 	/* Cleaner version. */

#if YY_DO_REJECT
/* Macro for rejecting current action. Can only be used within yylex(). */
#define REJECT		YY_REJECT
#endif

#define	YY_MORE yyMore(YY_DATA_P)
#define yymore() YY_MORE

#define YY_LESS(n) yyLess(YY_DATA_P, n)
#define yyless(n) YY_LESS(n)

#define YY_TERMINATE()							\
  do {									\
    yyTerminate(YY_DATA_P);						\
    return YY_EOF_OUT;							\
  } while (0)
#define yyterminate() YY_TERMINATE()

#define YY_CHAR_NUM (yyBuf.nRead + (YY_TEXT0 - yyBuf.buf))

#define YY_NEW_FILE yyrestart(YY_IN)

#define YY_RESTART(f)	yyRestart(YY_DATA_P, f)
#define yyrestart(f)	YY_RESTART(f)

#define YY_GET()	yyGet(YY_DATA_P)
#ifdef __cplusplus
#define yy_input()	YY_GET()
#else
#define input()		YY_GET()
#endif

#define YY_UNPUT(ch)	yyUnput(YY_DATA_P, ch)
#define unput(ch)	YY_UNPUT(ch)

#define YY_BUFFER_STATE YYBufHandle

#define YY_CREATE_BUFFER(f, s)	yyCreateBuffer(YY_DATA_P, f, s)
#define yy_create_buffer(f, s)	YY_CREATE_BUFFER(f, s)
#define YY_SWITCH_TO_BUFFER(b)	yySwitchToBuffer(YY_DATA_P, b)
#define yy_switch_to_buffer(b)	(YY_SWITCH_TO_BUFFER(b))
#define YY_DELETE_BUFFER(b)	yyDeleteBuffer(YY_DATA_P, b)
#define yy_delete_buffer(b)	YY_DELETE_BUFFER(b)

#define YY_FLUSH_BUFFER		yy_flush_buffer(YY_CURRENT_BUFFER)
#define yy_flush_buffer(bp)	yyFlushBuffer(YY_DATA_P, bp)

#define YY_STRING_BUFFER(str)		yyStringBuffer(YY_DATA_P, str)
#define yy_scan_string(str)		YY_STRING_BUFFER(str)
#define YY_BYTES_BUFFER(bytes, len)	yyBytesBuffer(YY_DATA_P, bytes, len)
#define yy_scan_bytes(bytes, len)	YY_BYTES_BUFFER(bytes, len)
#define YY_MEM_BUFFER(buf, len)		yyMemBuffer(YY_DATA_P, buf, len)
#define yy_scan_buffer(buf, len)	YY_MEM_BUFFER(buf, len)

#define YY_PUSH_STATE(s)	yyPushState(YY_DATA_P, s)
#define yy_push_state(s)	YY_PUSH_STATE(s)
#define YY_POP_STATE()		yyPopState(YY_DATA_P)
#define yy_pop_state()		YY_POP_STATE()
#define YY_TOP_STATE()		yyTopState(YY_DATA_P)
#define yy_top_state()		YY_TOP_STATE()

/* 			SECTION 1 DECLARATIONS.				*/

#line 1 "scan.l"
/*

File:	 scan.l
Purpose: Zlex scanner.

Copyright (C) 1995 Zerksis D. Umrigar

See the file LICENSE for copying and distribution conditions.
THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM.

*/

#line 13 "scan.l"
/* -*-c-*- */
#line 14 "scan.l"
/*

Allows whitespace within patterns when optionsP->wsInPatterns.  The
pattern is terminated by seeing the start of an action or by a newline
(not within parentheses).

When whitespace is allowed in patterns, the following restrictions
facilitate recognition of a C-brace-action:

--  {lex_macro} uses are regarded as indivisible tokens and cannot 
    contain whitespace.

--  There cannot be any whitespace between the '{' and the first 
    digit specifying the start of a repetition range.

When whitespace is allowed, the most severe restriction (which may break
existing lex programs) is that if a action follows a pattern on the same
line and is not enclosed in braces, it will be considered as part of the
pattern! 

Actions are of three types:

--  Indented Actions:  A sequence of indented lines.

--  Decorated Actions: A sequence of lines enclosed within ^"%{" and
    ^"%}".

--  C Brace Actions: A sequence of lines within (balanced) braces.

Brace actions are C-interpreted --- i.e. braces are balanced except
when within a C-comment, C-string or C-character-constant.  The other
two actions are uninterpreted --- once within those actions, there is
no recognition of any C-construct.

A temporary file stores the "actions".  Each action is identified
using an index referred to as a ActIndex.  The global definitions
section from section 1 has ActIndex 0.  The local definitions section
(before the first pattern) from section 2 has ActIndex 1.  Each
subsequent user action with number (starting at 0) actNum has ActIndex
actNum + 2.

In section 2, a newline is considered to be a action by the local
yylex().  For the purpose of assigning action indexes, a sequence of
actions which have no intervening patterns are considered to be a
single action (tho' the local yylex() delivers individual ACT_TOKs for
each action in the sequence).  Each such action sequence is terminated
by a section 2 pattern or by a "%%" marker or EOF.

A top-level scan() wrapper around the local yylex() routine, is used
for token massaging using upto 2-token lookahead.

*/

#line 67 "scan.l"
		/* C char-constant character. */
#line 68 "scan.l"
/* Identifier. */
#line 69 "scan.l"
		/* Integer. */
#line 70 "scan.l"
		/* Octal number. */
#line 71 "scan.l"
		/* Hexadecimal number. */
#line 72 "scan.l"
		/* Use of a lex macro. */
#line 73 "scan.l"
		/* C string character. */
#line 74 "scan.l"
		/* Whitespace within line. */
#line 75 "scan.l"
		/* Special char-class start chars. */
#line 76 "scan.l"
		/* Option word. */

#line 78 "scan.l"
		/* Within the definitions section. */
#line 79 "scan.l"
	/* In a %option line. */
#line 80 "scan.l"
	/* Within a {num, num} range. */
#line 81 "scan.l"
	/* Defining start-states. */
#line 82 "scan.l"
	/* Using start-states. */

#line 84 "scan.l"
	/* Within balanced braces C-code section. */
#line 85 "scan.l"
	/* Within a lex character class. */
#line 86 "scan.l"
	/* With [: :] */
#line 87 "scan.l"
	/* Within slash-star comment. */
#line 88 "scan.l"
		/* With a C-string. */
#line 89 "scan.l"
	/* Within ^"%{" and ^"%}" code-section. */
#line 90 "scan.l"
	/* Within section of indented code. */
#line 91 "scan.l"
		/* Within %line directive line. */
#line 92 "scan.l"
		/* In section 3: merely copy source to G.outFile. */
#line 93 "scan.l"
	/* A '^' followed a '>' terminating a start-state list. */
#line 94 "scan.l"
		/* Within a lex pattern string. */
#line 95 "scan.l"
	/* In lex table declaration. */
#line 96 "scan.l"
	/* At the very beginning of a character-class. */

#line 98 "scan.l"


#include "files.h"
#include "scan.h"

#include "area.h"
#include "error.h"
#include "ids.h"
#include "memalloc.h"
#include "strspace.h"
#include "textid.h"
#include "zutil.h"

#include <ctype.h>

typedef struct {
  Area optionsText;	/* Accumulate text of options here. */
  FILE *outFile;	/* FILE pointer for output file in section 3. */
  FILE *tmpFile;	/* FILE pointer for temporary file. */

  /* lineSrcName may contain escape sequences; srcName will not. */
  ConstString lineSrcName; /* Name of source file for #line directives. */
  ConstString srcName;	/* Name of source file for error messages. */

  ConstString *argv;	/* Command-line arguments. */
  Count2 argc;		/* Number of command line arguments. */
  Count2 argn;		/* Number of processed command line arguments. */
  Index lineN;		/* Current line # in source file. */
  Index delimLineN;	/* Line # where paren/brace nesting started. */	
  Index2 lineState;	/* 0: Seen #line; 1: Seen NN; 2: Seen file name. */
  Count1 depth;		/* Depth of paren/brace nesting. */
  Boolean doCopy;	/* TRUE if comments should be copied. */
  Index1 secN;		/* Section #: 1, 2 or 3. */
  Index1 retSS;		/* Start-state to return to after comment or %line. */
} Globals;

static Globals *globalsP;
#define G (*globalsP)
  
#define END_TOK YY_NULL	/* Return at start of section 3. */

#define YY_DECL	static int yylex()

#define LAST_STATE()	(G.secN == 2 ? INITIAL : DEFS)

#define COPY()	do { fputs(yytext, G.tmpFile); } while (0)
#define COPY_NL()  do { fputs(yytext, G.tmpFile); } while (0)
#define XCOPY() if (G.doCopy) COPY()
#define XCOPY_NL() if (G.doCopy) COPY_NL()

static Int cEscChar PROTO((int c));
static Int lexDir PROTO((ConstString dir));
static VOID endAct PROTO((VOID_ARGS));
static Index nextAct PROTO((VOID_ARGS));
static Boolean action PROTO((ConstString text));
static VOID eofError PROTO((Count lineN, ConstString delimiter));
static VOID setSrcFile PROTO((VOID_ARGS));
static VOID addOptionsText PROTO((VOID_ARGS));
static ConstString getOptionsText PROTO((VOID_ARGS));
static VOID initTmpFile PROTO((VOID_ARGS));
static VOID terminateTmpFile PROTO((VOID_ARGS));
#if DO_TRACE
static VOID dumpActs PROTO((FILE *dumpFile));
#endif

#if TEST_SCAN
static Char ctok[2]= { '\0', '\0' };	/* Return char-toks as 1 char. str. */
#define CTOK(x) ((int)(ctok[0]= x , &ctok[0]))
#define TOK(x)		((int) #x)
#define TOK_EQ(unknownTok, litTok)					\
  ((unknownTok) != 0 							\
   && strcmp((ConstString) (unknownTok), #litTok) == 0)
#define CTOK_EQ(unknownTok, litTok)					\
  ( (unknownTok) != 0 && ((ConstString)(unknownTok))[0] == litTok	\
   && ((ConstString)(unknownTok))[1] == '\0' )
typedef struct {     	/* Just those we need to compile stand-alone. */
  Boolean lexCompat;
  Boolean lineDir;
  Boolean wsInPatterns;
} Options;
static Options options;
static Options *optionsP= &options;
typedef union {
  Int ch;
  ConstString opt;
  Index lineN;
  Index id;
  Index actN;
  Int num;
} YYSTYPE;
static YYSTYPE yylval;

#else /* !TEST_SCAN */

#include "options.h"
#include "patterns.h"

#include "parse.h"

#define TOK(x)		x
#define CTOK(x)		x
#define TOK_EQ(unknownTok, litTok)	(unknownTok == litTok)
#define CTOK_EQ(unknownTok, litTok)	(unknownTok == litTok)

#endif



#line 1055 "scan.c"

/* 		    LIBRARY TYPES & DECLARATIONS.			*/

#include <assert.h>
#include <stdio.h>

#ifndef BUFSIZ
#define BUFSIZ	4096
#endif

#if __STDC__
#include <stdlib.h>	/* For exit(). */
#endif



/* 		NAMES FOR EXTERN SCANNER OBJECTS.			*/

/* Default prefixed names provided, if macros not defined in section 1.	*/
#ifndef YY_CURRENT_BUFFER
#define YY_CURRENT_BUFFER yy_current_buffer
#endif

#ifndef YY_DATA_P
#define YY_DATA_P yydataP
#endif

#ifndef YY_ERR
#define YY_ERR yyerr
#endif

#ifndef YY_IN
#define YY_IN yyin
#endif

#ifndef YY_LENG
#define YY_LENG yyleng
#endif

#ifndef YY_LEX
#define YY_LEX yylex
#endif

#ifndef YY_LINENO
#define YY_LINENO yylineno
#endif

#ifndef YY_OUT
#define YY_OUT yyout
#endif

#ifndef YY_TEXT
#define YY_TEXT yytext
#endif

#ifndef YY_WRAP
#define YY_WRAP yywrap
#endif

#ifndef YY_ZLEX_DEBUG
#define YY_ZLEX_DEBUG yy_zlex_debug
#endif

#line 1119 "scan.c"


/*    DEFAULT MACRO DEFINITIONS IF NOT BEEN DEFINED IN SECTION 1.	*/

/* Prototype for yylex(). */
#ifndef YY_DECL
#define YY_DECL int YY_LEX(YY_VOID_ARGS)
#endif

/* Size of yytext when %array declaration used. */
#ifndef YYLMAX		
#define YYLMAX 8192	
#endif

#ifdef ECHO
#define YY_ECHO ECHO
#endif

#ifndef YY_ECHO
#define ECHO YY_ECHO
#define YY_ECHO fwrite(YY_TEXT, YY_LENG, 1, YY_OUT)
#endif

#ifndef YY_BREAK
#define YY_BREAK break
#endif

#ifndef YY_USER_ACTION
#define YY_USER_ACT
#else
#define YY_USER_ACT							\
  do { if (0 < yyAct && yyAct < YY_DEFAULT_ACTN) YY_USER_ACTION; } while (0)
#endif

#ifndef YY_USER_INIT
#define YY_USER_INIT
#endif

#ifndef YY_INPUT
#define YY_INPUT(buf, result, n)					\
  do {									\
    result= YY_READ(YY_IN, buf, (n));					\
    YY_READ_ERROR(result, YY_IN);					\
    if (result == 0) result= YY_EOF_IN; /* NOP when YY_EOF_IN == 0. */	\
  } while (0)
#endif

/* Combine YY_DO_DEBUG, YYDEBUG and YY_ZL_DEBUG (if def'd in declarations).*/
#if (YY_DO_DEBUG == 1)
#undef YY_ZL_DEBUG
#define YY_ZL_DEBUG
#endif
#ifdef YYDEBUG
#undef YY_ZL_DEBUG
#define YY_ZL_DEBUG
#endif

#ifndef YY_NULL
#define YY_NULL 0
#endif

#ifndef YY_EOF_IN
#define YY_EOF_IN	YY_NULL
#endif

#ifndef YY_EOF_OUT
#define YY_EOF_OUT	YY_NULL
#endif

#if YY_START_OF_LINE
#define YY_SET_BOL(v)	(yyBuf.lastCh= (v) ? '\n' : ' ')
#define yy_set_bol(v)	YY_SET_BOL(v)
#define YY_AT_BOL()	(yyBuf.lastCh == '\n')
#endif

#ifndef YY_FATAL
#define YY_FATAL(msg)	yyZlexFatal(YY_ERR, msg)
#endif

#if YY_DO_CODE		/* Generating a scanner with code-encoded state. */

#if YY_LABEL_VARS	/* Compiler allows vars to contain label addresses. */

#ifndef YY_LABEL_TYPEDEF /* How compiler declares vars containing labels. */
#ifdef __GNUC__
#define YY_LABEL_TYPEDEF(type)	typedef void *type
#endif
#endif

#ifndef YY_LABEL_ADDR	/* How compiler takes the address of a label. */
#ifdef __GNUC__
#define YY_LABEL_ADDR(label)	&&label
#endif
#endif

#endif /* if YY_LABEL_VARS */

#if YY_LABEL_VARS

YY_LABEL_TYPEDEF(YYLabP);
#define YY_SWITCH(tabName, var, def, cases)				\
  { static YYLabP tabName[]= { cases }; goto *tabName[var]; }
#define YY_CASE(val, label)	YY_LABEL_ADDR(label),
#define YY_DEFAULT_CASE(val, label) YY_CASE(val, label)

#else /* !YY_LABEL_VARS */

#define YY_SWITCH(tabName, var, def, cases)				\
  { switch (var) { cases default: goto def; } }
#define YY_CASE(val, label)	case val: goto label;
#define YY_DEFAULT_CASE(val, label)

#endif /* YY_LABEL_VARS */

#endif /* if YY_DO_CODE */

/*			START-STATE DEFINITIONS.			*/

#define INITIAL 0
#define DEFS 2
#define OPTIONS 4
#define RANGE 6
#define SS_DEF 8
#define SS_USE 10
#define BRACE 12
#define CLASS 14
#define COLON 16
#define COMMENT 18
#define CSTR 20
#define DECORATED 22
#define INDENT 24
#define LINE 26
#define SEC3 28
#define SS_START 30
#define STR 32
#define TABLE 34
#define X_CLASS 36
#line 1257 "scan.c"

/*		PRIVATE MACROS (SHOULD NOT BE USED BY USER)		*/

/* yytext which is usually in buffer. */
#if YY_ARRAY
#define YY_TEXT0		yytext0
#define YY_TEXT_ARRAY_INIT	YY_TEXT
#else
#define YY_TEXT0		YY_TEXT
#define YY_TEXT_ARRAY_INIT	NULL
#endif


#define YY_OPT_INIT \
  (   (YY_LINENO_ACTN ? YY_LINENO_FLAG : 0) \
    | (YY_ARRAY ? YY_ARRAY_FLAG : 0) \
    | (YY_BACKUP_OPTIMIZE ? YY_BACKUP_OPTIMIZE_FLAG : 0) \
  )

/* If cc initializer exp can't handle ?:, then define as follows (need to
 * add YY_BACKUP_OPTIMIZE case). 
 */
#if 0 
#if YY_ARRAY
#if YY_LINENO_ACTN
#define YY_OPT_INIT	(YY_LINENO_FLAG|YY_ARRAY_FLAG)
#else
#define	YY_OPT_INIT	(YY_ARRAY_FLAG)
#endif
#else /* !YY_ARRAY */
#if YY_LINENO_ACTN
#define YY_OPT_INIT	(YY_LINENO_FLAG)
#else
#define YY_OPT_INIT	0
#endif
#endif /* else !YY_ARRAY */
#endif /* #if 0 */

#if YY_DO_STDIO
#define YY_READ(f, b, n)	fread((b), sizeof(YYChar), (n), (f))
#define YY_READ_ERROR(result, f)					\
  do {									\
    if ((result) == 0 && ferror(f)) {					\
      YY_FATAL("Error reading input file.");				\
    }									\
  } while (0)
#else
extern int read();
/* Don't declare fileno() as it may be a macro. */
#define YY_READ(f, b, n)	read(fileno(f), (b), (n)*sizeof(YYChar))
#define YY_READ_ERROR(result, f)					\
  do {									\
    if ((result) < 0) {							\
      YY_FATAL("Error reading input file.");				\
    }									\
  } while (0)
#endif

#if (YY_DEFAULT_ACTION == 0)	/* echo */
#define YY_DEFAULT_ACT()						\
  do {									\
    YY_DEFAULT_MSG(); ECHO;						\
  } while (0)
#elif (YY_DEFAULT_ACTION == 1)	/* error */
#define YY_DEFAULT_ACT()						\
  do {									\
    YY_DEFAULT_MSG();							\
    fprintf(YY_ERR, "scanner jammed at character `%c'.\n", YY_TEXT[0]);	\
  } while (0)
#elif (YY_DEFAULT_ACTION == 2)	/* fatal */
#define YY_DEFAULT_ACT()						\
  do {									\
    char msg[80];							\
    YY_DEFAULT_MSG();							\
    sprintf(msg, "scanner jammed at character `%c'.\n", YY_TEXT[0]);	\
    YY_FATAL(msg);							\
  } while (0)
#else
#define YY_DEFAULT_ACT()	/* ignore */
#endif


/* Macro which decides whether we use a character directly or an eq. class. */
#if (YY_N_EQ_CLASSES == YY_CHAR_SET_SIZE)
#define YY_SET_EQ_CLASS(e, c) do { e= c; } while (0)
#elif (YY_MAX_EQ_BASE > 0) 
#define YY_SET_EQ_CLASS(e, c)						\
  do {									\
    YY_CONST YYUInt lo= (c) & ((1L << YY_CLASS_SEG_BIT) - 1);		\
    YY_CONST YYUInt hi= (c) >> YY_CLASS_SEG_BIT;			\
    YY_CONST YYUInt i= yyTab.u.s.eqBase[hi] + lo;			\
    e= (yyTab.u.s.eqCheck[i] == lo)					\
       ? yyTab.u.s.eqNext[i]						\
       : yyTab.u.s.eqDefault[hi];					\
  } while (0) 
#else
#define YY_SET_EQ_CLASS(e, c)						\
  do { e= yyTab.u.s.eqClass[c]; } while (0)
#endif

/* Macro which converts from YYChar to unsigned. Evaluates argument exactly
 * once.
 */
#if YY_16_BIT
#define YY_CHAR_TO_UNSIGNED(c)		((unsigned)(c))
#else
#define YY_CHAR_TO_UNSIGNED(c)		((unsigned)(unsigned char)(c))
#endif

#ifdef YY_ZL_DEBUG

#define YY_DEBUG_MSG(n)							\
  yyDebugMsg(&yyData, YY_SRC_NAME, n, YY_TEXT, YY_ZLEX_DEBUG)
#define YY_EOF_MSG() yyEOFMsg(&yyData, YY_ZLEX_DEBUG)
#define YY_DEFAULT_MSG() yyDefaultMsg(&yyData, YY_TEXT, YY_ZLEX_DEBUG)

#else

#define YY_DEBUG_MSG(n)
#define YY_EOF_MSG()
#define YY_DEFAULT_MSG()

#endif /* ifdef YY_DEBUG */

#ifdef YYTRACE	/* Trace DFA transitions. */

/* Since tracing will operate before the scanner has been initialized, 
 * when YY_ERR may be NULL, we check it using the following macro.
 */
#define YY_XERR		((YY_ERR) ? YY_ERR : stderr)

#define YY_TRACE_TRANSIT(s, c)	fprintf(YY_XERR, " %d/`%c'", (s), (c))
#define YY_TRACE_END(s)		fprintf(YY_XERR, " %d", s)
#define YY_TRACE_REJECT(s)	fprintf(YY_XERR, " ^%d", (s))
#define YY_TRACE_ACT(a)		fprintf(YY_XERR, " #%d\n", (a))

#else

#define YY_TRACE_TRANSIT(s, c)
#define YY_TRACE_END(s)
#define YY_TRACE_REJECT(s)
#define YY_TRACE_ACT(a)

#endif /* ifdef YYTRACE */

/* We need action numbers if YY_USER_ACTION is defined or YYTRACE is
 * defined.  The following clumsy code sets up YY_HAS_ACTION_NUMBERS 
 * without using the cpp `defined' operator. 
 */
#ifdef YYTRACE
#define YY_HAS_ACTION_NUMBERS 1
#else
#ifdef YY_USER_ACTION
#define YY_HAS_ACTION_NUMBERS 1
#else
#define YY_HAS_ACTION_NUMBERS 0
#endif
#endif

#if YY_HAS_ACTION_NUMBERS
#define YY_SET_ACT()							\
  do { yyAct= yyState < YY_N_STATES ? yyActs[yyState] : 0; } while (0)
#define yy_act	yyAct		/* For flex compatibility. */ 
#else
#define YY_SET_ACT()
#endif

/* Set up correct start-state at start of scanning. */
#if (YY_N_START_STATES == 1 && YY_START_OF_LINE == 0)
#define YY_START	0
#elif (YY_N_START_STATES == 1 && YY_START_OF_LINE == 1)
#define YY_START	(yyBuf.lastCh == '\n')
#elif (YY_N_START_STATES > 1 && YY_START_OF_LINE == 0)
#define YY_START	(yyData.startState)
#else
#define YY_START	(yyData.startState + (yyBuf.lastCh == '\n'))
#endif

/* For flex and AT&T compatibility. */
#define YYSTATE		YY_START


/* The following macros are used for initializing entries in the next[]
 * table.
 * YY_B(offset): 
 *		A macro used for initializing the base[] vector to point
 *		to next[offset] (using offset as an index if TABLE ==
 *		STATE_TABLE; using an address otherwise).
 * YY_N1(s0, s1): 
 *		A macro which represents the transition from significant 
 *		state s0 (which for TABLE != STATE_TABLE is represented 
 *		by its base value in next[]) to significant state s1 (which
 *		for TABLE != STATE_TABLE is represented by its base
 *		value in next[]). 
 * YY_N2(s0, s1): 
 *		A macro which represents the transition from significant 
 *		state s0 (which for TABLE != STATE_TABLE is represented 
 *		by its base value in next[]) to non-significant or
 *		pseudo-state s1.
 * YY_S(s):	
 *		A macro used for storing a state number when compressed 
 *		(stored at YY_STATE_INDEX offset from the base of the state).
 */
#if YY_TABLE_ENTRY == YY_ADDRESS_TABLE
#define YY_B(offset) (&yyTab.next[offset])
#define YY_N1(s0Base, s1Base) (&yyTab.next[s1Base])
#define YY_N2(s0Base, s1) ((YYNext *)(&yyTab.u.dummy[(s1) - YY_N_SIG_STATES]))
#define YY_S(s)	((YY_CONST YYNext *)(s))
#elif YY_TABLE_ENTRY == YY_DIFF_TABLE
/* By converting pointers to char* pointers, we can avoid an index*size
 * multiplication at runtime; also makes it possible for dummy[] to be
 * a char vector.  Disadvantage is that values may not fit within short.
 * The definition of YY_N2 uses array indices of 0 and makes explicit 
 * the address arithmetic.
 */
#define YY_B(offset) (&yyTab.next[offset])
#define YY_N1(s0Base, s1Base)						\
  ((s1Base - s0Base)*((int)sizeof(YYNext)))
#define YY_N2(s0Base, s1)						\
  ((&yyTab.u.dummy[0] - (char*)(&yyTab.next[0]))			\
   + ((s1) - YY_N_SIG_STATES)*((int)sizeof(char)) 			\
   - (s0Base)*((int)sizeof(YYNext)))
#define YY_S(s)	(s)
#else
#define YY_B(offset) (offset)
#define YY_N1(s0, s1) (s1)
#define YY_N2(s0, s1) (s1)
#define YY_S(s)	(s)
#endif

/* Decode next state tables.  9 possibilities for tables (3 compress 
 * options x 3 table-entry options).  Define following macros and
 * typedefs:
 *
 * YYTState:	A typedef used for states within transition loops.
 * YY_SIG_STATE_NUM(s)/YY_NON_SIG_STATE_NUM(s):  
 *		Convert from a significant/non-significant YYTState 
 *		to a normal numeric state.
 * YY_NUM_STATE_TO_T_STATE(s):
 *		Convert from  significant numeric state to a YYTState.
 * YY_SIG_LIMIT: A YYTState must be < this to be significant.
 * YY_D1(s0, def, isTerminal):
 *		A macro used for initializing the default for state s0
 *		(which for TABLE != STATE_TABLE is represented 
 *		by its base value in next[]) to default def (which
 *		for TABLE != STATE_TABLE is represented by its base
 *		value in next[]).  isTerminal is 1 iff the default
 *		is a terminal default which terminates the state
 *		transition iteration.
 * YY_D2(s0, def, isTerminal):
 *		A macro used for initializing the default for state s0
 *		(which for TABLE != STATE_TABLE is represented by its 
 *		base value in next[]) to non-significant or pseudo-state 
 *		default def. isTerminal is 1 iff the default is a terminal 
 *		default which terminates the state transition iteration.
 * YY_SET_NEXT_STATE(ss, c): Set YYTState ss to the next YYTState on
 *		character c.
 *
 * In addition, there are also typedefs for YYNext structures.
 */

#if (YY_COMPRESS == YY_NO_COMPRESS && YY_TABLE_ENTRY == YY_ADDRESS_TABLE)
typedef struct YYNext { YY_CONST struct YYNext *next; } YYNext;
typedef YY_CONST YYNext *YYTState;
#define YY_SIG_STATE_NUM(s)						\
  ((YYState)(((s) - yyTab.next)/YY_N_COLS))
#define YY_NON_SIG_STATE_NUM(s)						\
  (YY_N_SIG_STATES + (((char*)(s)) - yyTab.u.dummy))
#define YY_NUM_STATE_TO_T_STATE(s)	(&yyTab.next[(s)*YY_N_COLS])
#define YY_SIG_LIMIT							\
  (&yyTab.next[(YY_N_SIG_STATES - 1)*YY_N_COLS + 1])
#undef YY_D1
#undef YY_D2
#define YY_SET_NEXT_STATE(ss, c)					\
  do {									\
    (ss)= (ss)[c].next;							\
  } while (0)

#elif (YY_COMPRESS == YY_NO_COMPRESS && YY_TABLE_ENTRY == YY_DIFF_TABLE)
typedef YYDisp YYNext;
typedef YY_CONST YYNext *YYTState;
#define YY_SIG_STATE_NUM(s)						\
  ((YYState)(((s) - yyTab.next)/YY_N_COLS))
#define YY_NON_SIG_STATE_NUM(s)						\
  (YY_N_SIG_STATES + (((char*)(s)) - yyTab.u.dummy))
#define YY_NUM_STATE_TO_T_STATE(s)	(&yyTab.next[(s)*YY_N_COLS])
#define YY_SIG_LIMIT							\
  (&yyTab.next[(YY_N_SIG_STATES - 1)*YY_N_COLS + 1])
#undef YY_D1
#undef YY_D2
#define YY_SET_NEXT_STATE(ss, c)					\
  do {									\
    YY_CONST char *cs= (char *)(ss);					\
    cs+= (ss)[c];							\
    (ss)= (YYTState)cs;							\
  } while (0)

#elif (YY_COMPRESS == YY_NO_COMPRESS && YY_TABLE_ENTRY == YY_STATE_TABLE)
typedef YYXState YYNext;
typedef YYState YYTState;
#define YY_SIG_STATE_NUM(s)		(s)
#define YY_NON_SIG_STATE_NUM(s)		(s)
#define YY_NUM_STATE_TO_T_STATE(s)	(s)
#define YY_SIG_LIMIT			(YY_N_SIG_STATES)
#undef YY_D1
#undef YY_D2
#define YY_SET_NEXT_STATE(ss, c)					\
  do {									\
    (ss)= yyTab.next[ss][c];						\
  } while (0)

#elif (YY_COMPRESS == YY_COMB_COMPRESS && YY_TABLE_ENTRY == YY_ADDRESS_TABLE)
typedef struct YYNext { YY_CONST struct YYNext *next; YYCheck check; } YYNext;
typedef YY_CONST YYNext *YYTState;
#define YY_SIG_STATE_NUM(s)	((YYState)((s)[YY_STATE_INDEX].next))
#define YY_NON_SIG_STATE_NUM(s)						\
  (YY_N_SIG_STATES + (((char*)(s)) - yyTab.u.dummy))
#define YY_NUM_STATE_TO_T_STATE(numState) (yyTab.u.s.base[numState])
#define YY_SIG_LIMIT	(&yyTab.next[YY_MAX_BASE + 1])
#define YY_D1(s0Base, defBase, isTerminal) YY_N1(s0Base, defBase)
#define YY_D2(s0Base, def, isTerminal) YY_N2(s0Base, def)
#define YY_SET_NEXT_STATE(ss, c)					\
  do {									\
    YY_CONST YYNext *YY_CONST p= &(ss)[c];				\
    (ss)= (p->check == (c)) ? p->next : (ss)[YY_DEF_INDEX].next;	\
  } while (0)

#elif (YY_COMPRESS == YY_COMB_COMPRESS && YY_TABLE_ENTRY == YY_DIFF_TABLE)
typedef struct { YYDisp next; YYCheck check; } YYNext;
typedef YY_CONST YYNext *YYTState;
#define YY_SIG_STATE_NUM(s)	((YYState)((s)[YY_STATE_INDEX].next))
#define YY_NON_SIG_STATE_NUM(s)						\
  (YY_N_SIG_STATES + (((char*)(s)) - yyTab.u.dummy))
#define YY_NUM_STATE_TO_T_STATE(numState) (yyTab.u.s.base[numState])
#define YY_SIG_LIMIT	(&yyTab.next[YY_MAX_BASE + 1])
#define YY_D1(s0Base, defBase, isTerminal) YY_N1(s0Base, defBase)
#define YY_D2(s0Base, def, isTerminal) YY_N2(s0Base, def)
#define YY_SET_NEXT_STATE(ss, c)					\
  do {									\
    YY_CONST YYNext *YY_CONST p= &(ss)[c];				\
    YY_CONST char *sc= (char *)(ss);					\
    sc+= (p->check == (c)) ? p->next : (ss)[YY_DEF_INDEX].next;		\
    (ss)= (YYTState)sc;							\
  } while (0)

#elif (YY_COMPRESS == YY_COMB_COMPRESS && YY_TABLE_ENTRY == YY_STATE_TABLE)
typedef YYXState YYNext;
typedef YYState YYTState;
#define YY_SIG_STATE_NUM(s)		(s)
#define YY_NON_SIG_STATE_NUM(s)		(s)
#define YY_NUM_STATE_TO_T_STATE(s)	(s)
#define YY_SIG_LIMIT			(YY_N_SIG_STATES)
#define YY_D1(_s0Base, def, _isTerminal) (def)
#undef YY_D2
#define YY_SET_NEXT_STATE(ss, c)					\
  do {									\
    YY_CONST unsigned i= yyTab.u.s.base[ss] + (c);			\
    (ss)= (yyTab.check[i] == (c)) ? yyTab.next[i] : yyTab.def[ss];	\
  } while (0)

#elif (YY_COMPRESS == YY_ITERATIVE_COMPRESS && YY_TABLE_ENTRY == YY_ADDRESS_TABLE)
typedef struct YYNext { YY_CONST struct YYNext *next; YYCheck check; } YYNext;
typedef YY_CONST YYNext *YYTState;
#define YY_SIG_STATE_NUM(s)	((YYState)((s)[YY_STATE_INDEX].next))
#define YY_NON_SIG_STATE_NUM(s)						\
  (YY_N_SIG_STATES + (((char*)(s)) - yyTab.u.dummy))
#define YY_NUM_STATE_TO_T_STATE(numState)	(yyTab.u.s.base[numState])
#define YY_SIG_LIMIT	&yyTab.next[YY_MAX_BASE + 1]
#define YY_D1(s0Base, defBase, isTerminal)				\
  ((YYNext*)((((defBase - s0Base)*((int)sizeof(YYNext))) << 1)		\
   | (isTerminal)))
#define YY_D2(s0Base, def, isTerminal)					\
  ((YYNext*)								\
    ((((&yyTab.u.dummy[0] - (char*)&yyTab.next[0])			\
       + (def - YY_N_SIG_STATES) - (s0Base)*((int)sizeof(YYNext)))	\
      << 1)								\
     | (isTerminal)))
#define YY_SET_NEXT_STATE(ss, c)					\
  do {									\
    YY_CONST YYNext *YY_CONST p= &(ss)[c];				\
    if (p->check == (c)) {						\
      (ss)= p->next; break;						\
    }									\
    else {								\
      char *sc= (char*)(ss);						\
      int entry= (int)((ss)[YY_DEF_INDEX].next);			\
      sc+= (entry & ~1)/2; (ss)= (YYNext*)sc;				\
      if (entry & 1) break;						\
    }									\
  } while (1)

#elif (YY_COMPRESS == YY_ITERATIVE_COMPRESS && YY_TABLE_ENTRY == YY_DIFF_TABLE)
typedef struct { YYDisp next; YYCheck check; } YYNext;
typedef YY_CONST YYNext *YYTState;
#define YY_SIG_STATE_NUM(s)	((YYState)((s)[YY_STATE_INDEX].next))
#define YY_NON_SIG_STATE_NUM(s)						\
  (YY_N_SIG_STATES + (((char*)(s)) - yyTab.u.dummy))
#define YY_NUM_STATE_TO_T_STATE(numState) (yyTab.u.s.base[numState])
#define YY_SIG_LIMIT	(&yyTab.next[YY_MAX_BASE + 1])
#define YY_D1(s0Base, defBase, isTerminal)				\
    ((((defBase - s0Base) * ((int)sizeof(YYNext))) << 1) | (isTerminal))
#define YY_D2(s0Base, def, isTerminal)					\
   ((((&yyTab.u.dummy[0] - (char*)&yyTab.next[0])			\
      + (def - YY_N_SIG_STATES) - (s0Base)*((int)sizeof(YYNext)))	\
     << 1)								\
    | (isTerminal))
#define YY_SET_NEXT_STATE(ss, c)					\
  do {									\
    YY_CONST YYNext *YY_CONST p= &(ss)[c];				\
    YY_CONST char *sc= (char *)(ss);					\
    if (p->check == (c)) {						\
      sc+= p->next; (ss)= (YYTState)sc; break;				\
    }									\
    else {								\
      int entry= (ss)[YY_DEF_INDEX].next;				\
      sc+= (entry & ~1)/2; (ss)= (YYTState)sc;	 			\
      if (entry & 1) break;						\
    }									\
  } while (1)

#elif (YY_COMPRESS == YY_ITERATIVE_COMPRESS && YY_TABLE_ENTRY == YY_STATE_TABLE)
typedef YYXState YYNext;
typedef YYState YYTState;
#define YY_SIG_STATE_NUM(s)		(s)
#define YY_NON_SIG_STATE_NUM(s)		(s)
#define YY_NUM_STATE_TO_T_STATE(s)	(s)
#define YY_SIG_LIMIT			(YY_N_SIG_STATES)
#define YY_D1(_s0, def, isTerminal)	(((def)<<1) | (isTerminal))
#undef YY_D2
#define YY_SET_NEXT_STATE(ss, c)					\
  do {									\
    YY_CONST unsigned i= yyTab.u.s.base[ss] + (c);			\
    if (yyTab.check[i] == (c)) {					\
      (ss)= yyTab.next[i]; break;					\
    }									\
    else {								\
      unsigned entry= yyTab.def[ss];					\
      (ss)= entry >> 1;							\
      if (entry & 1) break;						\
    }									\
  } while (1)
#endif


#if (YY_START_OF_LINE == 1)
#if !YY_DO_CODE && !YY_BACKUP_OPTIMIZE
#define YY_SAVE_LAST()							\
  do {									\
    yyLastCh= yyBuf.lastCh; yyBuf.lastCh= yyCP[-1];			\
  } while (0)
#define YY_RESCAN_RESTORE()  do { yyBuf.lastCh= yyLastCh; } while (0)
#else
#define YY_SAVE_LAST()							\
  do {									\
    yyBuf.lastCh= yyCP[-1];						\
  } while (0)
#define YY_RESCAN_RESTORE()
#endif /* if !YY_DO_CODE && !YY_BACKUP_OPTIMIZE */
#else
#define YY_SAVE_LAST()
#define YY_RESCAN_RESTORE()
#endif /* if (YY_START_OF_LINE == 1) */

#if YY_ARRAY
#define YY_COPY_TEXT_TO_ARRAY()						\
  do {									\
    YYChar *src= YY_TEXT0, *dest= YY_TEXT;				\
    YYChar *end= &YY_TEXT0[YY_LENG] + 1;				\
    while (src < end)  *dest++= *src++;					\
  } while (0)
#else
#define YY_COPY_TEXT_TO_ARRAY()
#endif

#if YY_ARRAY
#define YY_RETERMINATE_ARRAY()	YY_TEXT[YY_LENG]= '\0'
#else
#define YY_RETERMINATE_ARRAY()
#endif

/* The following macro is called after matching a context pattern
 * PAT/CONTEXT where the length of PAT is known to be n.
 */
#define YY_SET_LENG(n) 							\
  do {									\
    assert(yyCP == yyBuf.cp);						\
    assert(yyCP == yyData.saveCP);					\
    *yyCP= yyData.saveCh;						\
    YY_LENG= (n); yyData.saveCP= yyBuf.cp= yyCP= YY_TEXT0 + (n);	\
    yyData.saveCh= *yyCP; *yyCP= '\0';					\
    YY_SAVE_LAST();							\
    YY_RETERMINATE_ARRAY();						\
  } while (0)

/* The following macro is called after matching a context pattern
 * PAT/CONTEXT where the length of CONTEXT is known to be n.
 */
#define YY_DEC_LENG(n) 							\
  do {									\
    assert(yyBuf.cp == yyCP);						\
    assert(yyCP == yyData.saveCP);					\
    *yyCP= yyData.saveCh;						\
    YY_LENG-= (n); yyData.saveCP= yyBuf.cp= yyCP-= (n);			\
    yyData.saveCh= *yyCP; *yyCP= '\0';					\
    YY_SAVE_LAST();							\
    YY_RETERMINATE_ARRAY();						\
  } while (0)

#if YY_HAS_INTRA_TOK_PAT

#if YY_N_INTRA_STATES == 0
#define YY_ALT_STATE(s)		YY_JAM_STATE
#else
#define YY_ALT_STATE(s0)						\
  ( ((s0) < YY_N_SIG_STATES + YY_N_INTRA_STATES)			\
    ? yyTab.u.s.intra[(s0) - YY_N_SIG_STATES]				\
    : YY_JAM_STATE							\
  )
#endif

	
#if YY_BACKUP_OPTIMIZE

#define YY_BACKUP(len, string)						\
  do {									\
    if (0 < len && len <= YY_LENG) {					\
      yyBuf.cp= yyReplace(YY_DATA_P, len, string, &yyIntraText);	\
      yyRSP-= len; yyAltState= *yyRSP;					\
    }									\
  } while (0)

#else /* !YY_BACKUP_OPTIMIZE */

#define YY_BACKUP(len, string)						\
  do {									\
    if (0 < len && len <= YY_LENG) {					\
      yyReplace(YY_DATA_P, len, string, &yyIntraText);			\
      yyBuf.cp= yyIntraText; goto yyRescan;				\
    }									\
  } while (0)

#endif /* else !YY_DO_CODE */
#endif /* if YY_HAS_INTRA_TOK_PAT */

/* 		          GLOBAL VARIABLES.				*/

/* 
 * Dummy buffer used for auto-initialization.  dummyBuf[0] will contain a
 * SENTINEL_CHAR to force initialization via yyProcessSentinel();
 * dummyBuf[1] will be overwritten by '\0' by the scanner to terminate
 * YY_TEXT before it realizes this is not a normal token.  At init, cp
 * == &dummyBuf[0] & sentinelP == &dummyBuf[0].  We'd really like to
 * put the dummyBuf within yyData, but can't because some cc's don't
 * allow initializing vars which have circular initialization dependencies.
 */
#define YY_INIT_BUF_SIZE 2
static YYChar yyDummyBuf[YY_INIT_BUF_SIZE];

/* Dummy stack used in 1st pass thru scanning loop at init. time. 	*/
static YYState yyDummyStk[1];	

FILE *YY_IN;			/* Input FILE pointer. */
FILE *YY_OUT;			/* Output FILE pointer. */
FILE *YY_ERR;			/* Error FILE pointer. */

#if YY_ARRAY
YYChar YY_TEXT[YYLMAX];		/* Array containing last matched lexeme. */
#endif
YYChar *YY_TEXT0=		/* Pointer to last matched lexeme in buffer.*/ 
  &yyDummyBuf[0];
int YY_LENG= 0;			/* # of chars in last token matched.	*/

#ifdef YY_ZL_DEBUG
int YY_ZLEX_DEBUG= 1;		/* Flag to turn debug messages on/off. 	*/
#endif

#if YY_LINENO_ACTN
int YY_LINENO= 0;		/* Initialization will increment it. */
#define YY_COL_NUM	(YY_CHAR_NUM - yyBuf.lastLinePos)
#define YY_SET_COL_NUM(c)						\
  do { yyBuf.lastLinePos= YY_CHAR_NUM - (c); } while (0)
#define YY_LINENOP_INIT	(&YY_LINENO)
#else
#define YY_LINENOP_INIT 0
#endif

#if __STDC__
static yy_size_t yyRead (YYChar *buf, yy_size_t nRead);
#else
static yy_size_t yyRead();
#endif

#if __STDC__
int YY_WRAP(void);
#else
int YY_WRAP();
#endif

/* This buffer is used during initialization and to cache the current 
 * dynamically-allocated buffer.
 */
static YYBuf yyBuf= {		
  NULL,				/* yyin */
  &yyDummyBuf[0],		/* buf */
  &yyDummyBuf[1],		/* end */
  YY_INIT_BUF_SIZE,		/* size */
  0,				/* nRead */
  0,				/* intraPos */
  &yyDummyBuf[0],		/* cp */
  0,				/* lastLinePos */
  0,				/* firstNLPos */
  0,				/* lineno */
  '\n',				/* lastCh */
  0,				/* hasNL */
  0				/* eofState */
};

/* Opaque pointer to current buffer.  Read-only for user.
 * It will ALWAYS point to a dynamically allocated  buffer, 
 * or be NULL.
 */
YYBufHandle YY_CURRENT_BUFFER= NULL;

static YYData yyData= {
  &YY_IN,				/* yyinP		*/
  &YY_OUT,				/* yyoutP		*/
  &YY_ERR,				/* yyerrP		*/
  &YY_TEXT0,				/* yytextP		*/
  &YY_LENG,				/* yylengP		*/
  YY_LINENOP_INIT,			/* yylinenoP		*/
  (YYBufP *)&YY_CURRENT_BUFFER,		/* yyCurrentBufP	*/	
  YY_TEXT_ARRAY_INIT,			/* textArray		*/
  &yyBuf,				/* bufP			*/
  yyRead,				/* read()		*/
  YY_WRAP,				/* yywrap()		*/
  &yyDummyBuf[0],			/* saveCP		*/
  &yyDummyBuf[0],			/* sentinelP		*/
  YY_SENTINEL_CHAR,			/* sentinelChar		*/
  '\0',					/* sentinelSave		*/
  YY_SENTINEL_CHAR,			/* saveCh		*/
  YY_INIT_SENTINEL,			/* flags		*/
  YY_OPT_INIT,				/* options		*/
  0,					/* doMore		*/
  NULL,					/* moreText		*/
  0,					/* moreLeng		*/
  NULL,					/* yyTextSave		*/
  0,					/* yyTextSaveSize	*/
  yyDummyStk,				/* stk			*/
  1,					/* stkSize		*/
  0,					/* startState		*/
  NULL					/* ssStkP		*/
};

YY_VOIDP YY_CONST YY_DATA_P= (YY_VOIDP) (&yyData);




/*			     DFA TABLES.				*/

/* The following macro is used for within yyTab. */
#if __STDC__
/* ANSI allows initializing first element of union. */
#define YY_UNION_STRUCT		union
#else
/* Do not assume that a union can be initialized. */
#define YY_UNION_STRUCT		struct
#endif


typedef struct { /* YYTab */
  YYNext next[940];
  YYCheck check[950];
  YYDef def[127];
  YY_UNION_STRUCT {
    struct {
      YYXState sentinel[125];
      YYXState intra[1];
      YYBase base[127];
      YYClass eqClass[256];
    } s;
  } u;
} YYTab;
static YY_CONST YYTab yyTab= {
  { /* next[940] */
      205,   127,    59,   138,    59,   129,   130,    62,   127,   131, 
      132,   133,   134,   127,   127,   135,    54,   127,   127,   127, 
       61,   127,   127,   136,   220,   221,   224,   155,   155,   159, 
       56,    57,   127,   139,   171,    78,    78,   177,    47,    58, 
      137,   127,   211,   127,    59,   145,    59,   129,   130,    60, 
      127,   131,   132,   133,   134,   127,   127,   135,    54,   127, 
      127,   127,    61,   127,   127,   136,    41,   279,   284,    96, 
      279,   190,    56,    57,   127,   139,   226,   227,   279,    84, 
       84,    58,   137,   127,   212,   127,    53,   128,    53,   129, 
      130,   127,   127,   131,   132,   133,   134,   146,   127,   135, 
       54,   127,   127,   127,    55,   127,    67,   136,   311,   191, 
      230,   311,    50,   161,    56,    57,   127,   127,   231,   311, 
       48,   161,    49,    58,   137,   127,   213,   127,    59,   138, 
       59,   129,   130,    60,   127,   131,   132,   133,   134,   146, 
      127,   135,    54,   127,   127,   127,    61,   127,    67,   136, 
      222,   101,   101,   156,   232,   157,    56,    57,   127,   139, 
      236,   292,    51,   166,   292,    58,   137,   127,   210,   200, 
       53,   144,    53,   129,   130,   192,   192,   131,   132,   133, 
      134,    80,   225,   135,    54,   159,    52,   163,    55,    82, 
      118,   136,    66,    66,    66,    66,    66,    66,    56,    57, 
      233,   201,    66,    66,    66,    66,    66,    58,   137,   206, 
      127,    53,   140,    53,   129,   130,   127,   127,   131,   132, 
      133,   134,   127,   244,   135,    54,   244,   259,   127,    55, 
      174,   127,   136,   163,   246,   248,   171,   189,   248,    56, 
       57,   127,   127,   282,    93,   178,   189,   180,    58,   137, 
      127,   207,   127,    59,   141,    59,   129,   130,    60,   127, 
      131,   132,   133,   134,   127,    94,   135,    54,    39,   237, 
      127,    61,   166,   127,   136,   283,    90,   285,   283,   181, 
      285,    56,    57,   127,   139,   290,   272,   238,   194,   272, 
       58,   137,   127,   209,   179,    59,   138,    59,   129,   130, 
       60,   168,   131,   132,   133,   134,   142,   182,   135,    54, 
       65,    65,   114,    61,   114,   291,   136,    42,   291,   169, 
       91,   115,   115,    56,    57,   228,   139,    85,   160,    85, 
       86,   195,    58,   137,   143,   208,   119,    53,   128,    53, 
      129,   130,    87,    87,   131,   132,   133,   134,   142,   195, 
      135,    54,    65,    65,   223,    55,   184,   156,   136,   157, 
      298,   101,   101,   298,   216,    56,    57,   152,   234,   313, 
      122,   164,   313,   165,    58,   137,   143,   203,    72,    59, 
      138,    59,   129,   130,    60,    80,   131,   132,   133,   134, 
      239,   198,   135,    54,    73,    74,   153,    61,   314,    74, 
      136,   314,   315,   318,   168,   315,   194,    56,    57,   202, 
      139,    53,   128,    53,   129,   130,    58,   137,   131,   132, 
      133,   134,   169,    91,   135,    54,     0,   319,   217,    55, 
      319,   152,   136,   114,   199,   114,   172,   115,   115,    56, 
       57,   204,    72,    53,   128,    53,   129,   130,    58,   137, 
      131,   132,   133,   134,   172,   172,   135,    54,    73,    74, 
      153,    55,     0,   100,   136,   276,   100,   100,   276,     0, 
      100,    56,    57,   100,   100,   100,   100,   100,   100,     0, 
       58,   137,   106,   100,   100,   100,   100,   100,    40,    40, 
      320,   218,     0,   320,     0,    40,    40,    40,    40,    40, 
       40,   326,     0,   107,   326,    40,    40,    40,    40,    40, 
       75,   219,   196,     0,     0,    76,    76,    76,    76,    76, 
       76,     0,     0,     0,     0,    76,    76,    76,    76,    76, 
       75,     0,     0,     0,     0,    76,    76,    76,    76,    76, 
       76,     0,     0,   175,   175,    76,    76,    76,    76,    76, 
       40,    40,    40,    40,    40,    40,   177,    92,   170,    92, 
       40,    40,    40,    40,    40,    95,   176,    95,     0,     0, 
        0,    38,     0,    97,    97,    97,    97,    97,    97,    38, 
        0,     0,     0,    97,    97,    98,    97,    97,    96,    99, 
       99,     0,     0,     0,   170,   170,    99,    99,    99,    99, 
       99,    99,   170,   170,   102,   102,    99,    99,    99,    99, 
       99,   102,   102,   102,   102,   102,   102,     0,     0,   103, 
      103,   102,   102,   102,   102,   102,   103,   103,   103,   103, 
      103,   103,     0,     0,   108,   108,   103,   103,   103,   103, 
      103,   108,   108,   108,   108,   108,   108,     0,     0,    97, 
       97,   108,   108,   108,   108,   108,    97,    97,    97,    97, 
       97,    97,     0,     0,    97,    97,    97,    97,    97,    97, 
       97,    97,    97,    97,    97,    97,    97,     0,     0,    99, 
       99,    97,   121,    97,    97,    97,    99,    99,    99,    99, 
       99,    99,     0,     0,   102,   102,    99,    99,    99,    99, 
       99,   102,   102,   102,   102,   102,   102,     0,     0,   103, 
      103,   102,   102,   102,   102,   102,   103,   103,   103,   103, 
      103,   103,     0,     0,   108,   108,   103,   103,   103,   103, 
      103,   108,   108,   108,   108,   108,   108,     0,     0,    97, 
       97,   108,   108,   108,   108,   108,    97,    97,    97,    97, 
       97,    97,     0,     0,    97,    97,    97,    97,    97,   125, 
       97,    97,    97,    97,    97,    97,    97,     0,     0,    97, 
       97,   126,    97,    97,    97,    97,    97,    97,    97,    97, 
       97,    97,   280,     0,     0,     0,    97,    97,    97,    97, 
       97,   214,   215,   110,   147,   147,   148,   148,   186,    70, 
       70,   229,     0,    85,   160,    85,    86,    71,    71,   271, 
        0,     0,   271,     0,   271,     0,     0,   271,    87,    87, 
        0,   306,     0,     0,   306,   271,   306,   120,   120,   306, 
      149,   149,   150,   150,   120,   120,   120,   306,    92,   170, 
       92,    95,   176,    95,   120,   312,   235,     0,   271,   164, 
      271,   165,    38,     0,     0,    38,   110,   123,   123,     0, 
      306,   312,   306,     0,   123,   123,   123,   245,   247,     0, 
      187,   193,   188,   197,   123,   170,   170,    74,   170,   170, 
      120,   120,     0,   123,   123,     0,     0,   120,   120,   120, 
      123,   123,   123,     0,     0,     0,     0,   120,    44,    46, 
      123,   281,   288,     0,   187,   193,   188,   288,   307,     0, 
        0,   307,     0,     0,     0,     0,   179,     0,     0,     0, 
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
        0,     0,    44,    46,     0,     0,     0,     0,     0,    42
  } /* next[940] */
  ,
  { /* check[950] */
        0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
       10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
       20,    21,    22,    23,     0,     0,     0,     3,     3,     3, 
       30,    31,    32,    33,    11,    11,    11,     7,    25,    39, 
       40,    41,     0,     1,     2,     3,     4,     5,     6,     7, 
        8,     9,    10,    11,    12,    13,    14,    15,    16,    17, 
       18,    19,    20,    21,    22,    23,    36,     0,     0,    39, 
        3,     3,    30,    31,    32,    33,     0,     0,    11,     3, 
        3,    39,    40,    41,     0,     1,     2,     3,     4,     5, 
        6,     7,     8,     9,    10,    11,    12,    13,    14,    15, 
       16,    17,    18,    19,    20,    21,    22,    23,     0,    41, 
        0,     3,    37,     3,    30,    31,    32,    33,     0,    11, 
       35,     3,    28,    39,    40,    41,     0,     1,     2,     3, 
        4,     5,     6,     7,     8,     9,    10,    11,    12,    13, 
       14,    15,    16,    17,    18,    19,    20,    21,    22,    23, 
        0,    17,    18,     3,     0,     5,    30,    31,    32,    33, 
        0,     0,    26,     3,     3,    39,    40,    41,     0,    34, 
        2,     3,     4,     5,     6,     2,     3,     9,    10,    11, 
       12,    31,     0,    15,    16,     3,    22,    33,    20,     7, 
       29,    23,    24,    25,    26,    27,    28,    29,    30,    31, 
        0,    22,    34,    35,    36,    37,    38,    39,    40,     0, 
        1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
       11,    12,    13,     0,    15,    16,     3,     0,    19,    20, 
        3,    22,    23,    33,     0,     0,    11,     3,     3,    30, 
       31,    32,    33,     0,    17,    33,     3,    11,    39,    40, 
       41,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
        9,    10,    11,    12,    13,    38,    15,    16,    20,     0, 
       19,    20,     3,    22,    23,     0,     7,     0,     3,    32, 
        3,    30,    31,    32,    33,     0,     0,     0,     3,     3, 
       39,    40,    41,     0,     8,     2,     3,     4,     5,     6, 
        7,    14,     9,    10,    11,    12,    13,    19,    15,    16, 
       17,    18,     2,    20,     4,     0,    23,    31,     3,    32, 
       33,    17,    18,    30,    31,     0,    33,     2,     3,     4, 
        5,    14,    39,    40,    41,     0,    17,     2,     3,     4, 
        5,     6,    17,    18,     9,    10,    11,    12,    13,    32, 
       15,    16,    17,    18,     0,    20,    32,     3,    23,     5, 
        0,    17,    18,     3,     0,    30,    31,     3,     0,     0, 
       17,     3,     3,     5,    39,    40,    41,     0,    14,     2, 
        3,     4,     5,     6,     7,    31,     9,    10,    11,    12, 
        0,    17,    15,    16,    30,    31,    32,    20,     0,    31, 
       23,     3,     0,     0,    14,     3,     3,    30,    31,     0, 
       33,     2,     3,     4,     5,     6,    39,    40,     9,    10, 
       11,    12,    32,    33,    15,    16,    42,     0,     0,    20, 
        3,     3,    23,     2,    17,     4,    14,    17,    18,    30, 
       31,     0,    14,     2,     3,     4,     5,     6,    39,    40, 
        9,    10,    11,    12,    32,    33,    15,    16,    30,    31, 
       32,    20,    42,    14,    23,     0,    17,    18,     3,    42, 
       21,    30,    31,    24,    25,    26,    27,    28,    29,    42, 
       39,    40,    17,    34,    35,    36,    37,    38,    17,    18, 
        0,     0,    42,     3,    42,    24,    25,    26,    27,    28, 
       29,     0,    42,    38,     3,    34,    35,    36,    37,    38, 
       19,     0,    41,    42,    42,    24,    25,    26,    27,    28, 
       29,    42,    42,    42,    42,    34,    35,    36,    37,    38, 
       19,    42,    42,    42,    42,    24,    25,    26,    27,    28, 
       29,    42,    42,    17,    18,    34,    35,    36,    37,    38, 
       24,    25,    26,    27,    28,    29,     7,     2,     3,     4, 
       34,    35,    36,    37,    38,     2,     3,     4,    42,    42, 
       42,    16,    42,    24,    25,    26,    27,    28,    29,    16, 
       42,    42,    42,    34,    35,    36,    37,    38,    39,    17, 
       18,    42,    42,    42,    39,    40,    24,    25,    26,    27, 
       28,    29,    39,    40,    17,    18,    34,    35,    36,    37, 
       38,    24,    25,    26,    27,    28,    29,    42,    42,    17, 
       18,    34,    35,    36,    37,    38,    24,    25,    26,    27, 
       28,    29,    42,    42,    17,    18,    34,    35,    36,    37, 
       38,    24,    25,    26,    27,    28,    29,    42,    42,    17, 
       18,    34,    35,    36,    37,    38,    24,    25,    26,    27, 
       28,    29,    42,    42,    17,    18,    34,    35,    36,    37, 
       38,    24,    25,    26,    27,    28,    29,    42,    42,    17, 
       18,    34,    35,    36,    37,    38,    24,    25,    26,    27, 
       28,    29,    42,    42,    17,    18,    34,    35,    36,    37, 
       38,    24,    25,    26,    27,    28,    29,    42,    42,    17, 
       18,    34,    35,    36,    37,    38,    24,    25,    26,    27, 
       28,    29,    42,    42,    17,    18,    34,    35,    36,    37, 
       38,    24,    25,    26,    27,    28,    29,    42,    42,    17, 
       18,    34,    35,    36,    37,    38,    24,    25,    26,    27, 
       28,    29,    42,    42,    17,    18,    34,    35,    36,    37, 
       38,    24,    25,    26,    27,    28,    29,    42,    42,    17, 
       18,    34,    35,    36,    37,    38,    24,    25,    26,    27, 
       28,    29,     0,    42,    42,    42,    34,    35,    36,    37, 
       38,     0,     0,    11,     3,     3,     5,     5,    16,     8, 
        8,     0,    42,     2,     3,     4,     5,    16,    16,     0, 
       42,    42,     3,    42,     5,    42,    42,     8,    17,    18, 
       42,     0,    42,    42,     3,    16,     5,    17,    18,     8, 
       39,    39,    41,    41,    24,    25,    26,    16,     2,     3, 
        4,     2,     3,     4,    34,     0,     0,    42,    39,     3, 
       41,     5,    16,    42,    42,    16,    11,    17,    18,    42, 
       39,    16,    41,    42,    24,    25,    26,     0,     0,    42, 
        3,     3,     5,     5,    34,    39,    40,    31,    39,    40, 
       17,    18,    42,    17,    18,    42,    42,    24,    25,    26, 
       24,    25,    26,    42,    42,    42,    42,    34,    31,    31, 
       34,     0,     0,    42,     3,     3,     5,     5,     0,    42, 
       42,     3,    42,    42,    42,    42,     8,    42,    42,    42, 
       42,    42,    42,    42,    42,    42,    42,    42,    42,    42, 
       42,    42,    31,    31,    42,    42,    42,    42,    42,    31, 
       42,    42,    42,    42,    42,    42,    42,    42,    42,    42
  } /* check[950] */
  ,
  { /* def[127] */
    YY_D1(0, 127, 1), YY_D1(0, 127, 1), YY_D1(0, 127, 1), YY_D1(0, 63, 1), 
    YY_D1(0, 64, 1), YY_D1(0, 64, 1), YY_D1(0, 127, 1), YY_D1(0, 127, 1), 
    YY_D1(0, 127, 1), YY_D1(0, 66, 1), YY_D1(0, 68, 1), YY_D1(0, 68, 1), 
    YY_D1(0, 69, 1), YY_D1(0, 69, 1), YY_D1(0, 151, 1), YY_D1(0, 151, 1), 
    YY_D1(0, 154, 1), YY_D1(0, 154, 1), YY_D1(0, 77, 1), YY_D1(0, 77, 1), 
    YY_D1(0, 79, 1), YY_D1(0, 79, 1), YY_D1(0, 158, 1), YY_D1(0, 81, 1), 
    YY_D1(0, 83, 1), YY_D1(0, 83, 1), YY_D1(0, 158, 1), YY_D1(0, 158, 1), 
    YY_D1(0, 88, 1), YY_D1(0, 88, 1), YY_D1(0, 162, 1), YY_D1(0, 162, 1), 
    YY_D1(0, 151, 1), YY_D1(0, 151, 1), YY_D1(0, 89, 1), YY_D1(0, 89, 1), 
    YY_D1(0, 167, 1), YY_D1(0, 167, 1), YY_D1(0, 240, 1), YY_D1(0, 241, 1), 
    YY_D1(0, 242, 1), YY_D1(0, 243, 1), YY_D1(0, 105, 1), YY_D1(0, 43, 1), 
    YY_D1(0, 43, 1), YY_D1(0, 45, 1), YY_D1(0, 45, 1), YY_D1(0, 249, 1), 
    YY_D1(0, 250, 1), YY_D1(0, 251, 1), YY_D1(0, 252, 1), YY_D1(0, 253, 1), 
    YY_D1(0, 254, 1), YY_D1(0, 255, 1), YY_D1(0, 256, 1), YY_D1(0, 257, 1), 
    YY_D1(0, 258, 1), YY_D1(0, 173, 1), YY_D1(0, 260, 1), YY_D1(0, 261, 1), 
    YY_D1(0, 262, 1), YY_D1(0, 263, 1), YY_D1(0, 264, 1), YY_D1(0, 265, 1), 
    YY_D1(0, 266, 1), YY_D1(0, 267, 1), YY_D1(0, 268, 1), YY_D1(0, 269, 1), 
    YY_D1(0, 270, 1), YY_D1(0, 104, 1), YY_D1(0, 105, 1), YY_D1(0, 273, 1), 
    YY_D1(0, 274, 1), YY_D1(0, 275, 1), YY_D1(0, 183, 1), YY_D1(0, 277, 1), 
    YY_D1(0, 278, 1), YY_D1(0, 109, 1), YY_D1(0, 185, 1), YY_D1(0, 43, 1), 
    YY_D1(0, 43, 1), YY_D1(0, 111, 1), YY_D1(0, 112, 1), YY_D1(0, 113, 1), 
    YY_D1(0, 286, 1), YY_D1(0, 287, 1), YY_D1(0, 45, 1), YY_D1(0, 289, 1), 
    YY_D1(0, 116, 1), YY_D1(0, 117, 1), YY_D1(0, 117, 1), YY_D1(0, 293, 1), 
    YY_D1(0, 294, 1), YY_D1(0, 295, 1), YY_D1(0, 296, 1), YY_D1(0, 297, 1), 
    YY_D1(0, 96, 1), YY_D1(0, 299, 1), YY_D1(0, 300, 1), YY_D1(0, 301, 1), 
    YY_D1(0, 302, 1), YY_D1(0, 303, 1), YY_D1(0, 304, 1), YY_D1(0, 305, 1), 
    YY_D1(0, 104, 1), YY_D1(0, 105, 1), YY_D1(0, 308, 1), YY_D1(0, 309, 1), 
    YY_D1(0, 310, 1), YY_D1(0, 109, 1), YY_D1(0, 185, 1), YY_D1(0, 111, 1), 
    YY_D1(0, 112, 1), YY_D1(0, 113, 1), YY_D1(0, 316, 1), YY_D1(0, 317, 1), 
    YY_D1(0, 116, 1), YY_D1(0, 117, 1), YY_D1(0, 124, 1), YY_D1(0, 321, 1), 
    YY_D1(0, 322, 1), YY_D1(0, 323, 1), YY_D1(0, 324, 1), YY_D1(0, 325, 1), 
    YY_D1(0, 124, 1), YY_D1(0, 327, 1), YY_D1(0, 328, 1)
  } /* def[127] */
  ,
  { /* YY_UNION_STRUCT u */
    { /* struct s */
      { /* sentinel[125] */
          127,   127,   127,   127,   127,   127,   127,   127,   127,   127, 
          127,   127,    69,    69,   151,   151,   154,   154,    77,    77, 
           79,    79,   158,    81,    83,    83,   158,   158,    88,    88, 
          162,   162,   151,   151,    89,    89,   167,   167,   531,   531, 
          531,   531,   105,    43,    43,    45,    45,   531,   531,   531, 
          531,   531,   531,   531,   531,   531,   531,   173,   531,   531, 
          531,   531,   531,   531,   531,   531,   531,   531,   531,   104, 
          105,   531,   531,   531,   183,   531,   531,   109,   185,    43, 
           43,   111,   112,   113,   531,   531,    45,   531,   116,   117, 
          117,   531,   531,   531,   531,   531,    96,   531,   531,   531, 
          531,   531,   531,   531,   104,   105,   531,   531,   531,   109, 
          185,   111,   112,   113,   531,   531,   116,   117,   124,   531, 
          531,   531,   531,   531,   124
      } /* sentinel[125] */
      ,
      { /* intra[1] */
        0
      } /* intra[1] */
      ,
      { /* base[127] */
        YY_B(409), YY_B(377), YY_B(441), YY_B(0), YY_B(209), YY_B(251), 
        YY_B(335), YY_B(293), YY_B(168), YY_B(42), YY_B(84), YY_B(126), 
        YY_B(791), YY_B(792), YY_B(364), YY_B(428), YY_B(491), YY_B(511), 
        YY_B(24), YY_B(25), YY_B(150), YY_B(354), YY_B(26), YY_B(182), 
        YY_B(76), YY_B(77), YY_B(325), YY_B(801), YY_B(110), YY_B(118), 
        YY_B(154), YY_B(200), YY_B(368), YY_B(846), YY_B(160), YY_B(269), 
        YY_B(287), YY_B(390), YY_B(23), YY_B(13), YY_B(471), YY_B(85), 
        YY_B(223), YY_B(867), YY_B(234), YY_B(868), YY_B(235), YY_B(94), 
        YY_B(75), YY_B(136), YY_B(135), YY_B(164), YY_B(179), YY_B(555), 
        YY_B(225), YY_B(248), YY_B(422), YY_B(227), YY_B(526), YY_B(563), 
        YY_B(30), YY_B(248), YY_B(549), YY_B(572), YY_B(449), YY_B(134), 
        YY_B(587), YY_B(212), YY_B(602), YY_B(809), YY_B(286), YY_B(236), 
        YY_B(247), YY_B(288), YY_B(465), YY_B(324), YY_B(617), YY_B(67), 
        YY_B(782), YY_B(901), YY_B(243), YY_B(275), YY_B(68), YY_B(277), 
        YY_B(173), YY_B(310), YY_B(902), YY_B(304), YY_B(285), YY_B(315), 
        YY_B(161), YY_B(317), YY_B(836), YY_B(319), YY_B(810), YY_B(839), 
        YY_B(360), YY_B(632), YY_B(647), YY_B(662), YY_B(449), YY_B(344), 
        YY_B(677), YY_B(692), YY_B(821), YY_B(908), YY_B(353), YY_B(840), 
        YY_B(707), YY_B(108), YY_B(845), YY_B(369), YY_B(398), YY_B(402), 
        YY_B(431), YY_B(420), YY_B(403), YY_B(427), YY_B(490), YY_B(374), 
        YY_B(863), YY_B(722), YY_B(417), YY_B(866), YY_B(501), YY_B(737), 
        YY_B(752)
      } /* base[127] */
      ,
      { /* eqClass[256] */
            0,    1,    1,    1,    1,    1,    1,    1,    1,    2,
            3,    4,    4,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    2,    1,    5,    1,    6,    7,    1,    8,
            9,   10,   11,   12,   13,   14,   15,   16,   17,   17,
           17,   17,   17,   17,   17,   17,   18,   18,   19,    1,
           20,   21,   22,   23,    1,   24,   24,   24,   24,   25,
           26,   27,   27,   27,   27,   27,   27,   27,   27,   28,
           27,   27,   27,   27,   29,   27,   27,   27,   27,   27,
           27,   30,   31,   32,   33,   27,    1,   24,   24,   24,
           24,   34,   24,   27,   27,   35,   27,   27,   36,   27,
           37,   27,   27,   27,   27,   27,   29,   27,   27,   27,
           38,   27,   27,   39,   40,   41,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
            1,    1,    1,    1,    1,    1
      } /* eqClass[256] */
    } /* struct s */
  } /* YY_UNION_STRUCT u */
};
#line 2250 "scan.c"

/* Tables defining actions. */
#if YY_HAS_ACTION_NUMBERS
static YYAct yyActs[202]= {
      0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
      0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
      0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
      0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
      0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
      0,     0,     0,    18,    45,    46,    29,    46,    20,    16, 
     46,    25,    46,     1,     3,     5,     8,    12,    10,    54, 
     53,    55,    96,    98,    98,    60,    59,    65,    64,   109, 
    109,    74,   109,    80,    78,    82,   109,    83,    87,   101, 
    101,   105,    18,    34,    37,    16,    21,     2,     2,     1, 
      3,     5,     8,    10,    54,    53,    90,    92,    59,    65, 
     63,    74,    76,    80,    82,    83,    87,   101,   101,    34, 
     35,     2,    90,    91,   100,     2,     2,    46,    14,    36, 
     44,    27,    28,    39,    40,    43,    41,    42,    14,    26, 
      4,     4,     6,     7,     9,     9,    11,    48,    51,    50, 
     49,    98,    88,    93,    60,    62,    68,    69,   109,    72, 
     81,    86,   103,   102,    89,    95,    99,   108,   107,   106, 
     19,    17,    30,    37,    38,    33,    15,    22,    13,    52, 
     56,    97,    94,    92,    58,    63,    66,    71,    69,    70, 
     75,    73,    79,    85,    86,   104,    32,    84,    34,    90, 
     23,    24
}; /* yyActs[202] */
#line 2277 "scan.c"
#endif /* if YY_HAS_ACTION_NUMBERS */


/* 			SCANNER ROUTINES				*/


static yy_size_t 
#if __STDC__
yyRead (YYChar *buf, yy_size_t nRead) 
#else
yyRead (buf, nRead)
  YYChar *buf;
  yy_size_t nRead;
#endif
{
/* Read upto nRead chars. from YY_IN into buffer buf.  Return # of chars.
 * read or 0 on EOF.  Print error message and abort if read error.
 * This is a call-back routine from the library to allow it to use a
 * user-specified INPUT().
 */
  int result;
  YY_INPUT(buf, result, nRead);
  return result;
}

#if YY_HAS_VAR_CONTEXTS

#if YY_BACKUP_OPTIMIZE

#define YY_VAR_CONTEXT_RESCAN(patStart, contextStart)			\
  yyVarContextRescan(YY_TEXT0, YY_LENG, patStart, contextStart, yyRSP)

#else

#define YY_VAR_CONTEXT_RESCAN(patStart, contextStart)			\
  yyVarContextRescan(YY_TEXT0, YY_LENG, patStart, contextStart, 0)

#endif

#if 0
#define YY_VAR_CONTEXT_RESCAN(patStart, contextStart)			\
  do {
    if (yyVarContext == 0) { /* Entry after PAT/CONTEXT match. */
      yyVarContextText= YY_TEXT0; 
      yyVarContextSentinelP= &YY_TEXT0[YY_LENG]; 
      *yyVarContextSentinelP= YY_SENTINEL_CHAR;
      yyState= patStart; yyCP= YY_TEXT0; yyVarContext= 1; goto yyStateSwitch;
    }
    else if (yyVarContext == 1) { /* Entry after PAT rematch. */
      yyVarContextP= yyCP;
  } while (0)
#endif

/* Call-back routine for variable context rescan.  We need a call-back
 * routine to access next-state tables.  text and leng specifies 
 * pat/context.  Starting in state patStart scan text for longest 
 * match within text.  Then try to get to an accepting state starting
 * in state contextStart with rest of text.  If unsuccessful, shorten
 * pat match and try again for a context match.
 */

#if __STDC__
static YY_VOID 
yyVarContextRescan(YYChar *text, YYUInt leng, 
		   YYState patStart, YYState contextStart,
		   YYState *sp)
#else
static YY_VOID 
yyVarContextAdjust(text, leng, patStart, contextStart, sp)
  YYChar *text;
  YYUInt leng;
  YYState patStart;
  YYState contextStart;
  YYState *sp;
#endif
{  
  YYState *YY_CONST spBase=   
    (sp == NULL || (yyData.stk + yyData.stkSize) - sp < leng) 
    ? (YYState*)malloc(leng * sizeof(YYState))
    : sp;
  YYState *rSP= spBase;
  YYTState tstate= YY_NUM_STATE_TO_T_STATE(patStart);
  YYChar *yyCP= text;
  YY_CONST YYChar *YY_CONST end= text + leng;
  YYState s, state;
  if (!spBase) {
    YY_FATAL("Out of memory for context rescan.");
  }
  do { /* Scan for longest possible match for pattern. */
    unsigned yyChar= YY_CHAR_TO_UNSIGNED(*yyCP++); /* Get next character. */
    unsigned yyEqChar;
    YY_SET_EQ_CLASS(yyEqChar, yyChar);
    *rSP++ = YY_SIG_STATE_NUM(tstate);	/* Remember state in state-stack. */
    assert(yyCP - text == rSP - spBase);	/* rSP, yyCP in sync. */
    YY_SET_NEXT_STATE(tstate, yyEqChar);
  } while (tstate < YY_SIG_LIMIT && yyCP < end);
  state= YY_NON_SIG_STATE_NUM(tstate);
#if 0
  if (state != YY_JAM_STATE) { *rSP++= state; }
#endif
  if (state < YY_N_STATES) { *rSP++= state; }
  do { /* Backup pattern match until context matches. */
    YYTState ts= YY_NUM_STATE_TO_T_STATE(contextStart);
    assert(rSP > spBase);
    do { /* Pop states off stack, until an accepting state is found. */
      state= *--rSP;
    } while (state < YY_N_NON_FINAL_STATES);
    yyCP= text + (rSP - spBase);
    while (ts < YY_SIG_LIMIT && yyCP < end) { /* Scan for context. */
      unsigned yyChar= YY_CHAR_TO_UNSIGNED(*yyCP++); /* Get next character. */
      unsigned yyEqChar; 
      YY_SET_EQ_CLASS(yyEqChar, yyChar);	
      YY_SET_NEXT_STATE(ts, yyEqChar);
    }
    s= (ts < YY_SIG_LIMIT) ? YY_SIG_STATE_NUM(ts) : YY_NON_SIG_STATE_NUM(ts); 
  } while (yyCP < end || s < YY_N_NON_FINAL_STATES);
  leng= rSP - spBase;
  if (spBase != sp) free(spBase);
  YY_SET_LENG(leng);
}

#endif /* if YY_HAS_VAR_CONTEXTS */



/*			MACROS USED WITHIN yylex()			*/


/* Macro to check if we've landed up in a jam-state because of a
 * sentinel char.
 */
#if YY_COMPRESS == YY_NO_COMPRESS && YY_BACKUP_OPTIMIZE
#define YY_JAM_PROCESS()	do { yyState= *--yyRSP; } while (0)
#endif 

#if YY_COMPRESS != YY_NO_COMPRESS && YY_BACKUP_OPTIMIZE
#define YY_JAM_PROCESS()						\
  do {									\
    if (yyChar == YY_SENTINEL_CHAR) {					\
      yyChar++;	/* Set yyChar to any char != YY_SENTINEL_CHAR. */	\
      yyState= YY_SENTINEL_STATE;					\
    }									\
    else {								\
      yyState= *--yyRSP;						\
    }									\
  } while (0)
#endif 

#if YY_COMPRESS == YY_NO_COMPRESS && !YY_BACKUP_OPTIMIZE
#define YY_JAM_PROCESS()						\
  do {									\
    yyCP--;	/* Backup corrects for 1-char overscan. */		\
    /* If jammed, set yyState to state before overscan. */		\
    yyState-= YY_N_STATES;						\
  } while (0)
#endif 

#if YY_COMPRESS != YY_NO_COMPRESS && !YY_BACKUP_OPTIMIZE
#define YY_JAM_PROCESS()						\
  do {									\
    yyCP--;	/* Backup corrects for 1-char overscan. */		\
    if (yyChar == YY_SENTINEL_CHAR) {					\
      yyChar++;	/* Set yyChar to any char != YY_SENTINEL_CHAR. */	\
    } else {  /* We have a jam. */					\
      yyState-= YY_N_STATES;	 /* Set yyState to jam predecessor. */	\
    }									\
  } while (0)
#endif 


/* Macro to rescan the current lexeme, using a slower scan. */
#if !YY_BACKUP_OPTIMIZE && !YY_DO_CODE
#define YY_RESCAN()							\
  do {									\
    *yyData.saveCP= yyData.saveCh;	/* Replace NUL terminator. */	\
    yyLimit= yyCP;							\
    goto yyScan2;							\
  } while (0)
#else
/* We should never get here. */
#define YY_RESCAN() assert(("Bad rescan sentinel" , 0))
#endif /* if !YY_BACKUP_OPTIMIZE && !YY_DO_CODE */


#if YY_BACKUP_OPTIMIZE && !YY_DO_CODE
/* Macro to handle a sentinel action in the action switch. */
#define YY_DO_SENTINEL()						\
  do { /* Sentinel action: cp points just past sentinel char. */	\
    assert(yyCP == yyBuf.cp);	/* Cached yyCP in synch. */		\
    assert(yyCP == yyData.saveCP);/* Just terminated yytext. */		\
    *yyCP= yyData.saveCh;	/* Restore ch. clobbered by '\0'. */	\
    --yyCP;			/* Point to sentinel char. */		\
    yyState= *--yyRSP;		/* yyState to sentinel state pred. */	\
    goto yyDoSentinel;							\
  } while (0)
#else
/* We should never get here. */
#define YY_DO_SENTINEL() assert(0)	/* Bad sentinel. */
#endif /* #if YY_BACKUP_OPTIMIZE && !YY_DO_CODE */


/* Macro to handle a sentinel which resulted in a pseudo sentinel state.
 * Used in the default case in the action switch.
 */
#if !YY_BACKUP_OPTIMIZE && !YY_DO_CODE
#define YY_DO_PSEUDO_SENTINELS()					\
  do {									\
    *yyData.saveCP= yyData.saveCh;	/* Replace NUL terminator. */	\
    yyState-= YY_N_STATES; /* set to sentinel state predecessor. */	\
    goto yyDoSentinel;							\
  } while (0)
#else
/* We shouldn't get here. */
#define YY_DO_PSEUDO_SENTINELS() assert(("Bad pseudo-sentinel" , 0)) 
#endif /* if !YY_BACKUP_OPTIMIZE && !YY_DO_CODE */


/* A utility macro to continue scanning used in several situations. */
#if YY_DO_CODE
#define YY_CONTINUE(codeJamLabel)					\
  do {									\
    if (yyAltState == YY_JAM_STATE) { goto codeJamLabel; }		\
    else { yyState= yyAltState; goto yyStateSwitch; }			\
  } while (0)
#endif


#if !YY_DO_CODE && YY_BACKUP_OPTIMIZE
#define YY_CONTINUE(codeJamLabel)					\
  do {									\
    yyState= yyAltState;						\
    if (yyState < YY_N_SIG_STATES) goto yyContinueScan;			\
    else goto yyEndScan;						\
  } while (0)
#endif


#if !YY_DO_CODE && !YY_BACKUP_OPTIMIZE 
#define YY_CONTINUE(codeJamLabel)					\
  do {									\
    yyState= yyAltState;						\
    if (yyState < YY_N_SIG_STATES) goto yyContinueScan;			\
    else if (yyState != YY_JAM_STATE) goto yyTerminateText;		\
    else { /* Rescan upto (not including) yyLimit. */			\
      yyLimit= yyCP - 1; goto yyScan2;					\
    }									\
  } while (0)
#endif 


/* Macro to perform yylineno action in action switch. */
#if YY_LINENO_ACTN
#define YYLINENO_ACT()							\
  do {									\
    yyCP= yyBuf.cp;							\
    if (!yyBuf.hasNL) { /* no '\n' in current token so far. */		\
      yy_size_t nlPos=  yyBuf.nRead + (yyCP - yyBuf.buf);		\
      if (nlPos > yyBuf.lastLinePos) { /* Not previously counted. */	\
	yyBuf.hasNL= 1; yyBuf.firstNLPos= nlPos;			\
      }									\
    }									\
    assert(yyCP == yyData.saveCP);					\
    *yyCP= yyData.saveCh;						\
    yyAltState= YY_ALT_STATE(yyState);					\
    YY_CONTINUE(yyBackup);						\
 } while (0)
#endif /* #if YY_LINENO_ACTN */


/* Macro which is invoked before the action for any intra-token pattern. */
#define YY_INTRA_PRE(len)						\
  do {									\
   yyAltState= YY_ALT_STATE(yyState);					\
   yyIntraPos= yyBuf.nRead + (yyBuf.cp - yyBuf.buf);			\
   if (yyIntraPos <= yyBuf.intraPos)					\
     goto yyIntraEnd;							\
   yyIntraText= YY_TEXT0; yyIntraLeng= YY_LENG;				\
   YY_TEXT0= yyBuf.cp - (len); YY_LENG= (len);				\
   YY_COPY_TEXT_TO_ARRAY();						\
  } while (0)



/* Macro which is invoked after the action for any intra-token pattern. */
#define YY_INTRA_POST()	 goto yyIntraDone



/*			MAIN SCANNER ROUTINE.				*/


YY_DECL
{
  /* Declare auto vars having full function scope. */ 
  
  register unsigned yyChar;	/* Character read. */
#if YY_DO_CODE
  YYChar *yyLastAcceptCP;	/* CP when last accepted when recorded. */
  YYState yyLastAcceptState;	/* Last accepting state when recorded. */
#endif
#if YY_BACKUP_OPTIMIZE
  YYState *yyStk= yyData.stk;	/* Stack base. */
  register YYState *yyRSP;	/* Stack pointer. */
#endif 
  register YYState yyState;	/* Numeric scanner state. */
  register YYTState yyTState;	/* Transition scanner state. */
  register YYChar *yyCP;	/* Points to next scan char. */
  YYState yyAltState;		/* Used for continuing scanning. */
#if YY_HAS_ACTION_NUMBERS
  unsigned yyAct;		/* Action # to be executed. */
#endif
#if YY_HAS_INTRA_TOK_PAT
  YYChar *yyIntraText;		/* Save area for yytext. */
  int yyIntraLeng;		/* Save area for yyleng. */
  yy_size_t yyIntraPos;		/* Buffer position of point after intra pat. */
#endif	
#if !YY_BACKUP_OPTIMIZE && !YY_DO_CODE
  YYChar *yyLimit;		/* Limit for second slower rescan. */
#endif
#if YY_DO_CODE && !YY_BACKUP_OPTIMIZE 
  static YYChar *yyBackupSaveP= 0;/* Pointer to end of yytext to backup over. */
  YYChar yyBackupSave;		/* Char. originally at yyBackupSaveP. */
#endif
#if !YY_DO_CODE && !YY_BACKUP_OPTIMIZE && YY_START_OF_LINE
  YYChar yyLastCh;		/* Save char before yytext for rescanning. */
#endif
#if YY_DO_REJECT
  YYState yyRejectState;	/* Remember current state here for reject. */
#endif

/* Local declarations made by user. */
#line 207 "scan.l"
#line 207 "scan.l"
/*                       INCLUSIVE START STATES. 			*/
#line 2612 "scan.c"
 
  while (1) { /* Do forever until user action returns or EOF. */

  yyRescan:   /* Come here to restart a scan. */	

    /* Declare and initialize variables used for each scan. */ 
    
#if YY_BACKUP_OPTIMIZE
    yyRSP= yyStk;			/* Initialize stack pointer. */ 
#endif
    yyCP= yyBuf.cp;			/* Cache char. ptr. */
    yyState= YY_START;			/* Set scan state to start state. */
    *yyData.saveCP= yyData.saveCh;	/* Replace NUL terminator. */
    YY_TEXT0= yyCP;			/* Setup yytext. */ 
 
    /* If --yylineno, then update yylineno from last scan. */ 
    
#if YY_LINENO_ACTN
    if (yyBuf.hasNL) {
      YY_CONST YYChar *p;
      for (p= yyBuf.buf + (yyBuf.firstNLPos - 1 - yyBuf.nRead); 
	   p < yyCP; p++) {
        if (*p == '\n') {
	  YY_LINENO++;
  	  yyBuf.lastLinePos= yyBuf.nRead + (p - yyBuf.buf) + 1;
        }
      }
      yyBuf.hasNL= 0;
    }
#endif /* if YY_LINENO_ACTN */
 
#if YY_DO_CODE
    /* Directly encoded DFA. */
#line 2646 "scan.c"
#else /* Table-driven scanner. */
    /* Enter performance-critical inner-loop. */ 
    
  yyContinueScan:	/* Reenter after seeing a sentinel. */
    yyTState= YY_NUM_STATE_TO_T_STATE(yyState);
    do { /* This is the scanner inner-loop. */
      unsigned yyEqChar; 
      yyChar= YY_CHAR_TO_UNSIGNED(*yyCP++); /* Get next character. */
      YY_SET_EQ_CLASS(yyEqChar, yyChar);
#if YY_BACKUP_OPTIMIZE
      *yyRSP++ = YY_SIG_STATE_NUM(yyTState);/* Remember state in state-stack. */
      assert(yyCP - YY_TEXT0 == yyRSP - yyStk);/* sp, cp in sync. */
#endif
      YY_TRACE_TRANSIT(YY_SIG_STATE_NUM(yyTState), yyChar);
      YY_SET_NEXT_STATE(yyTState, yyEqChar);
    } while (yyTState < YY_SIG_LIMIT); 
    yyState= YY_NON_SIG_STATE_NUM(yyTState); 
    YY_TRACE_END(yyState); 
 
    /* Backup to correct for overscanning or for REJECT action. */ 
    
#if YY_BACKUP_OPTIMIZE
  yyEndScan:	/* Label for a sentinel which terminates scan loop. */ 
    if (yyState == YY_JAM_STATE) { 
      YY_JAM_PROCESS();
    }
  yyFindAction: /* Label for rejecting to shorter lexeme or backing up. */
    assert(yyState != YY_JAM_STATE);
    while (yyState < YY_N_NON_FINAL_STATES) {
      /* Pop states off stack, until an accepting state is found. */
      yyState= *--yyRSP; 
      YY_TRACE_REJECT(yyState);
    }
#endif /* #if YY_BACKUP_OPTIMIZE */

#if !YY_BACKUP_OPTIMIZE
  yyEndScan:	/* Label for a sentinel which terminates scan loop. */ 
    if (yyState >= YY_N_STATES) { /* Overscanned. */
      YY_JAM_PROCESS();
    }
#endif /* #if !YY_BACKUP_OPTIMIZE */
 
#endif /* if !YY_DO_CODE Table-driver scanner. */
    /* Compute yyleng; terminate yytext. */ 
    
#if YY_DO_CODE
yyGetRecorded:
  yyCP= yyLastAcceptCP; yyState= yyLastAcceptState;
#endif
  yyTerminateText:
#if YY_BACKUP_OPTIMIZE
    YY_LENG= yyRSP - yyStk; 
    yyData.saveCP= yyBuf.cp= yyCP= YY_TEXT0 + YY_LENG;
    /* yyBuf.cp, sp now in synch. */
#else
    YY_LENG= yyCP - YY_TEXT0;
    yyData.saveCP= yyBuf.cp= yyCP;
#endif	
    YY_SAVE_LAST();
    yyData.saveCh= *yyCP; *yyCP= '\0';
    YY_COPY_TEXT_TO_ARRAY();  /* Copy from buf to yytext[] if %array. */
 
    /* Perform user or fixed scanner action. */ 
    assert(YY_INV(&yyData));
    
#if YY_DO_REJECT
    yyRejectState= yyState; /* Remember original state for doing rejects. */
#endif  
  yyDoAction:		/* For eof and reject actions. */	
    YY_SET_ACT();
    YY_TRACE_ACT(yyAct);
    YY_USER_ACT;
    switch (yyState) { /* Action table. */
/* User actions specified in zlex source file. */
	case -2:
	YY_DEBUG_MSG(291);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 291 "scan.l"
{ G.depth= 1; return CTOK('('); }
	  YY_BREAK;
	case 0:
	yyStateAct0:
	YY_DEBUG_MSG(310);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 310 "scan.l"
{ if (G.depth > 0) eofError(G.delimLineN, ")"); }

#line 312 "scan.l"
/*			EXCLUSIVE START STATES.				*/

	  YY_BREAK;
	case 2:
	  goto yyStateAct0;
	  YY_BREAK;
	case 4:
	  goto yyStateAct0;
	  YY_BREAK;
	case 6:
	  goto yyStateAct0;
	  YY_BREAK;
	case 8:
	  goto yyStateAct0;
	  YY_BREAK;
	case 10:
	  goto yyStateAct0;
	  YY_BREAK;
	case 12:
	YY_DEBUG_MSG(325);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 325 "scan.l"
{ eofError(G.delimLineN, "}"); }

	  YY_BREAK;
	case 14:
	  YY_BREAK;
	case 16:
	YY_DEBUG_MSG(334);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 334 "scan.l"
{ error("EOF within [: ... :]."); }

	  YY_BREAK;
	case 18:
	YY_DEBUG_MSG(341);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 341 "scan.l"
{ eofError(G.delimLineN, "*/"); }

	  YY_BREAK;
	case 20:
	  YY_BREAK;
	case 22:
	YY_DEBUG_MSG(355);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 355 "scan.l"
{ eofError(G.delimLineN, "%}"); }

	  YY_BREAK;
	case 24:
	  YY_BREAK;
	case 26:
	  YY_BREAK;
	case 28:
	  YY_BREAK;
	case 30:
	  YY_BREAK;
	case 32:
	  YY_BREAK;
	case 34:
	  YY_BREAK;
	case 36:
	  YY_BREAK;
	case 38:
	case 39:
	case 40:
	case 41:
	case 42:
	case 43:
	case 44:
	case 45:
	case 46:
	case 47:
	case 48:
	case 49:
	case 50:
	case 51:
	case 52:
	  YY_RESCAN(); YY_BREAK;
	case 53:
	yyStateAct53:
	YY_DEBUG_MSG(252);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 92 || yyRejectState == 95 || \
	 0) goto yyBackup; \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 252 "scan.l"
{ if (G.secN == 2 && !optionsP->wsInPatterns) {
		    if (G.depth > 0) { error("Missing `)'."); G.depth= 0; }
		    BEGIN INDENT; if (action(yytext)) return TOK(ACT_TOK);
		  }
		}
	  YY_BREAK;
	case 54:
	YY_DEBUG_MSG(308);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 308 "scan.l"
{ return CTOK('/'); }
	  YY_BREAK;
	case 55:
	yyStateAct55:
	YY_DEBUG_MSG(309);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 309 "scan.l"
{ yylval.ch= (UChar)yytext[0]; return TOK(CHAR_TOK); }
	  YY_BREAK;
	case 56:
	YY_DEBUG_MSG(289);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 289 "scan.l"
{ BEGIN CLASS; return CTOK('['); }
	  YY_BREAK;
	case 57:
	  goto yyStateAct55;
	  YY_BREAK;
	case 58:
	YY_DEBUG_MSG(259);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 259 "scan.l"
{ if (G.depth) error("Unbalanced parentheses.");
		  BEGIN BRACE; G.delimLineN= G.lineN;  
		  G.depth= 1; if (action(yytext)) return TOK(ACT_TOK);
		}

	  YY_BREAK;
	case 59:
	yyStateAct59:
	YY_DEBUG_MSG(240);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 53; goto yyDoAction; } \
  } while (0) 
#line 240 "scan.l"
{ if (!optionsP->wsInPatterns || G.depth == 0) {
		    BEGIN INDENT; if (action(yytext)) return TOK(ACT_TOK);
		  } 
		}
	  YY_BREAK;
	case 60:
	  goto yyStateAct55;
	  YY_BREAK;
	case 61:
	YY_DEBUG_MSG(275);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 275 "scan.l"
{ if (G.secN == 2) BEGIN SS_USE; 
                  yylval.lineN= G.lineN; return CTOK('<'); 
                }
	  YY_BREAK;
	case 62:
	  goto yyStateAct55;
	  YY_BREAK;
	case 63:
	yyStateAct63:
	YY_DEBUG_MSG(208);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 99 || 0) goto yyBackup; \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 208 "scan.l"
{ yylval.id= getID(yytext, yyleng); return TOK(ID_TOK); }
	  YY_BREAK;
	case 64:
	yyStateAct64:
	YY_DEBUG_MSG(211);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 100 || 0) goto yyBackup; \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 211 "scan.l"
{ addOptionsText(); }
	  YY_BREAK;
	case 65:
	yyStateAct65:
	YY_DEBUG_MSG(215);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 101 || 0) goto yyBackup; \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 215 "scan.l"
{ yylval.num= atoi(yytext); return TOK(NUM_TOK); }
	  YY_BREAK;
	case 66:
	yyStateAct66:
	YY_DEBUG_MSG(219);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 102 || 0) goto yyBackup; \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 219 "scan.l"
{ yylval.id= getID(yytext, yyleng); return TOK(SS_ID_TOK); }
	  YY_BREAK;
	case 67:
	YY_DEBUG_MSG(224);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 224 "scan.l"
{ BEGIN INITIAL; return CTOK('>'); }
	  YY_BREAK;
	case 68:
	yyStateAct68:
	YY_DEBUG_MSG(222);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 103 || 0) goto yyBackup; \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 222 "scan.l"
{ yylval.id= getID(yytext, yyleng); return TOK(SS_ID_TOK); }
	  YY_BREAK;
	case 69:
	yyStateAct69:
	YY_DEBUG_MSG(320);
	goto yyLab55;
	  YY_BREAK;
	case 70:
	yyStateAct70:
	YY_DEBUG_MSG(319);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 105 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 319 "scan.l"
{ warn("Unterminated C character-constant."); }
	  YY_BREAK;
	case 71:
	YY_DEBUG_MSG(321);
  yyLab55:
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 104 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 321 "scan.l"
#line 321 "scan.l"
{ COPY(); }
	  YY_BREAK;
	case 72:
	YY_DEBUG_MSG(407);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 73; goto yyDoAction; } \
  } while (0) 
#line 407 "scan.l"
{ return CTOK('-'); }
	  YY_BREAK;
	case 73:
	yyStateAct73:
	YY_DEBUG_MSG(409);
  yyLab93:
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 181 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 409 "scan.l"
#line 409 "scan.l"
{ yylval.ch= (UChar)yytext[0]; return TOK(CHAR_TOK); }

	  YY_BREAK;
	case 74:
	  goto yyStateAct73;
	  YY_BREAK;
	case 75:
	yyStateAct75:
	YY_DEBUG_MSG(331);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 331 "scan.l"
{ error("Invalid character within [: ... :]."); 
                          BEGIN LAST_STATE();
                        }
	  YY_BREAK;
	case 76:
	yyStateAct76:
	YY_DEBUG_MSG(328);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 108 || 0) goto yyBackup; \
    { yyState= 75; goto yyDoAction; } \
  } while (0) 
#line 328 "scan.l"
{ yylval.id= getID(yytext, yyleng); 
                          return TOK(ID_TOK); 
			}
	  YY_BREAK;
	case 77:
	yyStateAct77:
	YY_DEBUG_MSG(339);
  yyLab63:
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 109 || yyRejectState == 110 || \
	 yyRejectState == 185 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 338 "scan.l"
#line 339 "scan.l"
#line 339 "scan.l"
{ XCOPY(); }
	  YY_BREAK;
	case 78:
	YY_DEBUG_MSG(338);
	goto yyLab63;
	  YY_BREAK;
	case 79:
	yyStateAct79:
	  YY_DEFAULT_ACT();
	  YY_BREAK;
	case 80:
	  goto yyStateAct79;
	  YY_BREAK;
	case 81:
	yyStateAct81:
	YY_DEBUG_MSG(352);
	goto yyLab72;
	  YY_BREAK;
	case 82:
	  goto yyStateAct79;
	  YY_BREAK;
	case 83:
	yyStateAct83:
	YY_DEBUG_MSG(361);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 113 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 361 "scan.l"
{ COPY(); }

#line 363 "scan.l"
/* Seen %line directive. */
	  YY_BREAK;
	case 84:
	YY_DEBUG_MSG(357);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 357 "scan.l"
{ G.lineN++; COPY_NL(); 
			  G.depth= 0; BEGIN LAST_STATE(); 
			}
	  YY_BREAK;
	case 85:
	yyStateAct85:
	YY_DEBUG_MSG(365);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 114 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 366 "scan.l"
	  YY_BREAK;
	case 86:
	  goto yyStateAct79;
	  YY_BREAK;
	case 87:
	yyStateAct87:
	YY_DEBUG_MSG(366);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 115 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 366 "scan.l"
{ if (G.lineState) {
                            error("Unexpected number %s in %%line directive.",
                                  yytext);
                          }
                          else {
                            G.lineN= atoi(yytext) - 1;
                          }
                        }
	  YY_BREAK;
	case 88:
	yyStateAct88:
	YY_DEBUG_MSG(387);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 116 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 387 "scan.l"
{ fputs(yytext, G.outFile); }

	  YY_BREAK;
	case 89:
	yyStateAct89:
	YY_DEBUG_MSG(413);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 117 || yyRejectState == 118 || \
	 yyRejectState == 124 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 414 "scan.l"
#line 415 "scan.l"
#line 415 "scan.l"
/*	   EXCLUSIVE START-STATES WITH GUARANTEED LOOKAHEAD.		*/

	  YY_BREAK;
	case 90:
	  goto yyStateAct89;
	  YY_BREAK;
	case 91:
	YY_DEBUG_MSG(421);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 167; goto yyDoAction; } \
  } while (0) 
#line 421 "scan.l"
{ BEGIN CLASS; return CTOK('^'); }
	  YY_BREAK;
	case 92:
	  goto yyStateAct53;
	  YY_BREAK;
	case 93:
	yyStateAct93:
	YY_DEBUG_MSG(297);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 119 || yyRejectState == 198 || \
	 0) goto yyBackup; \
    { yyState= 94; goto yyDoAction; } \
  } while (0) 
#line 297 "scan.l"
{ sscanf(&yytext[1], "%o", &yylval.ch); return TOK(CHAR_TOK); } 
	  YY_BREAK;
	case 94:
	yyStateAct94:
	YY_DEBUG_MSG(300);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 300 "scan.l"
{ yylval.ch= cEscChar((UChar)yytext[1]); return TOK(CHAR_TOK); }
	  YY_BREAK;
	case 95:
	  goto yyStateAct59;
	  YY_BREAK;
	case 96:
	YY_DEBUG_MSG(264);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 264 "scan.l"
{ G.delimLineN= G.lineN; BEGIN DECORATED; 
		  G.depth= 0; if (action(&yytext[2])) return TOK(ACT_TOK);
		}

	  YY_BREAK;
	case 97:
	yyStateAct97:
	YY_DEBUG_MSG(209);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 126 || 0) { yyState= 200; goto yyDoAction; } \
    goto yyBackup; \
  } while (0) 
#line 209 "scan.l"
{ Int t= lexDir(&yytext[1]); if (t >= 0) return t; }

	  YY_BREAK;
	case 98:
	  goto yyStateAct97;
	  YY_BREAK;
	case 99:
	  goto yyStateAct63;
	  YY_BREAK;
	case 100:
	  goto yyStateAct64;
	  YY_BREAK;
	case 101:
	  goto yyStateAct65;
	  YY_BREAK;
	case 102:
	  goto yyStateAct66;
	  YY_BREAK;
	case 103:
	  goto yyStateAct68;
	  YY_BREAK;
	case 104:
	  goto yyStateAct69;
	  YY_BREAK;
	case 105:
	  goto yyStateAct70;
	  YY_BREAK;
	case 106:
	yyStateAct106:
	YY_DEBUG_MSG(395);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 122 || yyRejectState == 199 || \
	 0) goto yyBackup; \
    { yyState= 107; goto yyDoAction; } \
  } while (0) 
#line 395 "scan.l"
{ sscanf(&yytext[1], "%o", &yylval.ch);
			  return TOK(CHAR_TOK);
			} 
	  YY_BREAK;
	case 107:
	yyStateAct107:
	YY_DEBUG_MSG(401);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 401 "scan.l"
{ yylval.ch= cEscChar((UChar)yytext[1]); 
			  return TOK(CHAR_TOK); 
			}
	  YY_BREAK;
	case 108:
	  goto yyStateAct76;
	  YY_BREAK;
	case 109:
	  goto yyStateAct77;
	  YY_BREAK;
	case 110:
	yyStateAct110:
	  YY_DEC_LENG(1);
	YY_DEBUG_MSG(337);
	goto yyLab63;
	  YY_BREAK;
	case 111:
	  goto yyStateAct81;
	  YY_BREAK;
	case 112:
	YY_DEBUG_MSG(354);
  yyLab72:
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 111 || yyRejectState == 112 || \
	 yyRejectState == 190 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 353 "scan.l"
#line 354 "scan.l"
#line 354 "scan.l"
{ COPY(); }
	  YY_BREAK;
	case 113:
	  goto yyStateAct83;
	  YY_BREAK;
	case 114:
	  goto yyStateAct85;
	  YY_BREAK;
	case 115:
	  goto yyStateAct87;
	  YY_BREAK;
	case 116:
	  goto yyStateAct88;
	  YY_BREAK;
	case 117:
	  goto yyStateAct89;
	  YY_BREAK;
	case 118:
	  goto yyStateAct89;
	  YY_BREAK;
	case 119:
	  goto yyStateAct93;
	  YY_BREAK;
	case 120:
	YY_DEBUG_MSG(298);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 298 "scan.l"
{ sscanf(&yytext[2], "%x", &yylval.ch); return TOK(CHAR_TOK); } 
	  YY_BREAK;
	case 121:
	  goto yyStateAct97;
	  YY_BREAK;
	case 122:
	  goto yyStateAct106;
	  YY_BREAK;
	case 123:
	YY_DEBUG_MSG(398);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 398 "scan.l"
{ sscanf(&yytext[2], "%x", &yylval.ch);
			  return TOK(CHAR_TOK);
			} 
	  YY_BREAK;
	case 124:
	YY_DEBUG_MSG(412);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 89; goto yyDoAction; } \
  } while (0) 
#line 412 "scan.l"
{ BEGIN DEFS; }			
	  YY_BREAK;
	case 125:
	  goto yyStateAct97;
	  YY_BREAK;
	case 126:
	  goto yyStateAct97;
	  YY_BREAK;
	case 127:
	  goto yyStateAct55;
	  YY_BREAK;
	case 128:
	yyStateAct128:
	YY_DEBUG_MSG(229);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 138 || yyRejectState == 141 || \
	 yyRejectState == 145 || 0) { yyState= 176; goto yyDoAction; } \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 229 "scan.l"
{ G.lineN++;
		  if (!optionsP->wsInPatterns && G.depth > 0) {
		    error("Missing `)'."); G.depth= 0; BEGIN LAST_STATE();
		  }
		  if ((G.depth == 0 || !optionsP->wsInPatterns) 
		      && G.secN == 2) { 
                    if (action("")) return TOK(ACT_TOK);
                  }
		}	

	  YY_BREAK;
	case 129:
	YY_DEBUG_MSG(299);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 299 "scan.l"
{ BEGIN STR; }
	  YY_BREAK;
	case 130:
	YY_DEBUG_MSG(307);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 307 "scan.l"
{ return CTOK('$'); }
	  YY_BREAK;
	case 131:
	YY_DEBUG_MSG(279);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= -2; goto yyDoAction; } \
  } while (0) 
#line 279 "scan.l"
{ G.depth++; BEGIN INITIAL; return TOK('('); }
	  YY_BREAK;
	case 132:
	YY_DEBUG_MSG(280);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 280 "scan.l"
{ if (G.depth == 0) { 
		    warn("Unbalanced `)'"); 
		  }
		  else {
		    G.depth--;
		  }
		  if (G.depth == 0) BEGIN LAST_STATE();
		  return CTOK(')');
		}
	  YY_BREAK;
	case 133:
	YY_DEBUG_MSG(302);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 302 "scan.l"
{ return CTOK('*'); }
	  YY_BREAK;
	case 134:
	YY_DEBUG_MSG(303);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 303 "scan.l"
{ yylval.lineN= G.lineN; return CTOK('+'); }
	  YY_BREAK;
	case 135:
	YY_DEBUG_MSG(306);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 306 "scan.l"
{ return CTOK('.'); }
	  YY_BREAK;
	case 136:
	YY_DEBUG_MSG(304);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 304 "scan.l"
{ return CTOK('?'); }
	  YY_BREAK;
	case 137:
	YY_DEBUG_MSG(305);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 305 "scan.l"
{ return CTOK('|'); }
	  YY_BREAK;
	case 138:
	  goto yyStateAct128;
	  YY_BREAK;
	case 139:
	YY_DEBUG_MSG(278);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 278 "scan.l"
{ return CTOK('^'); }
	  YY_BREAK;
	case 140:
	yyStateAct140:
	YY_DEBUG_MSG(212);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 128; goto yyDoAction; } \
  } while (0) 
#line 212 "scan.l"
{ G.lineN++; BEGIN DEFS; 
                  yylval.text= getOptionsText(); return TOK(OPTION_VAL_TOK); 
                }
	  YY_BREAK;
	case 141:
	  goto yyStateAct140;
	  YY_BREAK;
	case 142:
	YY_DEBUG_MSG(216);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 216 "scan.l"
{ return CTOK(','); }
	  YY_BREAK;
	case 143:
	YY_DEBUG_MSG(217);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 217 "scan.l"
{ BEGIN LAST_STATE(); return CTOK('}'); }

	  YY_BREAK;
	case 144:
	yyStateAct144:
	YY_DEBUG_MSG(220);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 128; goto yyDoAction; } \
  } while (0) 
#line 220 "scan.l"
{ G.lineN++; BEGIN DEFS; }

	  YY_BREAK;
	case 145:
	  goto yyStateAct144;
	  YY_BREAK;
	case 146:
	YY_DEBUG_MSG(223);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 55; goto yyDoAction; } \
  } while (0) 
#line 223 "scan.l"
{ return CTOK(','); }
	  YY_BREAK;
	case 147:
	YY_DEBUG_MSG(314);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 314 "scan.l"
{ G.lineN++; COPY_NL(); }
	  YY_BREAK;
	case 148:
	YY_DEBUG_MSG(317);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 317 "scan.l"
{ BEGIN CSTR; COPY(); }
	  YY_BREAK;
	case 149:
	YY_DEBUG_MSG(316);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 316 "scan.l"
{ G.depth++; COPY(); }
	  YY_BREAK;
	case 150:
	YY_DEBUG_MSG(315);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 315 "scan.l"
{ COPY(); if (--G.depth == 0) BEGIN INDENT; }
	  YY_BREAK;
	case 151:
	  goto yyStateAct73;
	  YY_BREAK;
	case 152:
	YY_DEBUG_MSG(389);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 389 "scan.l"
{ error("Unterminated character class."); 
			  G.lineN++; BEGIN LAST_STATE(); 
			}
	  YY_BREAK;
	case 153:
	YY_DEBUG_MSG(404);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 73; goto yyDoAction; } \
  } while (0) 
#line 404 "scan.l"
{ BEGIN LAST_STATE(); return CTOK(']'); }
	  YY_BREAK;
	case 154:
	  goto yyStateAct75;
	  YY_BREAK;
	case 155:
	YY_DEBUG_MSG(336);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 336 "scan.l"
{ G.lineN++; XCOPY_NL(); }
	  YY_BREAK;
	case 156:
	YY_DEBUG_MSG(343);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 187; goto yyDoAction; } \
  } while (0) 
#line 343 "scan.l"
{ G.lineN++; COPY_NL(); }
	  YY_BREAK;
	case 157:
	yyStateAct157:
	YY_DEBUG_MSG(344);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 188 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 344 "scan.l"
{ COPY(); BEGIN BRACE; }
	  YY_BREAK;
	case 158:
	  goto yyStateAct79;
	  YY_BREAK;
	case 159:
	YY_DEBUG_MSG(350);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 350 "scan.l"
{ G.lineN++; COPY_NL(); }
	  YY_BREAK;
	case 160:
	YY_DEBUG_MSG(364);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 364 "scan.l"
{ G.lineN++; BEGIN G.retSS; }
	  YY_BREAK;
	case 161:
	yyStateAct161:
	YY_DEBUG_MSG(386);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 194 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 386 "scan.l"
{ fputs(yytext, G.outFile); G.lineN++; }
	  YY_BREAK;
	case 162:
	YY_DEBUG_MSG(418);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 418 "scan.l"
{ INTERNAL_ERROR(); }

	  YY_BREAK;
	case 163:
	YY_DEBUG_MSG(417);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 162; goto yyDoAction; } \
  } while (0) 
#line 417 "scan.l"
{ BEGIN INITIAL; return CTOK('^'); }
	  YY_BREAK;
	case 164:
	YY_DEBUG_MSG(392);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 392 "scan.l"
{ error("Unterminated pattern string."); 
			  G.lineN++; BEGIN LAST_STATE(); 
			}
	  YY_BREAK;
	case 165:
	YY_DEBUG_MSG(406);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 73; goto yyDoAction; } \
  } while (0) 
#line 406 "scan.l"
{ BEGIN LAST_STATE(); }
	  YY_BREAK;
	case 166:
	YY_DEBUG_MSG(411);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 411 "scan.l"
{ G.lineN++; }
	  YY_BREAK;
	case 167:
	YY_DEBUG_MSG(424);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 424 "scan.l"
{ INTERNAL_ERROR(); }

	  YY_BREAK;
	case 168:
	YY_DEBUG_MSG(423);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 167; goto yyDoAction; } \
  } while (0) 
#line 423 "scan.l"
{ BEGIN CLASS; yylval.ch= '-'; return TOK(CHAR_TOK); }
	  YY_BREAK;
	case 169:
	YY_DEBUG_MSG(422);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    { yyState= 167; goto yyDoAction; } \
  } while (0) 
#line 422 "scan.l"
{ BEGIN CLASS; yylval.ch= ']'; return TOK(CHAR_TOK); }
	  YY_BREAK;
	case 170:
	  YY_DEC_LENG(1);
	YY_DEBUG_MSG(257);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 257 "scan.l"
	/* Ignore ws right before action. */

	  YY_BREAK;
	case 171:
	YY_DEBUG_MSG(244);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 244 "scan.l"
{ if (optionsP->wsInPatterns || YY_START == OPTIONS) {
                    G.retSS= YY_START; BEGIN COMMENT; 
		  }
		  else {
		    G.retSS= INDENT; G.depth= 0; G.doCopy= 1; BEGIN COMMENT; 
		    if (action(yytext)) return TOK(ACT_TOK);
		  }
		}
	  YY_BREAK;
	case 172:
	  YY_SET_LENG(1);
	YY_DEBUG_MSG(290);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 290 "scan.l"
{ BEGIN X_CLASS; return CTOK('['); }
	  YY_BREAK;
	case 173:
	  goto yyStateAct94;
	  YY_BREAK;
	case 174:
	  YY_SET_LENG(1);
	YY_DEBUG_MSG(301);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 301 "scan.l"
{ error("Invalid escaped newline."); }
	  YY_BREAK;
	case 175:
	  YY_SET_LENG(1);
	YY_DEBUG_MSG(296);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 296 "scan.l"
{ BEGIN RANGE; return CTOK('{'); }  
	  YY_BREAK;
	case 176:
	YY_DEBUG_MSG(239);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 176 || 0) { yyState= 170; goto yyDoAction; } \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 239 "scan.l"
{ G.lineN++;  /* Ignore blank lines. */ }
	  YY_BREAK;
	case 177:
	YY_DEBUG_MSG(268);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 268 "scan.l"
{ G.secN++; endAct(); BEGIN (G.secN == 2) ? INITIAL : SEC3; 
		  return (G.secN == 3) ? TOK(END_TOK) : TOK(SEC_TOK); 
                }
	  YY_BREAK;
	case 178:
	  YY_SET_LENG(1);
	YY_DEBUG_MSG(225);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 225 "scan.l"
{ BEGIN SS_START; return CTOK('>'); }

#line 227 "scan.l"
/*		PATTERNS FOR ALL INCLUSIVE START STATES.		*/

	  YY_BREAK;
	case 179:
	YY_DEBUG_MSG(318);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 318 "scan.l"
{ COPY(); }
	  YY_BREAK;
	case 180:
	YY_DEBUG_MSG(322);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 322 "scan.l"
{ G.retSS= BRACE; COPY(); 
	                  G.doCopy= TRUE; BEGIN COMMENT; 
			}
	  YY_BREAK;
	case 181:
	  YY_SET_LENG(1);
	YY_DEBUG_MSG(408);
	goto yyLab93;
	  YY_BREAK;
	case 182:
	YY_DEBUG_MSG(405);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 405 "scan.l"
{ BEGIN COLON; return TOK(COLON_BEGIN_TOK); }
	  YY_BREAK;
	case 183:
	  goto yyStateAct107;
	  YY_BREAK;
	case 184:
	YY_DEBUG_MSG(327);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 327 "scan.l"
{ BEGIN CLASS; return TOK(COLON_END_TOK); }
	  YY_BREAK;
	case 185:
	  goto yyStateAct110;
	  YY_BREAK;
	case 186:
	YY_DEBUG_MSG(340);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 340 "scan.l"
{ XCOPY(); BEGIN G.retSS; }
	  YY_BREAK;
	case 187:
	  YY_DEC_LENG(1);
	YY_DEBUG_MSG(346);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    if ( yyRejectState == 187 || 0) goto yyBackup; \
    { yyState= 79; goto yyDoAction; } \
  } while (0) 
#line 346 "scan.l"
{ warn("Unterminated C-string."); 
			  COPY(); BEGIN BRACE; 
			}

	  YY_BREAK;
	case 188:
	  goto yyStateAct157;
	  YY_BREAK;
	case 189:
	  YY_DEC_LENG(1);
	YY_DEBUG_MSG(345);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 345 "scan.l"
{ COPY(); }
	  YY_BREAK;
	case 190:
	  YY_SET_LENG(1);
	YY_DEBUG_MSG(353);
	goto yyLab72;
	  YY_BREAK;
	case 191:
	YY_DEBUG_MSG(351);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 351 "scan.l"
{ BEGIN INDENT; }
	  YY_BREAK;
	case 192:
	  YY_SET_LENG(1);
	YY_DEBUG_MSG(360);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 360 "scan.l"
{ G.lineN++; COPY_NL(); }
	  YY_BREAK;
	case 193:
	  YY_DEC_LENG(1);
	YY_DEBUG_MSG(382);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 382 "scan.l"
{ error(
                            "Unterminated file name in %%line directive."); 
                        }

	  YY_BREAK;
	case 194:
	  goto yyStateAct161;
	  YY_BREAK;
	case 195:
	  YY_SET_LENG(1);
	YY_DEBUG_MSG(420);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 420 "scan.l"
{ return CTOK('^'); }
	  YY_BREAK;
	case 196:
	YY_DEBUG_MSG(292);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 292 "scan.l"
{ yytext[yyleng - 1]= '\0'; 
                  yylval.id= getID(&yytext[1], yyleng - 2);
		  return TOK(MACRO_TOK);
                }
	  YY_BREAK;
	case 197:
	YY_DEBUG_MSG(374);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 374 "scan.l"
{ if (G.lineState < 2) {
                            setSrcFile(); G.lineState= 2;
                          }
                          else {
                            error("Duplicate file name %s in %%line directive.",
			          yytext);
                          }
                        }
	  YY_BREAK;
	case 198:
	  goto yyStateAct93;
	  YY_BREAK;
	case 199:
	  goto yyStateAct106;
	  YY_BREAK;
	case 200:
	YY_DEBUG_MSG(271);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 271 "scan.l"
{ if (optionsP->lexCompat) { REJECT; }
                  else { G.retSS= YY_START; BEGIN LINE; }
                }
	  YY_BREAK;
	case 201:
	YY_DEBUG_MSG(274);
#undef YY_REJECT
#define YY_REJECT \
  do { \
    goto yyBackup; \
  } while (0) 
#line 274 "scan.l"
{ return TOK(EOF_PAT_TOK); }
	  YY_BREAK;
	default:
	  YY_DO_PSEUDO_SENTINELS();
#line 4157 "scan.c"
    } /* switch (yyState) */

    continue;	/* With outer scanning loop. */
    /* Segments of code entered and exited using gotos. */ 
    
  /* Code to process sentinel. */
  
#if YY_DO_CODE
      yyDoSentinel1: /* yyCP points past sentinel char. */
	yyCP--;	/* Point yyCP to sentinel character. */
#endif
      yyDoSentinel: { /* cp points to the sentinel char. */
	assert(*yyCP == YY_SENTINEL_CHAR);
	yyData.saveCP= yyBuf.cp= yyCP;
	yyData.saveCh= YY_SENTINEL_CHAR; *yyCP= '\0';
	YY_LENG= yyCP - YY_TEXT0;
#if YY_DO_CODE && !YY_BACKUP_OPTIMIZE
	if (yyCP == yyBackupSaveP) {
	  
	  *yyBackupSaveP= yyBackupSave; yyBackupSaveP= 0; 
  	  yyCP++; goto yyJamSwitch;

	}
	else 
#endif /* #if !YY_BACKUP_OPTIMIZE */
	if (yyCP != yyData.sentinelP) { /* A sentinel char in input. */
          
	{ yyAltState= 
	    (yyState < 
             sizeof(yyTab.u.s.sentinel)/sizeof(yyTab.u.s.sentinel[0])) 
	    ? yyTab.u.s.sentinel[yyState]
	    : YY_JAM_STATE;
	  yyCP++;	/* Sentinel-char read as normal char. */
#if YY_BACKUP_OPTIMIZE
	  yyRSP++;	/* Adjust stack to recontain sentinel state pred. */
#endif
	  YY_CONTINUE(yyJamSwitch);
	} /* { yyAltState= */
 
	}
	else if (yyBuf.eofState && yyCP >= yyBuf.end) {
	  /* End-of-file sentinel. */ 
          
            if (YY_TEXT0 != yyCP) { /* EOF but need to process current token. */
	      assert(yyState < YY_N_STATES);
	      yyCP++;	/* Make cp point past char. which caused jam. */
#if YY_DO_CODE
	      goto yyJamSwitch;
#else
#if !YY_BACKUP_OPTIMIZE
	      yyState+= YY_N_STATES;
#endif
	      goto yyEndScan;
#endif 
	    }
            else if (yyBuf.eofState == 1) { /* Process <<EOF>> act. */
	      YY_EOF_MSG();
              assert(yyData.saveCh == YY_SENTINEL_CHAR);
              YY_IN= 0; yyBuf.eofState= 2; 
	      yyState= yyData.startState; 
              goto yyDoAction;
            }
            else if (YY_IN) {	/* User has reset yyin in <<EOF>> act. */
              YY_RESTART(YY_IN); 
              continue;		/* Continue with outer scanning loop. */
            }
            else {
              return YY_EOF_OUT;  
            }
 
	}
	else { 
          /* Buffer end, stack overflow or yymore action. */ 
	  
	    assert(yyState < YY_N_SIG_STATES);
	    if ((yyData.flags & YY_INIT_SENTINEL)) { YY_USER_INIT; }
            yyProcessSentinel(&yyData, yyCP - YY_TEXT0);
            yyCP= yyBuf.cp;	/* Recache updated cp. */
#if YY_BACKUP_OPTIMIZE
            yyStk= yyData.stk;	/* Recache stack which may have changed. */
            yyRSP= yyStk + (yyCP - YY_TEXT0);
#endif
#if YY_DO_CODE
            goto yyStateSwitch;	/* Continue scan, sentinel char undone. */
#else
            goto yyContinueScan;/* Continue scan, after sentinel char undone. */
#endif /* #if YY_DO_CODE */
 
        }
      } /* yyDoSentinel */

  /* Code to reject to next lexeme. */ 
  
      yyBackup:
        yyCP= yyBuf.cp;			/* Recache after possible input(). */
        if (YY_TEXT0 + YY_LENG != yyCP) {
	  yyMakeAdjText(&yyData);	/* Ensure yytext ends at cp. */
	  yyCP= yyBuf.cp;
        }
	assert(yyData.saveCP == &YY_TEXT0[YY_LENG]);
        *yyData.saveCP= yyData.saveCh;/* Restore saved char. */
#if YY_DO_CODE
	yyBackupSaveP= &yyCP[-1]; 
	yyBackupSave= *yyBackupSaveP; *yyBackupSaveP= YY_SENTINEL_CHAR;
	yyBuf.cp= YY_TEXT0;
	goto yyRescan;	/* Rescan in outer scanning loop. */
#elif YY_BACKUP_OPTIMIZE	
        yyState= *--yyRSP; 		/* Pop state off stack. */
        goto yyFindAction;
#else
	yyLimit= yyCP - 1;
	goto yyScan2;
#endif /* #if YY_DO_CODE */
 
  /* Code to rescan text relatively slowly. */
  
#if !YY_DO_CODE && !YY_BACKUP_OPTIMIZE
  yyScan2: { /* Label to rescan chars upto but not including yyLimit. */	
    YYState acceptState;
    YYChar *acceptCP;
    yyCP= YY_TEXT0;
    YY_RESCAN_RESTORE(); /* Restore yyBuf.lastCh to get correct start state. */
    yyState= YY_START;
    yyTState= YY_NUM_STATE_TO_T_STATE(yyState);
    do { /* Repetition of inner-loop, but tracking accept states. */
      unsigned yyChar= YY_CHAR_TO_UNSIGNED(*yyCP++); /* Get next character. */
      unsigned yyEqChar; 
      YY_SET_EQ_CLASS(yyEqChar, yyChar);	
      YY_TRACE_TRANSIT(YY_SIG_STATE_NUM(yyTState), yyChar);
      YY_SET_NEXT_STATE(yyTState, yyEqChar);
      yyState= (yyTState < YY_SIG_LIMIT) 
	       ? YY_SIG_STATE_NUM(yyTState)
               : YY_NON_SIG_STATE_NUM(yyTState);
      assert(yyState < YY_N_SIG_STATES);
      if (YY_N_NON_FINAL_STATES <= yyState) {
	acceptState= yyState; acceptCP= yyCP;
      }
    } while (yyCP < yyLimit);
    yyState= acceptState; yyCP= acceptCP;
    goto yyTerminateText;
  } /* yyScan2: */
#endif


  /* Code to windup an intra-token action. */ 
  
#if YY_HAS_INTRA_TOK_PAT
yyIntraDone: 
  yyBuf.intraPos= yyIntraPos;
  YY_TEXT0= yyIntraText; YY_LENG= yyIntraLeng;
yyIntraEnd: {
  yyCP= yyBuf.cp;
  *yyData.saveCP= yyData.saveCh;
  YY_CONTINUE(yyBackup);
} /* yyIntraEnd */
#endif 
 
 
  } /* while (1) loop until return. */
}


/* 			SECTION 3 CODE					*/

#line 426 "scan.l"


/*			TOP-LEVEL SCANNER ROUTINE.			*/

/* Buffer upto 2 tokens and filter tokens from yylex() as follows: 
 * The sequence '|' ACT_TOK converted to NEXT_ACT_TOK (no endAct()).
 * '$' converted to CHAR_TOK if not followed by ACT_TOK or by '|' ACT_TOK.
 * A sequence of consecutive ACT_TOKs replaced by a single one (the first).
 * Calls endAct() after a sequence of ACT_TOKs completed.
 * We buffer only a single semantic value of the last token read from
 * yylex() only when we convert a '$' to a CHAR_TOK.  When we do so,
 * we set a flags and restore yylval from the semantic value buffer
 * at the next entry to this routine.
 * Possibilities of tokens stored in buffer are:
 *    | X  or X where X may have a semantic value.
 */
int 
scan()
{
#define IS_EMPTY()  (bufIndex0 == bufIndex1)
#define IS_FULL()   ((bufIndex1 + 1) % N1 == bufIndex0)
#define READ_TOK(tok)							\
  do {									\
    assert(bufIndex0 <= N);						\
    assert(bufIndex1 <= N);						\
    if (IS_EMPTY()) { /* Buffer is empty. */		\
      tok= yylex();							\
    }									\
    else { /* Get from buffer. Increment read-pointer circularly. */	\
      tok= tokBuf[bufIndex0]; bufIndex0= (bufIndex0 + 1) % N1;		\
    }									\
  } while (0)	
#define SAVE_TOK(tok)							\
  do {									\
    assert(bufIndex0 <= N);						\
    assert(bufIndex1 <= N);						\
    assert(!IS_FULL());							\
    tokBuf[bufIndex1]= tok; bufIndex1= (bufIndex1 + 1) % N1;		\
  } while (0)

  enum {
    N= 2,			/* Max. # of tokens buffered. */
    N1= N + 1			/* 1 extra for circular buffer. */
  };
  static Boolean lastIsAct	/* True if last token delivered was ACT. */
    = FALSE;
  static Int tokBuf[N1];	/* Circular token buffer: 1 extra entry. */
  static Index bufIndex0= 0;	/* Points to next read index for tokBuf[]. */
  static int bufIndex1= 0;	/* Points to next write index for tokBuf[]. */
  static YYSTYPE yylvalBuf;	/* Buffer for single semantic value. */
  static Boolean isLValBuf=	/* True if yylvalBuf contains a value. */
    FALSE;
  int tok;			/* Token to be delivered. */
  if (isLValBuf) { yylval= yylvalBuf; isLValBuf= FALSE; }
  do {
    READ_TOK(tok);
    if (lastIsAct && tok != TOK(ACT_TOK)) { 
      endAct(); lastIsAct= FALSE; 
    }
    if (CTOK_EQ(tok, '|')) {
      int nextTok;
      READ_TOK(nextTok);
      if (TOK_EQ(nextTok, ACT_TOK) && G.secN == 2) {
        tok= TOK(NEXT_ACT_TOK); 
      }
      else {
	SAVE_TOK(nextTok);
      }
    }
    else if (CTOK_EQ(tok, '$')) {
      int nextTok0= yylex();
      assert(IS_EMPTY());
      if (CTOK_EQ(nextTok0, '|')) {		/* '$' '|' */
	int nextTok1= yylex();
	if (TOK_EQ(nextTok1, ACT_TOK)) {	/* '$' '|' ACT_TOK */
	  SAVE_TOK(TOK(NEXT_ACT_TOK));		/* '$' unchanged. */
	}
	else {					/* '$' '|' ^ACT_TOK */
	  assert(isLValBuf == FALSE);
	  yylvalBuf= yylval; isLValBuf= TRUE;
	  SAVE_TOK(nextTok0); SAVE_TOK(nextTok1);
	  tok= TOK(CHAR_TOK); yylval.ch= '$';	/* '$' transformed. */
	}
      }
      else if (TOK_EQ(nextTok0, ACT_TOK)) {	/* '$' ACT_TOK */
	SAVE_TOK(nextTok0);			/* '$' unchanged. */
      }
      else {					/* '$' ^{'|', ACT_TOK} */
	assert(isLValBuf == FALSE);
	yylvalBuf= yylval; isLValBuf= TRUE;
	SAVE_TOK(nextTok0);	
	tok= TOK(CHAR_TOK); yylval.ch= '$';	/* '$' transformed. */
      }
    }
  } while (lastIsAct && TOK_EQ(tok, ACT_TOK));
  if (tok == TOK(ACT_TOK)) lastIsAct= TRUE;
  return tok;
#undef IS_EMPTY
#undef IS_FULL
#undef READ_TOK
#undef SAVE_TOK
}


/*			     LEX DIRECTIVES.				*/

enum { /* Pseudo-token values must be < 0. */
  LINE_PSEUDO_TOK= -1,
  TABLE_PSEUDO_TOK= -2
};

/* Recognize the lex-directive dir and return a corresponding token.
 * Set the next start-state if appropriate.
 */
static Int 
lexDir(dir)
  ConstString dir;
{
  
  if (dir[1] == '\0') {
    switch (toupper(dir[0])) {
      case 'S':
	BEGIN SS_DEF;
	return TOK(START_TOK); 
      case 'X':
	BEGIN SS_DEF;
	return TOK(STARTX_TOK); 
      case 'T':
	BEGIN TABLE;
	return TABLE_PSEUDO_TOK;
      case 'E': case 'K': case 'N': case 'O':
	BEGIN OPTIONS;
        return TOK(LEX_DIR_TOK);
    }
  }
  if (strncmp(dir, "option", 6) == 0) {	/* Allow "option*". */
    BEGIN OPTIONS; return TOK(OPTION_TOK);
  }
  else if (strcmp(dir, "array") == 0) {
    BEGIN OPTIONS; return TOK(ARRAY_OPTION_TOK); 
  }
  else if (strcmp(dir, "pointer") == 0 || strcmp(dir, "ptr") == 0) {
    BEGIN OPTIONS; return TOK(POINTER_OPTION_TOK); 
  }
  else if ((strcmp(dir, "line") == 0)) {
    G.retSS= YY_START; BEGIN LINE; return LINE_PSEUDO_TOK; 
  }
  else {
    error("Invalid zlex directive %s.", dir);
    BEGIN OPTIONS;
    return TOK(LEX_DIR_TOK);
  }
}


/*			TRANSLATE C-ESCAPES.				*/

/* Define values for escape characters which are in ANSI, but not K&R. */
#ifndef BEL
#define BEL		7
#endif

#ifndef VT
#define VT		11
#endif

/* Return the translation of the c-escape-char c. */
static int 
cEscChar(c)
  int c;
{
  switch (c) {
    case 'a':
#if __STDC__
      return '\a';
#else
      return BEL;		/* Ok for ASCII; bad elsewhere. */
#endif
    case 'b':
      return '\b';
    case 'f':
      return '\f';
    case 'n':
      return '\n';
    case 'r':
      return '\r';
    case 't':
      return '\t';
    case 'v':
#if __STDC__
      return '\v';
#else
      return VT;
#endif
    default:
      return c;
  }
}

/*			  ERROR ROUTINES				*/


unsigned 
lineN() 
{
  return G.lineN;
}


static VOID 
eofError(lineN, delimiter)
  Count lineN;
  ConstString delimiter;
{
  errorAtLine("%d: Unexpected EOF.  Expected `%s'.", lineN, delimiter);
}

ConstString
srcName()
{
  return G.srcName; 
}

/* Entered when a %line directive sets a source file name. */
static VOID 
setSrcFile()
{
  Count n= yyleng - 2;
  G.lineSrcName= internText(&yytext[1], n);  /* Used for #line directives. */
  n= translateCEscapes(&yytext[1], yyleng - 2); 
  G.srcName= (n = yyleng - 2)
             ? G.lineSrcName
             : internText(&yytext[1], n);
}


/*			   OPTIONS TEXT ROUTINE				*/

#define OPTIONS_TEXT(i)	A_ACCESS(G.optionsText, Char, i)

/* Add the options word in yytext to current optionsText followed by a 
 * space. 
 */
static VOID
addOptionsText()
{
  ConstString p;
  Index i;
  for (p= yytext; *p != '\0'; p++) {
    i= A_NEXT(G.optionsText);
    OPTIONS_TEXT(i)= *p;
  }
  i= A_NEXT(G.optionsText); OPTIONS_TEXT(i)= ' ';
}

/* Return accumulated options text and reset area index.  Note that the
 * returned text should be completely processed before the next call
 * to addOptionsText().
 */
static ConstString
getOptionsText()
{
  Index i= A_NEXT(G.optionsText);
  OPTIONS_TEXT(i)= '\0';
  A_CUT(G.optionsText, 0);
  return &OPTIONS_TEXT(0);
}

#undef OPTIONS_TEXT


/*		  TEMPORARY FILE & ACTION ROUTINES			*/

/*

Temporary file has following sections:

1 section for declarations in lex file.
1 section for declarations in yylex() function.
n sections for user actions, where n is the number of non-`|' user actions
  in section 2.

for a total of (n + 2) sections.
Some of the sections may be empty.

*/

static VOID 
initTmpFile() 
{
  G.tmpFile= tmpfile();
  if (!G.tmpFile) fatal("Could not open temporary file.");
  VOID_RET();
}

static VOID
terminateTmpFile()
{
  if (fclose(G.tmpFile) == EOF) {
    fatal("Could not close temporary file.");
  }
  VOID_RET();
}

Count 
lineDir(outFile, lineN, fName)
  FILE *outFile;
  Count lineN;
  ConstString fName;
{
  if (optionsP->lineDir) {
    fprintf(outFile, "#line %d \"%s\"\n", lineN, fName);
    return 1;
  }
  else 
    return 0;
}

typedef struct {
  long endOffset;	/* ftell() returned offset of action end. */
} Act;
static AREA (acts, Act, 8, UINT2_MAX);
#define ACTS(a) A_ACCESS(acts, Act, a)

Count 
nSrcActs()
{
  return A_NENTRIES(acts);
}

static VOID 
endAct()
{
  Index a= A_NEXT(acts);
  ACTS(a).endOffset= ftell(G.tmpFile);
}

static Index 
nextAct()
{
  return A_NENTRIES(acts);
}

static Boolean 
action(text)
  ConstString text;
{
  lineDir(G.tmpFile, G.lineN, G.lineSrcName);
  fputs(text, G.tmpFile);
  yylval.actN= nextAct();
  return (G.secN == 2);
}

/* Output source action n to outFile: 0: section 1 definitions; 1: yylex
 * local declarations; 2 ... : scanner actions.  Assumes that outDefs()
 * has been previously called (rewinds G.tmpFile).
 */
Count
outSrcAction(outFile, srcActN)
  FILE *outFile;
  Index srcActN;
{
  long startOffset= (srcActN > 0) ? ACTS(srcActN - 1).endOffset : 0;
  long endOffset= ACTS(srcActN).endOffset;
  Count nLines= 0;
  long i;
  assert(srcActN < A_NENTRIES(acts));
  fseek(G.tmpFile, startOffset, 0); /* Some systems don't know SEEK_SET */
  for (i= startOffset; i < endOffset; i++) {
    CONST int c= getc(G.tmpFile);
    assert(c != EOF);
    if (c == '\n') nLines++;
    fputc(c, outFile);
  }
  return nLines;
}

/* Output section 1 definitions. */
Count
outDefs(outFile)
  FILE *outFile;
{
  rewind(G.tmpFile);
  return outSrcAction(outFile, 0);
}

/* Output local definitions within yylex().  Assumes that last tmpFile
 * output call was to outDefs().
 */
Count
outLocalDecs(outFile)
  FILE *outFile;
{
  return outSrcAction(outFile, 1);
}

Count
outSec3(outFile)
  FILE *outFile;
{
  CONST Count lineNum= G.lineN;
  Count nLines= 0;
  G.outFile= outFile;
  nLines+= lineDir(G.outFile, G.lineN, G.lineSrcName);
  yylex();
  fclose(yyin); yyin= NULL;
  nLines+= G.lineN - lineNum;
  fputs("\n", outFile); nLines++;
  G.outFile= NULL;
  return nLines;
}

Count 
outScanParams(outFile)
  FILE *outFile;
{
  Count nLines= 0;
  fprintf(outFile, "#define YY_SRC_NAME \"%s\"\n",  G.srcName);
  nLines++;
  return nLines;
}



/*			INITIALIZATION.					*/

int 
yywrap()
{
  if (G.argn >= G.argc) {
    return 1;
  }
  else {
    G.srcName= G.lineSrcName= G.argv[G.argn++];
    G.lineN= 1;
    if (strcmp(G.srcName, "-") == 0) {
      clearerr(stdin); yyin= stdin; G.srcName= G.lineSrcName= "<stdin>";
    }
    else {
      yyin= fopen(G.srcName, "r");
      if (!yyin) fatal("Could not open source file %s.", G.srcName);
    }
    return 0;
  }
}

VOID 
initScan(argc, nonOptArgN, argv)
  int argc;
  int nonOptArgN;
  ConstString argv[];
{
  globalsP= MALLOC_VEC(1, Globals);
  INIT_AREA(G.optionsText, Char, 6, UINT2_MAX);
  G.srcName= G.lineSrcName= "<stdin>"; G.secN= G.lineN= 1;
  G.argc= argc; G.argn= nonOptArgN; G.argv= argv;
  G.delimLineN= G.lineState= G.depth= 0;
  G.depth= 0; G.doCopy= FALSE; 
  G.retSS= 0;
  yywrap(); /* Setup first file if any; otherwise default to stdin. */
  initTmpFile();
  BEGIN DEFS;
  VOID_RET();
}

VOID
terminateScan()
{
#if DO_TRACE
  if (files.dumpFile) dumpActs(files.dumpFile);
#endif
  terminateTmpFile();
  delArea(&G.optionsText);
  delArea(&acts);
  FREE(globalsP);
  VOID_RET();
}

#if DO_TRACE
static VOID 
dumpActs(dumpFile)
  FILE *dumpFile;
{
  CONST Index nActs= A_NENTRIES(acts) - 1;
  Index a;
  fputs("SOURCE ACTIONS:\n", dumpFile);
  for (a= 2; a < nActs; a++) {
    fprintf(dumpFile, "%d:\n", a);
    outSrcAction(dumpFile, a);
  }
}
#endif


#ifdef TEST_SCAN

Int 
main(argc, argv)
  Int argc;
  ConstString argv[];
{
  Int tok;
  initID();
  initError(NULL, errorSrc, lineN, NULL);
  initScan(argc, 1, argv);
  options.wsInPatterns= (argc > 1);
  G.outFile= stdout;
  while ((tok= scan())) {
    printf("yytext= `%s'; Token= %s; ", yytext, (ConstString) tok);
    if (strcmp((ConstString) tok, "ID_TOK") == 0) {
      printf("ID= %d; IDText= %s;", 
	     yylval.id, getIDString(yylval.id));
    }
    else if (strcmp((ConstString) tok, "CHAR_TOK") == 0) {
      printf("Char= %c;", yylval.ch);
    }
    else if (strcmp((ConstString) tok, "NUM_TOK") == 0) {
      printf("Number= %d;", yylval.num);
    }
    else if (strcmp((ConstString) tok, "ACT_TOK") == 0) {
      printf("Act #= %d;", yylval.actN);
    }
    printf("\n");
  }
  return 0;
}

#endif

#line 4852 "scan.c"
